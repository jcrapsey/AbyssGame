{
  "version": 3,
  "file": "playcraft.js",
  "sources": [
    "vendors/playcraftengine/playcraftjs/lib/packed.js",
    "vendors/playcraftengine/playcraftjs/lib/playcraft.js",
    "vendors/playcraftengine/playcraftjs/lib/boot.js",
    "vendors/playcraftengine/playcraftjs/lib/ext/box2dweb.2.1a-pc.js",
    "vendors/playcraftengine/playcraftjs/lib/input.js",
    "vendors/playcraftengine/playcraftjs/lib/hashmap.js",
    "vendors/playcraftengine/playcraftjs/lib/tools.js",
    "vendors/playcraftengine/playcraftjs/lib/color.js",
    "vendors/playcraftengine/playcraftjs/lib/debug.js",
    "vendors/playcraftengine/playcraftjs/lib/device.js",
    "vendors/playcraftengine/playcraftjs/lib/sound.js",
    "vendors/playcraftengine/playcraftjs/lib/layer.js",
    "vendors/playcraftengine/playcraftjs/lib/entitylayer.js",
    "vendors/playcraftengine/playcraftjs/lib/tileset.js",
    "vendors/playcraftengine/playcraftjs/lib/tilemap.js",
    "vendors/playcraftengine/playcraftjs/lib/tilelayer.js",
    "vendors/playcraftengine/playcraftjs/lib/entity.js",
    "vendors/playcraftengine/playcraftjs/lib/sprite.js",
    "vendors/playcraftengine/playcraftjs/lib/spritesheet.js",
    "vendors/playcraftengine/playcraftjs/lib/math.js",
    "vendors/playcraftengine/playcraftjs/lib/image.js",
    "vendors/playcraftengine/playcraftjs/lib/scene.js",
    "vendors/playcraftengine/playcraftjs/lib/game.js",
    "vendors/playcraftengine/playcraftjs/lib/loader.js",
    "vendors/playcraftengine/playcraftjs/lib/dataresource.js",
    "vendors/playcraftengine/playcraftjs/lib/components/component.js",
    "vendors/playcraftengine/playcraftjs/lib/components/circle.js",
    "vendors/playcraftengine/playcraftjs/lib/components/poly.js",
    "vendors/playcraftengine/playcraftjs/lib/components/scale.js",
    "vendors/playcraftengine/playcraftjs/lib/components/spin.js",
    "vendors/playcraftengine/playcraftjs/lib/components/physics.js",
    "vendors/playcraftengine/playcraftjs/lib/components/alpha.js",
    "vendors/playcraftengine/playcraftjs/lib/components/joint.js",
    "vendors/playcraftengine/playcraftjs/lib/components/expiry.js",
    "vendors/playcraftengine/playcraftjs/lib/components/originshifter.js",
    "vendors/playcraftengine/playcraftjs/lib/components/spatial.js",
    "vendors/playcraftengine/playcraftjs/lib/components/overlay.js",
    "vendors/playcraftengine/playcraftjs/lib/components/clip.js",
    "vendors/playcraftengine/playcraftjs/lib/components/activator.js",
    "vendors/playcraftengine/playcraftjs/lib/components/input.js",
    "vendors/playcraftengine/playcraftjs/lib/components/fade.js",
    "vendors/playcraftengine/playcraftjs/lib/components/rect.js",
    "vendors/playcraftengine/playcraftjs/lib/components/text.js",
    "vendors/playcraftengine/playcraftjs/lib/components/sprite.js",
    "vendors/playcraftengine/playcraftjs/lib/components/layout.js",
    "vendors/playcraftengine/playcraftjs/lib/components/particleemitter.js",
    "vendors/playcraftengine/playcraftjs/lib/es/entitymanager.js",
    "vendors/playcraftengine/playcraftjs/lib/es/systemmanager.js",
    "vendors/playcraftengine/playcraftjs/lib/systems/system.js",
    "vendors/playcraftengine/playcraftjs/lib/systems/entitysystem.js",
    "vendors/playcraftengine/playcraftjs/lib/systems/physics.js",
    "vendors/playcraftengine/playcraftjs/lib/systems/effects.js",
    "vendors/playcraftengine/playcraftjs/lib/systems/particles.js",
    "vendors/playcraftengine/playcraftjs/lib/systems/input.js",
    "vendors/playcraftengine/playcraftjs/lib/systems/expiry.js",
    "vendors/playcraftengine/playcraftjs/lib/systems/activation.js",
    "vendors/playcraftengine/playcraftjs/lib/systems/render.js",
    "vendors/playcraftengine/playcraftjs/lib/systems/layout.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACliQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;ACnbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACnfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACnkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACt3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;ACzfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourcesContent": [
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * Special include file added to the playcraft library when it's been built and packed. This file is not included\n * when the developer loader is used to run the game.\n */\n\nif (!window.pc)\n    window.pc = {};\n\npc.packed = true;\n",
    "/**\n * Playcraft Engine\n */\n\n/*\n (function (globalNamespace)\n {\n var req = typeof module !== 'undefined' && module.exports\n ? require(\"requirejs\")\n : require;\n\n var pc = {};\n\n pc.start = function ()\n {\n req(\"loader\", function ()\n {\n // loaded\n });\n };\n\n // Always add it to the global namespace\n globalNamespace.pc = pc;\n\n if (typeof define === 'function')\n { // AMD Module\n define(function ()\n {\n return pc;\n });\n } else if (typeof module !== 'undefined' && module.exports)\n { // Node.js Module\n module.exports = pc;\n }\n\n }).call(this);\n */\n\n\nif (!window.pc)\n  window.pc = {};\n\npc.VERSION = '0.5.7';\n\n\n/**\n * Simple javascript loader. Loads sources in a linear order (the order they are added to the loader).\n * This ensures dependencies based on the order of loading. It isn't particularly super efficient, but is\n * generally only used for development; and the difference in loading times over fast connections is minimal.\n * For production deployment you should be packing/minimizing the game into a single file.\n */\npc.JSLoader = function ()\n{\n  this.progress = 0;\n  this.canvasId = null;\n  this.current = 0;\n  this.baseUrl = '';\n  this.started = false;\n  this.finished = false;\n  this._noCacheString = '';\n  this.gameClass = null;\n  this.resources = [];\n\n  /**\n   * Tells the resource loader to disable caching in the browser by modifying the resource src\n   * by appending the current time\n   */\n  this.setDisableCache = function ()\n  {\n    this._noCacheString = '?nocache=' + Date.now();\n  };\n\n  this.setBaseUrl = function (url)\n  {\n    this.baseUrl = url;\n  };\n\n  this.makeUrl = function (src)\n  {\n    return this.baseUrl + src + this._noCacheString;\n  };\n\n  this.add = function (src)\n  {\n    this.resources.push(this.makeUrl(src));\n  };\n\n  this.start = function (canvasId, gameClass)\n  {\n    this.current = 0;\n    this.canvasId = canvasId;\n    this.gameClass = gameClass;\n    this.loadNextScript();\n  };\n\n  this.loadNextScript = function ()\n  {\n    var src = this.resources[this.current];\n    var script = document.createElement(\"script\");\n    script.type = \"application/javascript\";\n    script.src = src;\n\n    script.onload = this.checkAllDone.bind(this);\n    script.onerror = function ()\n    {\n      throw('Could not load javascript file: ' + script.src);\n    };\n\n    console.log('Loading ' + src);\n    document.getElementsByTagName(\"head\")[0].appendChild(script);\n  };\n\n  this.checkAllDone = function ()\n  {\n    if (this.resources.length - 1 == this.current)\n    {\n      this.finished = true;\n      pc.device.boot(this.canvasId, this.gameClass);\n    } else\n    {\n      this.current++;\n      this.loadNextScript();\n    }\n  }\n};\n\n\npc.start = function (canvasId, gameClass, gameBaseUrl, scripts, engineBaseURL)\n{\n  var loader = new pc.JSLoader();\n//    loader.setDisableCache();\n\n  // if we're not packed/minified, then load the source directly here\n  if (pc.packed == undefined)\n  {\n    if (engineBaseURL == undefined)\n      engineBaseURL = '/playcraftjs/lib/';\n    loader.setBaseUrl(engineBaseURL);\n\n    // Externals\n    loader.add('ext/gamecore.js/src/gamecore.js');\n    loader.add('ext/gamecore.js/src/class.js');\n    loader.add('ext/gamecore.js/src/base.js');\n    loader.add('ext/gamecore.js/src/jhashtable.js');\n    loader.add('ext/gamecore.js/src/device.js');\n    loader.add('ext/gamecore.js/src/perf.js');\n    loader.add('ext/gamecore.js/src/linkedlist.js');\n    loader.add('ext/gamecore.js/src/hashlist.js');\n    loader.add('ext/gamecore.js/src/stacktrace.js');\n    loader.add('ext/gamecore.js/src/pooled.js');\n    loader.add('ext/box2dweb.2.1a-pc.js');\n\n    // Playcraft Engine\n    loader.add('boot.js'); // <--- must be first for engine scripts (sets up some translations)\n    loader.add('input.js');\n    loader.add('input.js');\n    loader.add('hashmap.js');\n    loader.add('tools.js');\n    loader.add('color.js');\n    loader.add('debug.js');\n    loader.add('device.js');\n    loader.add('sound.js');\n    loader.add('layer.js');\n    loader.add('imagelayer.js');\n    loader.add('entitylayer.js');\n    loader.add('tileset.js');\n    loader.add('tilemap.js');\n    loader.add('tilelayer.js');\n    loader.add('hextilelayer.js');\n    loader.add('isotilelayer.js');\n    loader.add('entity.js');\n    loader.add('sprite.js');\n    loader.add('spritesheet.js');\n    loader.add('math.js');\n    loader.add('image.js');\n    loader.add('scene.js');\n    loader.add('game.js');\n    loader.add('loader.js');\n    loader.add('dataresource.js');\n    loader.add('components/component.js');\n    loader.add('components/physics.js');\n    loader.add('components/alpha.js');\n    loader.add('components/joint.js');\n    loader.add('components/expiry.js');\n    loader.add('components/originshifter.js');\n    loader.add('components/spatial.js');\n    loader.add('components/overlay.js');\n    loader.add('components/clip.js');\n    loader.add('components/activator.js');\n    loader.add('components/input.js');\n    loader.add('components/fade.js');\n    loader.add('components/spin.js');\n    loader.add('components/scale.js');\n    loader.add('components/rect.js');\n    loader.add('components/poly.js');\n    loader.add('components/circle.js');\n    loader.add('components/text.js');\n    loader.add('components/sprite.js');\n    loader.add('components/layout.js');\n    loader.add('components/mover.js');\n    loader.add('components/particleemitter.js');\n    loader.add('systems/system.js');\n    loader.add('es/entitymanager.js');\n    loader.add('es/systemmanager.js');\n    loader.add('systems/entitysystem.js');\n    loader.add('systems/physics.js');\n    loader.add('systems/effects.js');\n    loader.add('systems/particles.js');\n    loader.add('systems/mover.js');\n    loader.add('systems/input.js');\n    loader.add('systems/expiry.js');\n    loader.add('systems/activation.js');\n    loader.add('systems/render.js');\n    loader.add('systems/layout.js');\n  }\n\n  // now load the game scripts\n  loader.setBaseUrl(gameBaseUrl);\n  for (var i = 0; i < scripts.length; i++)\n    loader.add(scripts[i]);\n\n  loader.start(canvasId, gameClass);\n};\n",
    "\n// first playcraft script loaded -- used to init anything before the rest of the engine is loaded\npc.Hashtable = gamecore.Hashtable;\n\n/**\n * @class pc.Base\n * @augments gamecore.Base\n */\npc.Base = gamecore.Base('pc.Base',\n    /** @lends gamecore.Base */\n    {},\n    /** @lends gamecore.Base.prototype */\n    {});\n\n/**\n * @class pc.Pool\n * @augments gamecore.Pool\n */\npc.Pool = gamecore.Pool.extend('pc.Pool',\n    /** @lends gamecore.Pool */\n    {},\n    /** @lends gamecore.Pool.prototype */\n    {});\n\n/**\n * @class pc.Pooled\n * @augments gamecore.Pooled\n */\npc.Pooled = gamecore.Pooled.extend('pc.Pooled',\n    /** @lends gamecore.Pooled */\n    {},\n    /** @lends gamecore.Pooled.prototype */\n    {});\n\n/**\n * @class pc.LinkedList\n * @augments gamecore.LinkedList\n */\npc.LinkedList = gamecore.LinkedList.extend('pc.LinkedList',\n    /** @lends gamecore.LinkedList */\n    {},\n    /** @lends gamecore.LinkedList.prototype */\n    {});\n\n/**\n * @class pc.LinkedListNode\n * @augments gamecore.LinkedListNode\n */\npc.LinkedListNode = gamecore.LinkedListNode.extend('pc.LinkedListNode',\n    /** @lends gamecore.LinkedListNode */\n    {},\n    /** @lends gamecore.LinkedListNode.prototype */\n    {});\n\n/**\n * @class pc.HashList\n * @augments gamecore.HashList\n */\npc.HashList = gamecore.HashList.extend('pc.HashList',\n    /** @lends gamecore.HashList */\n    {},\n    /** @lends gamecore.HashList.prototype */\n    {});\n\nif (!Function.prototype.bind)\n{\n    Function.prototype.bind = function (oThis)\n    {\n        if (typeof this !== \"function\") // closest thing possible to the ECMAScript 5 internal IsCallable function\n            throw new TypeError(\"Function.prototype.bind - what is trying to be fBound is not callable\");\n\n        var aArgs = Array.prototype.slice.call(arguments, 1),\n            fToBind = this,\n            fNOP = function ()\n            {\n            },\n            fBound = function ()\n            {\n                return fToBind.apply(this instanceof fNOP ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)));\n            };\n\n        fNOP.prototype = this.prototype;\n        fBound.prototype = new fNOP();\n        return fBound;\n    };\n}\n\nif (!Array.prototype.indexOf)\n{\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */)\n    {\n        \"use strict\";\n        if (this == null)\n        {\n            throw new TypeError();\n        }\n        var t = Object(this);\n        var len = t.length >>> 0;\n        if (len === 0)\n        {\n            return -1;\n        }\n        var n = 0;\n        if (arguments.length > 0)\n        {\n            n = Number(arguments[1]);\n            if (n != n)\n            { // shortcut for verifying if it's NaN\n                n = 0;\n            } else if (n != 0 && n != Infinity && n != -Infinity)\n            {\n                n = (n > 0 || -1) * Math.floor(Math.abs(n));\n            }\n        }\n        if (n >= len)\n        {\n            return -1;\n        }\n        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n        for (; k < len; k++)\n        {\n            if (k in t && t[k] === searchElement)\n            {\n                return k;\n            }\n        }\n        return -1;\n    }\n}\n\n\n",
    "/*\n * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the authors be held liable for any damages\n * arising from the use of this software.\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgment in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n/*\n * Original Box2D created by Erin Catto\n * http://www.gphysics.com\n * http://box2d.org/\n *\n * Box2D was converted to Flash by Boris the Brave, Matt Bush, and John Nesky as Box2DFlash\n * http://www.box2dflash.org/\n *\n * Box2DFlash was converted from Flash to Javascript by Uli Hecht as box2Dweb\n * http://code.google.com/p/box2dweb/\n *\n * box2Dweb was modified to utilize Google Closure, as well as other bug fixes, optimizations, and tweaks by Illandril\n * https://github.com/illandril/box2dweb-closure\n *\n * Playcraft additions:\n * - various bug fixes\n * - debug positioning supports the notion of an origin\n *\n */\n\ngoog = {inherits:function (a, b)\n{\n    function c()\n    {\n    }\n\n    c.prototype = b.prototype;\n    a.superClass_ = b.prototype;\n    a.prototype = new c;\n    a.prototype.constructor = a\n}};\ngoog.debug = {};\ngoog.debug.Error = function (a)\n{\n    this.stack = Error().stack || \"\";\n    a && (this.message = \"\" + a)\n};\ngoog.inherits(goog.debug.Error, Error);\ngoog.debug.Error.prototype.name = \"CustomError\";\ngoog.string = {};\ngoog.string.Unicode = {NBSP:\"\\u00a0\"};\ngoog.string.startsWith = function (a, b)\n{\n    return 0 == a.lastIndexOf(b, 0)\n};\ngoog.string.endsWith = function (a, b)\n{\n    var c = a.length - b.length;\n    return 0 <= c && a.indexOf(b, c) == c\n};\ngoog.string.caseInsensitiveStartsWith = function (a, b)\n{\n    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(0, b.length))\n};\ngoog.string.caseInsensitiveEndsWith = function (a, b)\n{\n    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(a.length - b.length, b.length))\n};\ngoog.string.subs = function (a, b)\n{\n    for (var c = 1; c < arguments.length; c++)\n    {\n        var d = (\"\" + arguments[c]).replace(/\\$/g, \"$$$$\"), a = a.replace(/\\%s/, d)\n    }\n    return a\n};\ngoog.string.collapseWhitespace = function (a)\n{\n    return a.replace(/[\\s\\xa0]+/g, \" \").replace(/^\\s+|\\s+$/g, \"\")\n};\ngoog.string.isEmpty = function (a)\n{\n    return/^[\\s\\xa0]*$/.test(a)\n};\ngoog.string.isEmptySafe = function (a)\n{\n    return goog.string.isEmpty(goog.string.makeSafe(a))\n};\ngoog.string.isBreakingWhitespace = function (a)\n{\n    return!/[^\\t\\n\\r ]/.test(a)\n};\ngoog.string.isAlpha = function (a)\n{\n    return!/[^a-zA-Z]/.test(a)\n};\ngoog.string.isNumeric = function (a)\n{\n    return!/[^0-9]/.test(a)\n};\ngoog.string.isAlphaNumeric = function (a)\n{\n    return!/[^a-zA-Z0-9]/.test(a)\n};\ngoog.string.isSpace = function (a)\n{\n    return\" \" == a\n};\ngoog.string.isUnicodeChar = function (a)\n{\n    return 1 == a.length && \" \" <= a && \"~\" >= a || \"\\u0080\" <= a && \"\\ufffd\" >= a\n};\ngoog.string.stripNewlines = function (a)\n{\n    return a.replace(/(\\r\\n|\\r|\\n)+/g, \" \")\n};\ngoog.string.canonicalizeNewlines = function (a)\n{\n    return a.replace(/(\\r\\n|\\r|\\n)/g, \"\\n\")\n};\ngoog.string.normalizeWhitespace = function (a)\n{\n    return a.replace(/\\xa0|\\s/g, \" \")\n};\ngoog.string.normalizeSpaces = function (a)\n{\n    return a.replace(/\\xa0|[ \\t]+/g, \" \")\n};\ngoog.string.collapseBreakingSpaces = function (a)\n{\n    return a.replace(/[\\t\\r\\n ]+/g, \" \").replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g, \"\")\n};\ngoog.string.trim = function (a)\n{\n    return a.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, \"\")\n};\ngoog.string.trimLeft = function (a)\n{\n    return a.replace(/^[\\s\\xa0]+/, \"\")\n};\ngoog.string.trimRight = function (a)\n{\n    return a.replace(/[\\s\\xa0]+$/, \"\")\n};\ngoog.string.caseInsensitiveCompare = function (a, b)\n{\n    var c = (\"\" + a).toLowerCase(), d = (\"\" + b).toLowerCase();\n    return c < d ? -1 : c == d ? 0 : 1\n};\ngoog.string.numerateCompareRegExp_ = /(\\.\\d+)|(\\d+)|(\\D+)/g;\ngoog.string.numerateCompare = function (a, b)\n{\n    if (a == b)\n    {\n        return 0\n    }\n    if (!a)\n    {\n        return-1\n    }\n    if (!b)\n    {\n        return 1\n    }\n    for (var c = a.toLowerCase().match(goog.string.numerateCompareRegExp_), d = b.toLowerCase().match(goog.string.numerateCompareRegExp_), e = Math.min(c.length, d.length), f = 0; f < e; f++)\n    {\n        var g = c[f], h = d[f];\n        if (g != h)\n        {\n            return c = parseInt(g, 10), !isNaN(c) && (d = parseInt(h, 10), !isNaN(d) && c - d) ? c - d : g < h ? -1 : 1\n        }\n    }\n    return c.length != d.length ? c.length - d.length : a < b ? -1 : 1\n};\ngoog.string.encodeUriRegExp_ = /^[a-zA-Z0-9\\-_.!~*'()]*$/;\ngoog.string.urlEncode = function (a)\n{\n    a = \"\" + a;\n    return!goog.string.encodeUriRegExp_.test(a) ? encodeURIComponent(a) : a\n};\ngoog.string.urlDecode = function (a)\n{\n    return decodeURIComponent(a.replace(/\\+/g, \" \"))\n};\ngoog.string.newLineToBr = function (a, b)\n{\n    return a.replace(/(\\r\\n|\\r|\\n)/g, b ? \"<br />\" : \"<br>\")\n};\ngoog.string.htmlEscape = function (a, b)\n{\n    if (b)\n    {\n        return a.replace(goog.string.amperRe_, \"&amp;\").replace(goog.string.ltRe_, \"&lt;\").replace(goog.string.gtRe_, \"&gt;\").replace(goog.string.quotRe_, \"&quot;\")\n    }\n    if (!goog.string.allRe_.test(a))\n    {\n        return a\n    }\n    -1 != a.indexOf(\"&\") && (a = a.replace(goog.string.amperRe_, \"&amp;\"));\n    -1 != a.indexOf(\"<\") && (a = a.replace(goog.string.ltRe_, \"&lt;\"));\n    -1 != a.indexOf(\">\") && (a = a.replace(goog.string.gtRe_, \"&gt;\"));\n    -1 != a.indexOf('\"') && (a = a.replace(goog.string.quotRe_, \"&quot;\"));\n    return a\n};\ngoog.string.amperRe_ = /&/g;\ngoog.string.ltRe_ = /</g;\ngoog.string.gtRe_ = />/g;\ngoog.string.quotRe_ = /\\\"/g;\ngoog.string.allRe_ = /[&<>\\\"]/;\ngoog.string.unescapeEntities = function (a)\n{\n    return goog.string.contains(a, \"&\") ? \"document\" in goog.global ? goog.string.unescapeEntitiesUsingDom_(a) : goog.string.unescapePureXmlEntities_(a) : a\n};\ngoog.string.unescapeEntitiesUsingDom_ = function (a)\n{\n    var b = {\"&amp;\":\"&\", \"&lt;\":\"<\", \"&gt;\":\">\", \"&quot;\":'\"'}, c = document.createElement(\"div\");\n    return a.replace(goog.string.HTML_ENTITY_PATTERN_, function (a, e)\n    {\n        var f = b[a];\n        if (f)\n        {\n            return f\n        }\n        if (\"#\" == e.charAt(0))\n        {\n            var g = Number(\"0\" + e.substr(1));\n            isNaN(g) || (f = String.fromCharCode(g))\n        }\n        f || (c.innerHTML = a + \" \", f = c.firstChild.nodeValue.slice(0, -1));\n        return b[a] = f\n    })\n};\ngoog.string.unescapePureXmlEntities_ = function (a)\n{\n    return a.replace(/&([^;]+);/g, function (a, c)\n    {\n        switch (c)\n        {\n            case \"amp\":\n                return\"&\";\n            case \"lt\":\n                return\"<\";\n            case \"gt\":\n                return\">\";\n            case \"quot\":\n                return'\"';\n            default:\n                if (\"#\" == c.charAt(0))\n                {\n                    var d = Number(\"0\" + c.substr(1));\n                    if (!isNaN(d))\n                    {\n                        return String.fromCharCode(d)\n                    }\n                }\n                return a\n        }\n    })\n};\ngoog.string.HTML_ENTITY_PATTERN_ = /&([^;\\s<&]+);?/g;\ngoog.string.whitespaceEscape = function (a, b)\n{\n    return goog.string.newLineToBr(a.replace(/  /g, \" &#160;\"), b)\n};\ngoog.string.stripQuotes = function (a, b)\n{\n    for (var c = b.length, d = 0; d < c; d++)\n    {\n        var e = 1 == c ? b : b.charAt(d);\n        if (a.charAt(0) == e && a.charAt(a.length - 1) == e)\n        {\n            return a.substring(1, a.length - 1)\n        }\n    }\n    return a\n};\ngoog.string.truncate = function (a, b, c)\n{\n    c && (a = goog.string.unescapeEntities(a));\n    a.length > b && (a = a.substring(0, b - 3) + \"...\");\n    c && (a = goog.string.htmlEscape(a));\n    return a\n};\ngoog.string.truncateMiddle = function (a, b, c, d)\n{\n    c && (a = goog.string.unescapeEntities(a));\n    if (d && a.length > b)\n    {\n        d > b && (d = b);\n        var e = a.length - d, a = a.substring(0, b - d) + \"...\" + a.substring(e)\n    } else\n    {\n        a.length > b && (d = Math.floor(b / 2), e = a.length - d, a = a.substring(0, d + b % 2) + \"...\" + a.substring(e))\n    }\n    c && (a = goog.string.htmlEscape(a));\n    return a\n};\ngoog.string.specialEscapeChars_ = {\"\\x00\":\"\\\\0\", \"\\u0008\":\"\\\\b\", \"\\u000c\":\"\\\\f\", \"\\n\":\"\\\\n\", \"\\r\":\"\\\\r\", \"\\t\":\"\\\\t\", \"\\x0B\":\"\\\\x0B\", '\"':'\\\\\"', \"\\\\\":\"\\\\\\\\\"};\ngoog.string.jsEscapeCache_ = {\"'\":\"\\\\'\"};\ngoog.string.quote = function (a)\n{\n    a = \"\" + a;\n    if (a.quote)\n    {\n        return a.quote()\n    }\n    for (var b = ['\"'], c = 0; c < a.length; c++)\n    {\n        var d = a.charAt(c), e = d.charCodeAt(0);\n        b[c + 1] = goog.string.specialEscapeChars_[d] || (31 < e && 127 > e ? d : goog.string.escapeChar(d))\n    }\n    b.push('\"');\n    return b.join(\"\")\n};\ngoog.string.escapeString = function (a)\n{\n    for (var b = [], c = 0; c < a.length; c++)\n    {\n        b[c] = goog.string.escapeChar(a.charAt(c))\n    }\n    return b.join(\"\")\n};\ngoog.string.escapeChar = function (a)\n{\n    if (a in goog.string.jsEscapeCache_)\n    {\n        return goog.string.jsEscapeCache_[a]\n    }\n    if (a in goog.string.specialEscapeChars_)\n    {\n        return goog.string.jsEscapeCache_[a] = goog.string.specialEscapeChars_[a]\n    }\n    var b = a, c = a.charCodeAt(0);\n    if (31 < c && 127 > c)\n    {\n        b = a\n    } else\n    {\n        if (256 > c)\n        {\n            if (b = \"\\\\x\", 16 > c || 256 < c)\n            {\n                b += \"0\"\n            }\n        } else\n        {\n            b = \"\\\\u\", 4096 > c && (b += \"0\")\n        }\n        b += c.toString(16).toUpperCase()\n    }\n    return goog.string.jsEscapeCache_[a] = b\n};\ngoog.string.toMap = function (a)\n{\n    for (var b = {}, c = 0; c < a.length; c++)\n    {\n        b[a.charAt(c)] = !0\n    }\n    return b\n};\ngoog.string.contains = function (a, b)\n{\n    return-1 != a.indexOf(b)\n};\ngoog.string.removeAt = function (a, b, c)\n{\n    var d = a;\n    0 <= b && (b < a.length && 0 < c) && (d = a.substr(0, b) + a.substr(b + c, a.length - b - c));\n    return d\n};\ngoog.string.remove = function (a, b)\n{\n    var c = RegExp(goog.string.regExpEscape(b), \"\");\n    return a.replace(c, \"\")\n};\ngoog.string.removeAll = function (a, b)\n{\n    var c = RegExp(goog.string.regExpEscape(b), \"g\");\n    return a.replace(c, \"\")\n};\ngoog.string.regExpEscape = function (a)\n{\n    return(\"\" + a).replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, \"\\\\$1\").replace(/\\x08/g, \"\\\\x08\")\n};\ngoog.string.repeat = function (a, b)\n{\n    return Array(b + 1).join(a)\n};\ngoog.string.padNumber = function (a, b, c)\n{\n    a = goog.isDef(c) ? a.toFixed(c) : \"\" + a;\n    c = a.indexOf(\".\");\n    -1 == c && (c = a.length);\n    return goog.string.repeat(\"0\", Math.max(0, b - c)) + a\n};\ngoog.string.makeSafe = function (a)\n{\n    return null == a ? \"\" : \"\" + a\n};\ngoog.string.buildString = function (a)\n{\n    return Array.prototype.join.call(arguments, \"\")\n};\ngoog.string.getRandomString = function ()\n{\n    return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36)\n};\ngoog.string.compareVersions = function (a, b)\n{\n    for (var c = 0, d = goog.string.trim(\"\" + a).split(\".\"), e = goog.string.trim(\"\" + b).split(\".\"), f = Math.max(d.length, e.length), g = 0; 0 == c && g < f; g++)\n    {\n        var h = d[g] || \"\", i = e[g] || \"\", j = RegExp(\"(\\\\d*)(\\\\D*)\", \"g\"), k = RegExp(\"(\\\\d*)(\\\\D*)\", \"g\");\n        do {\n            var l = j.exec(h) || [\"\", \"\", \"\"], n = k.exec(i) || [\"\", \"\", \"\"];\n            if (0 == l[0].length && 0 == n[0].length)\n            {\n                break\n            }\n            var c = 0 == l[1].length ? 0 : parseInt(l[1], 10), m = 0 == n[1].length ? 0 : parseInt(n[1], 10), c = goog.string.compareElements_(c, m) || goog.string.compareElements_(0 == l[2].length, 0 == n[2].length) || goog.string.compareElements_(l[2], n[2])\n        } while (0 == c)\n    }\n    return c\n};\ngoog.string.compareElements_ = function (a, b)\n{\n    return a < b ? -1 : a > b ? 1 : 0\n};\ngoog.string.HASHCODE_MAX_ = 4294967296;\ngoog.string.hashCode = function (a)\n{\n    for (var b = 0, c = 0; c < a.length; ++c)\n    {\n        b = 31 * b + a.charCodeAt(c), b %= goog.string.HASHCODE_MAX_\n    }\n    return b\n};\ngoog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0;\ngoog.string.createUniqueString = function ()\n{\n    return\"goog_\" + goog.string.uniqueStringCounter_++\n};\ngoog.string.toNumber = function (a)\n{\n    var b = Number(a);\n    return 0 == b && goog.string.isEmpty(a) ? NaN : b\n};\ngoog.string.toCamelCaseCache_ = {};\ngoog.string.toCamelCase = function (a)\n{\n    return goog.string.toCamelCaseCache_[a] || (goog.string.toCamelCaseCache_[a] = (\"\" + a).replace(/\\-([a-z])/g, function (a, c)\n    {\n        return c.toUpperCase()\n    }))\n};\ngoog.string.toSelectorCaseCache_ = {};\ngoog.string.toSelectorCase = function (a)\n{\n    return goog.string.toSelectorCaseCache_[a] || (goog.string.toSelectorCaseCache_[a] = (\"\" + a).replace(/([A-Z])/g, \"-$1\").toLowerCase())\n};\ngoog.array = {};\ngoog.NATIVE_ARRAY_PROTOTYPES = !0;\ngoog.array.peek = function (a)\n{\n    return a[a.length - 1]\n};\ngoog.array.ARRAY_PROTOTYPE_ = Array.prototype;\ngoog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES && goog.array.ARRAY_PROTOTYPE_.indexOf ? function (a, b, c)\n{\n\n    return goog.array.ARRAY_PROTOTYPE_.indexOf.call(a, b, c)\n} : function (a, b, c)\n{\n    c = null == c ? 0 : 0 > c ? Math.max(0, a.length + c) : c;\n    if (goog.isString(a))\n    {\n        return!goog.isString(b) || 1 != b.length ? -1 : a.indexOf(b, c)\n    }\n    for (; c < a.length; c++)\n    {\n        if (c in a && a[c] === b)\n        {\n            return c\n        }\n    }\n    return-1\n};\ngoog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES && goog.array.ARRAY_PROTOTYPE_.lastIndexOf ? function (a, b, c)\n{\n\n    return goog.array.ARRAY_PROTOTYPE_.lastIndexOf.call(a, b, null == c ? a.length - 1 : c)\n} : function (a, b, c)\n{\n    c = null == c ? a.length - 1 : c;\n    0 > c && (c = Math.max(0, a.length + c));\n    if (goog.isString(a))\n    {\n        return!goog.isString(b) || 1 != b.length ? -1 : a.lastIndexOf(b, c)\n    }\n    for (; 0 <= c; c--)\n    {\n        if (c in a && a[c] === b)\n        {\n            return c\n        }\n    }\n    return-1\n};\ngoog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES && goog.array.ARRAY_PROTOTYPE_.forEach ? function (a, b, c)\n{\n\n    goog.array.ARRAY_PROTOTYPE_.forEach.call(a, b, c)\n} : function (a, b, c)\n{\n    for (var d = a.length, e = goog.isString(a) ? a.split(\"\") : a, f = 0; f < d; f++)\n    {\n        f in e && b.call(c, e[f], f, a)\n    }\n};\ngoog.array.forEachRight = function (a, b, c)\n{\n    for (var d = a.length, e = goog.isString(a) ? a.split(\"\") : a, d = d - 1; 0 <= d; --d)\n    {\n        d in e && b.call(c, e[d], d, a)\n    }\n};\ngoog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES && goog.array.ARRAY_PROTOTYPE_.filter ? function (a, b, c)\n{\n\n    return goog.array.ARRAY_PROTOTYPE_.filter.call(a, b, c)\n} : function (a, b, c)\n{\n    for (var d = a.length, e = [], f = 0, g = goog.isString(a) ? a.split(\"\") : a, h = 0; h < d; h++)\n    {\n        if (h in g)\n        {\n            var i = g[h];\n            b.call(c, i, h, a) && (e[f++] = i)\n        }\n    }\n    return e\n};\ngoog.array.map = goog.NATIVE_ARRAY_PROTOTYPES && goog.array.ARRAY_PROTOTYPE_.map ? function (a, b, c)\n{\n\n    return goog.array.ARRAY_PROTOTYPE_.map.call(a, b, c)\n} : function (a, b, c)\n{\n    for (var d = a.length, e = Array(d), f = goog.isString(a) ? a.split(\"\") : a, g = 0; g < d; g++)\n    {\n        g in f && (e[g] = b.call(c, f[g], g, a))\n    }\n    return e\n};\ngoog.array.reduce = function (a, b, c, d)\n{\n    if (a.reduce)\n    {\n        return d ? a.reduce(goog.bind(b, d), c) : a.reduce(b, c)\n    }\n    var e = c;\n    goog.array.forEach(a, function (c, g)\n    {\n        e = b.call(d, e, c, g, a)\n    });\n    return e\n};\ngoog.array.reduceRight = function (a, b, c, d)\n{\n    if (a.reduceRight)\n    {\n        return d ? a.reduceRight(goog.bind(b, d), c) : a.reduceRight(b, c)\n    }\n    var e = c;\n    goog.array.forEachRight(a, function (c, g)\n    {\n        e = b.call(d, e, c, g, a)\n    });\n    return e\n};\ngoog.array.some = goog.NATIVE_ARRAY_PROTOTYPES && goog.array.ARRAY_PROTOTYPE_.some ? function (a, b, c)\n{\n\n    return goog.array.ARRAY_PROTOTYPE_.some.call(a, b, c)\n} : function (a, b, c)\n{\n    for (var d = a.length, e = goog.isString(a) ? a.split(\"\") : a, f = 0; f < d; f++)\n    {\n        if (f in e && b.call(c, e[f], f, a))\n        {\n            return!0\n        }\n    }\n    return!1\n};\ngoog.array.every = goog.NATIVE_ARRAY_PROTOTYPES && goog.array.ARRAY_PROTOTYPE_.every ? function (a, b, c)\n{\n\n    return goog.array.ARRAY_PROTOTYPE_.every.call(a, b, c)\n} : function (a, b, c)\n{\n    for (var d = a.length, e = goog.isString(a) ? a.split(\"\") : a, f = 0; f < d; f++)\n    {\n        if (f in e && !b.call(c, e[f], f, a))\n        {\n            return!1\n        }\n    }\n    return!0\n};\ngoog.array.find = function (a, b, c)\n{\n    b = goog.array.findIndex(a, b, c);\n    return 0 > b ? null : goog.isString(a) ? a.charAt(b) : a[b]\n};\ngoog.array.findIndex = function (a, b, c)\n{\n    for (var d = a.length, e = goog.isString(a) ? a.split(\"\") : a, f = 0; f < d; f++)\n    {\n        if (f in e && b.call(c, e[f], f, a))\n        {\n            return f\n        }\n    }\n    return-1\n};\ngoog.array.findRight = function (a, b, c)\n{\n    b = goog.array.findIndexRight(a, b, c);\n    return 0 > b ? null : goog.isString(a) ? a.charAt(b) : a[b]\n};\ngoog.array.findIndexRight = function (a, b, c)\n{\n    for (var d = a.length, e = goog.isString(a) ? a.split(\"\") : a, d = d - 1; 0 <= d; d--)\n    {\n        if (d in e && b.call(c, e[d], d, a))\n        {\n            return d\n        }\n    }\n    return-1\n};\ngoog.array.contains = function (a, b)\n{\n    return 0 <= goog.array.indexOf(a, b)\n};\ngoog.array.isEmpty = function (a)\n{\n    return 0 == a.length\n};\ngoog.array.clear = function (a)\n{\n    if (!goog.isArray(a))\n    {\n        for (var b = a.length - 1; 0 <= b; b--)\n        {\n            delete a[b]\n        }\n    }\n    a.length = 0\n};\ngoog.array.insert = function (a, b)\n{\n    goog.array.contains(a, b) || a.push(b)\n};\ngoog.array.insertAt = function (a, b, c)\n{\n    goog.array.splice(a, c, 0, b)\n};\ngoog.array.insertArrayAt = function (a, b, c)\n{\n    goog.partial(goog.array.splice, a, c, 0).apply(null, b)\n};\ngoog.array.insertBefore = function (a, b, c)\n{\n    var d;\n    2 == arguments.length || 0 > (d = goog.array.indexOf(a, c)) ? a.push(b) : goog.array.insertAt(a, b, d)\n};\ngoog.array.remove = function (a, b)\n{\n    var c = goog.array.indexOf(a, b), d;\n    (d = 0 <= c) && goog.array.removeAt(a, c);\n    return d\n};\ngoog.array.removeAt = function (a, b)\n{\n\n    return 1 == goog.array.ARRAY_PROTOTYPE_.splice.call(a, b, 1).length\n};\ngoog.array.removeIf = function (a, b, c)\n{\n    b = goog.array.findIndex(a, b, c);\n    return 0 <= b ? (goog.array.removeAt(a, b), !0) : !1\n};\ngoog.array.concat = function (a)\n{\n    return goog.array.ARRAY_PROTOTYPE_.concat.apply(goog.array.ARRAY_PROTOTYPE_, arguments)\n};\ngoog.array.clone = function (a)\n{\n    if (goog.isArray(a))\n    {\n        return goog.array.concat(a)\n    }\n    for (var b = [], c = 0, d = a.length; c < d; c++)\n    {\n        b[c] = a[c]\n    }\n    return b\n};\ngoog.array.toArray = function (a)\n{\n    return goog.isArray(a) ? goog.array.concat(a) : goog.array.clone(a)\n};\ngoog.array.extend = function (a, b)\n{\n    for (var c = 1; c < arguments.length; c++)\n    {\n        var d = arguments[c], e;\n        if (goog.isArray(d) || (e = goog.isArrayLike(d)) && d.hasOwnProperty(\"callee\"))\n        {\n            a.push.apply(a, d)\n        } else\n        {\n            if (e)\n            {\n                for (var f = a.length, g = d.length, h = 0; h < g; h++)\n                {\n                    a[f + h] = d[h]\n                }\n            } else\n            {\n                a.push(d)\n            }\n        }\n    }\n};\ngoog.array.splice = function (a, b, c, d)\n{\n\n    return goog.array.ARRAY_PROTOTYPE_.splice.apply(a, goog.array.slice(arguments, 1))\n};\ngoog.array.slice = function (a, b, c)\n{\n\n    return 2 >= arguments.length ? goog.array.ARRAY_PROTOTYPE_.slice.call(a, b) : goog.array.ARRAY_PROTOTYPE_.slice.call(a, b, c)\n};\ngoog.array.removeDuplicates = function (a, b)\n{\n    for (var c = b || a, d = {}, e = 0, f = 0; f < a.length;)\n    {\n        var g = a[f++], h = goog.isObject(g) ? \"o\" + goog.getUid(g) : (typeof g).charAt(0) + g;\n        Object.prototype.hasOwnProperty.call(d, h) || (d[h] = !0, c[e++] = g)\n    }\n    c.length = e\n};\ngoog.array.binarySearch = function (a, b, c)\n{\n    return goog.array.binarySearch_(a, c || goog.array.defaultCompare, !1, b)\n};\ngoog.array.binarySelect = function (a, b, c)\n{\n    return goog.array.binarySearch_(a, b, !0, void 0, c)\n};\ngoog.array.binarySearch_ = function (a, b, c, d, e)\n{\n    for (var f = 0, g = a.length, h; f < g;)\n    {\n        var i = f + g >> 1, j;\n        j = c ? b.call(e, a[i], i, a) : b(d, a[i]);\n        0 < j ? f = i + 1 : (g = i, h = !j)\n    }\n    return h ? f : ~f\n};\ngoog.array.sort = function (a, b)\n{\n\n    goog.array.ARRAY_PROTOTYPE_.sort.call(a, b || goog.array.defaultCompare)\n};\ngoog.array.stableSort = function (a, b)\n{\n    for (var c = 0; c < a.length; c++)\n    {\n        a[c] = {index:c, value:a[c]}\n    }\n    var d = b || goog.array.defaultCompare;\n    goog.array.sort(a, function (a, b)\n    {\n        return d(a.value, b.value) || a.index - b.index\n    });\n    for (c = 0; c < a.length; c++)\n    {\n        a[c] = a[c].value\n    }\n};\ngoog.array.sortObjectsByKey = function (a, b, c)\n{\n    var d = c || goog.array.defaultCompare;\n    goog.array.sort(a, function (a, c)\n    {\n        return d(a[b], c[b])\n    })\n};\ngoog.array.isSorted = function (a, b, c)\n{\n    for (var b = b || goog.array.defaultCompare, d = 1; d < a.length; d++)\n    {\n        var e = b(a[d - 1], a[d]);\n        if (0 < e || 0 == e && c)\n        {\n            return!1\n        }\n    }\n    return!0\n};\ngoog.array.equals = function (a, b, c)\n{\n    if (!goog.isArrayLike(a) || !goog.isArrayLike(b) || a.length != b.length)\n    {\n        return!1\n    }\n    for (var d = a.length, c = c || goog.array.defaultCompareEquality, e = 0; e < d; e++)\n    {\n        if (!c(a[e], b[e]))\n        {\n            return!1\n        }\n    }\n    return!0\n};\ngoog.array.compare = function (a, b, c)\n{\n    return goog.array.equals(a, b, c)\n};\ngoog.array.compare3 = function (a, b, c)\n{\n    for (var c = c || goog.array.defaultCompare, d = Math.min(a.length, b.length), e = 0; e < d; e++)\n    {\n        var f = c(a[e], b[e]);\n        if (0 != f)\n        {\n            return f\n        }\n    }\n    return goog.array.defaultCompare(a.length, b.length)\n};\ngoog.array.defaultCompare = function (a, b)\n{\n    return a > b ? 1 : a < b ? -1 : 0\n};\ngoog.array.defaultCompareEquality = function (a, b)\n{\n    return a === b\n};\ngoog.array.binaryInsert = function (a, b, c)\n{\n    c = goog.array.binarySearch(a, b, c);\n    return 0 > c ? (goog.array.insertAt(a, b, -(c + 1)), !0) : !1\n};\ngoog.array.binaryRemove = function (a, b, c)\n{\n    b = goog.array.binarySearch(a, b, c);\n    return 0 <= b ? goog.array.removeAt(a, b) : !1\n};\ngoog.array.bucket = function (a, b)\n{\n    for (var c = {}, d = 0; d < a.length; d++)\n    {\n        var e = a[d], f = b(e, d, a);\n        goog.isDef(f) && (c[f] || (c[f] = [])).push(e)\n    }\n    return c\n};\ngoog.array.repeat = function (a, b)\n{\n    for (var c = [], d = 0; d < b; d++)\n    {\n        c[d] = a\n    }\n    return c\n};\ngoog.array.flatten = function (a)\n{\n    for (var b = [], c = 0; c < arguments.length; c++)\n    {\n        var d = arguments[c];\n        goog.isArray(d) ? b.push.apply(b, goog.array.flatten.apply(null, d)) : b.push(d)\n    }\n    return b\n};\ngoog.array.rotate = function (a, b)\n{\n\n    a.length && (b %= a.length, 0 < b ? goog.array.ARRAY_PROTOTYPE_.unshift.apply(a, a.splice(-b, b)) : 0 > b && goog.array.ARRAY_PROTOTYPE_.push.apply(a, a.splice(0, -b)));\n    return a\n};\ngoog.array.zip = function (a)\n{\n    if (!arguments.length)\n    {\n        return[]\n    }\n    for (var b = [], c = 0; ; c++)\n    {\n        for (var d = [], e = 0; e < arguments.length; e++)\n        {\n            var f = arguments[e];\n            if (c >= f.length)\n            {\n                return b\n            }\n            d.push(f[c])\n        }\n        b.push(d)\n    }\n};\ngoog.array.shuffle = function (a, b)\n{\n    for (var c = b || Math.random, d = a.length - 1; 0 < d; d--)\n    {\n        var e = Math.floor(c() * (d + 1)), f = a[d];\n        a[d] = a[e];\n        a[e] = f\n    }\n};\ngoog.structs = {};\ngoog.structs.Queue = function ()\n{\n    this.elements_ = []\n};\ngoog.structs.Queue.prototype.head_ = 0;\ngoog.structs.Queue.prototype.tail_ = 0;\ngoog.structs.Queue.prototype.enqueue = function (a)\n{\n    this.elements_[this.tail_++] = a\n};\ngoog.structs.Queue.prototype.dequeue = function ()\n{\n    if (this.head_ != this.tail_)\n    {\n        var a = this.elements_[this.head_];\n        delete this.elements_[this.head_];\n        this.head_++;\n        return a\n    }\n};\ngoog.structs.Queue.prototype.peek = function ()\n{\n    return this.head_ == this.tail_ ? void 0 : this.elements_[this.head_]\n};\ngoog.structs.Queue.prototype.getCount = function ()\n{\n    return this.tail_ - this.head_\n};\ngoog.structs.Queue.prototype.isEmpty = function ()\n{\n    return 0 == this.tail_ - this.head_\n};\ngoog.structs.Queue.prototype.clear = function ()\n{\n    this.tail_ = this.head_ = this.elements_.length = 0\n};\ngoog.structs.Queue.prototype.contains = function (a)\n{\n    return goog.array.contains(this.elements_, a)\n};\ngoog.structs.Queue.prototype.remove = function (a)\n{\n    a = goog.array.indexOf(this.elements_, a);\n    if (0 > a)\n    {\n        return!1\n    }\n    a == this.head_ ? this.dequeue() : (goog.array.removeAt(this.elements_, a), this.tail_--);\n    return!0\n};\ngoog.structs.Queue.prototype.getValues = function ()\n{\n    return this.elements_.slice(this.head_, this.tail_)\n};\nvar Box2D = {Common:{}};\n\nBox2D.Common.Math = {};\nBox2D.Common.Math.b2Vec2 = function (a, b)\n{\n\n    this.x = a;\n    this.y = b\n};\nBox2D.Common.Math.b2Vec2._freeCache = [];\nBox2D.Common.Math.b2Vec2.Get = function (a, b)\n{\n\n    if (0 < Box2D.Common.Math.b2Vec2._freeCache.length)\n    {\n        var c = Box2D.Common.Math.b2Vec2._freeCache.pop();\n        c.Set(a, b);\n        return c\n    }\n    return new Box2D.Common.Math.b2Vec2(a, b)\n};\nBox2D.Common.Math.b2Vec2.Free = function (a)\n{\n    null != a && ( Box2D.Common.Math.b2Vec2._freeCache.push(a))\n};\nBox2D.Common.Math.b2Vec2.prototype.SetZero = function ()\n{\n    this.y = this.x = 0\n};\nBox2D.Common.Math.b2Vec2.prototype.Set = function (a, b)\n{\n    this.x = a;\n    this.y = b\n};\nBox2D.Common.Math.b2Vec2.prototype.SetV = function (a)\n{\n    this.x = a.x;\n    this.y = a.y\n};\nBox2D.Common.Math.b2Vec2.prototype.GetNegative = function ()\n{\n    return Box2D.Common.Math.b2Vec2.Get(-this.x, -this.y)\n};\nBox2D.Common.Math.b2Vec2.prototype.NegativeSelf = function ()\n{\n    this.x = -this.x;\n    this.y = -this.y\n};\nBox2D.Common.Math.b2Vec2.prototype.Copy = function ()\n{\n    return Box2D.Common.Math.b2Vec2.Get(this.x, this.y)\n};\nBox2D.Common.Math.b2Vec2.prototype.Add = function (a)\n{\n    this.x += a.x;\n    this.y += a.y\n};\nBox2D.Common.Math.b2Vec2.prototype.Subtract = function (a)\n{\n    this.x -= a.x;\n    this.y -= a.y\n};\nBox2D.Common.Math.b2Vec2.prototype.Multiply = function (a)\n{\n    this.x *= a;\n    this.y *= a\n};\nBox2D.Common.Math.b2Vec2.prototype.MulM = function (a)\n{\n    var b = this.x;\n    this.x = a.col1.x * b + a.col2.x * this.y;\n    this.y = a.col1.y * b + a.col2.y * this.y\n};\nBox2D.Common.Math.b2Vec2.prototype.MulTM = function (a)\n{\n    var b = this.x * a.col1.x + this.y * a.col1.y;\n    this.y = this.x * a.col2.x + this.y * a.col2.y;\n    this.x = b\n};\nBox2D.Common.Math.b2Vec2.prototype.CrossVF = function (a)\n{\n    var b = this.x;\n    this.x = a * this.y;\n    this.y = -a * b\n};\nBox2D.Common.Math.b2Vec2.prototype.CrossFV = function (a)\n{\n    var b = this.x;\n    this.x = -a * this.y;\n    this.y = a * b\n};\nBox2D.Common.Math.b2Vec2.prototype.MinV = function (a)\n{\n    this.x = Math.min(this.x, a.x);\n    this.y = Math.min(this.y, a.y)\n};\nBox2D.Common.Math.b2Vec2.prototype.MaxV = function (a)\n{\n    this.x = Math.max(this.x, a.x);\n    this.y = Math.max(this.y, a.y)\n};\nBox2D.Common.Math.b2Vec2.prototype.Abs = function ()\n{\n    this.x = Math.abs(this.x);\n    this.y = Math.abs(this.y)\n};\nBox2D.Common.Math.b2Vec2.prototype.Length = function ()\n{\n    return Math.sqrt(this.LengthSquared())\n};\nBox2D.Common.Math.b2Vec2.prototype.LengthSquared = function ()\n{\n    return this.x * this.x + this.y * this.y\n};\nBox2D.Common.Math.b2Vec2.prototype.Normalize = function ()\n{\n    var a = this.Length();\n    if (a < Number.MIN_VALUE)\n    {\n        return 0\n    }\n    var b = 1 / a;\n    this.x *= b;\n    this.y *= b;\n    return a\n};\nBox2D.Common.Math.b2Vec2.prototype.IsValid = function ()\n{\n    return isFinite(this.x) && isFinite(this.y)\n};\nBox2D.Common.b2Settings = {};\nBox2D.Common.b2Settings.b2MixFriction = function (a, b)\n{\n    return Math.sqrt(a * b)\n};\nBox2D.Common.b2Settings.b2MixRestitution = function (a, b)\n{\n    return a > b ? a : b\n};\nBox2D.Common.b2Settings.b2Assert = function (a)\n{\n    if (!a)\n    {\n        throw\"Assertion Failed\";\n    }\n};\nBox2D.Common.b2Settings.VERSION = \"2.1a-playcraft\";\nBox2D.Common.b2Settings.USHRT_MAX = 65535;\nBox2D.Common.b2Settings.b2_maxManifoldPoints = 2;\nBox2D.Common.b2Settings.b2_aabbExtension = 0.1;\nBox2D.Common.b2Settings.b2_aabbMultiplier = 2;\nBox2D.Common.b2Settings.b2_polygonRadius = 2 * Box2D.Common.b2Settings.b2_linearSlop;\nBox2D.Common.b2Settings.b2_linearSlop = 0.0050;\nBox2D.Common.b2Settings.b2_angularSlop = 2 / 180 * Math.PI;\nBox2D.Common.b2Settings.b2_toiSlop = 8 * Box2D.Common.b2Settings.b2_linearSlop;\nBox2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;\nBox2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;\nBox2D.Common.b2Settings.b2_velocityThreshold = 1;\nBox2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;\nBox2D.Common.b2Settings.b2_maxAngularCorrection = 8 / 180 * Math.PI;\nBox2D.Common.b2Settings.b2_maxTranslation = 2;\nBox2D.Common.b2Settings.b2_maxTranslationSquared = Box2D.Common.b2Settings.b2_maxTranslation * Box2D.Common.b2Settings.b2_maxTranslation;\nBox2D.Common.b2Settings.b2_maxRotation = 0.5 * Math.PI;\nBox2D.Common.b2Settings.b2_maxRotationSquared = Box2D.Common.b2Settings.b2_maxRotation * Box2D.Common.b2Settings.b2_maxRotation;\nBox2D.Common.b2Settings.b2_contactBaumgarte = 0.2;\nBox2D.Common.b2Settings.b2_timeToSleep = 0.5;\nBox2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;\nBox2D.Common.b2Settings.b2_linearSleepToleranceSquared = Box2D.Common.b2Settings.b2_linearSleepTolerance * Box2D.Common.b2Settings.b2_linearSleepTolerance;\nBox2D.Common.b2Settings.b2_angularSleepTolerance = 2 / 180 * Math.PI;\nBox2D.Common.b2Settings.b2_angularSleepToleranceSquared = Box2D.Common.b2Settings.b2_angularSleepTolerance * Box2D.Common.b2Settings.b2_angularSleepTolerance;\nBox2D.Common.b2Settings.MIN_VALUE_SQUARED = Number.MIN_VALUE * Number.MIN_VALUE;\nBox2D.Common.Math.b2Mat22 = function ()\n{\n\n    this.col1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.col2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.SetIdentity()\n};\nBox2D.Common.Math.b2Mat22._freeCache = [];\nBox2D.Common.Math.b2Mat22.Get = function ()\n{\n\n    if (0 < Box2D.Common.Math.b2Mat22._freeCache.length)\n    {\n        var a = Box2D.Common.Math.b2Mat22._freeCache.pop();\n        a.SetZero();\n        return a\n    }\n    return new Box2D.Common.Math.b2Mat22\n};\nBox2D.Common.Math.b2Mat22.Free = function (a)\n{\n    null != a && ( Box2D.Common.Math.b2Mat22._freeCache.push(a))\n};\nBox2D.Common.Math.b2Mat22.FromAngle = function (a)\n{\n    var b = Box2D.Common.Math.b2Mat22.Get();\n    b.Set(a);\n    return b\n};\nBox2D.Common.Math.b2Mat22.FromVV = function (a, b)\n{\n    var c = Box2D.Common.Math.b2Mat22.Get();\n    c.SetVV(a, b);\n    return c\n};\nBox2D.Common.Math.b2Mat22.prototype.Set = function (a)\n{\n    var b = Math.cos(a), a = Math.sin(a);\n    this.col1.Set(b, a);\n    this.col2.Set(-a, b)\n};\nBox2D.Common.Math.b2Mat22.prototype.SetVV = function (a, b)\n{\n    this.col1.SetV(a);\n    this.col2.SetV(b)\n};\nBox2D.Common.Math.b2Mat22.prototype.Copy = function ()\n{\n    var a = Box2D.Common.Math.b2Mat22.Get();\n    a.SetM(this);\n    return a\n};\nBox2D.Common.Math.b2Mat22.prototype.SetM = function (a)\n{\n    this.col1.SetV(a.col1);\n    this.col2.SetV(a.col2)\n};\nBox2D.Common.Math.b2Mat22.prototype.AddM = function (a)\n{\n    this.col1.Add(a.col1);\n    this.col2.Add(a.col2)\n};\nBox2D.Common.Math.b2Mat22.prototype.SetIdentity = function ()\n{\n    this.col1.Set(1, 0);\n    this.col2.Set(0, 1)\n};\nBox2D.Common.Math.b2Mat22.prototype.SetZero = function ()\n{\n    this.col1.Set(0, 0);\n    this.col2.Set(0, 0)\n};\nBox2D.Common.Math.b2Mat22.prototype.GetAngle = function ()\n{\n    return Math.atan2(this.col1.y, this.col1.x)\n};\nBox2D.Common.Math.b2Mat22.prototype.GetInverse = function (a)\n{\n    var b = this.col1.x * this.col2.y - this.col2.x * this.col1.y;\n    0 !== b && (b = 1 / b);\n    a.col1.x = b * this.col2.y;\n    a.col2.x = -b * this.col2.x;\n    a.col1.y = -b * this.col1.y;\n    a.col2.y = b * this.col1.x;\n    return a\n};\nBox2D.Common.Math.b2Mat22.prototype.Solve = function (a, b, c)\n{\n    var d = this.col1.x * this.col2.y - this.col2.x * this.col1.y;\n    0 !== d && (d = 1 / d);\n    a.x = d * (this.col2.y * b - this.col2.x * c);\n    a.y = d * (this.col1.x * c - this.col1.y * b);\n    return a\n};\nBox2D.Common.Math.b2Mat22.prototype.Abs = function ()\n{\n    this.col1.Abs();\n    this.col2.Abs()\n};\nBox2D.Common.Math.b2Math = {};\nBox2D.Common.Math.b2Math.Dot = function (a, b)\n{\n    return a.x * b.x + a.y * b.y\n};\nBox2D.Common.Math.b2Math.CrossVV = function (a, b)\n{\n    return a.x * b.y - a.y * b.x\n};\nBox2D.Common.Math.b2Math.CrossVF = function (a, b)\n{\n    return Box2D.Common.Math.b2Vec2.Get(b * a.y, -b * a.x)\n};\nBox2D.Common.Math.b2Math.CrossFV = function (a, b)\n{\n    return Box2D.Common.Math.b2Vec2.Get(-a * b.y, a * b.x)\n};\nBox2D.Common.Math.b2Math.MulMV = function (a, b)\n{\n    return Box2D.Common.Math.b2Vec2.Get(a.col1.x * b.x + a.col2.x * b.y, a.col1.y * b.x + a.col2.y * b.y)\n};\nBox2D.Common.Math.b2Math.MulTMV = function (a, b)\n{\n    return Box2D.Common.Math.b2Vec2.Get(Box2D.Common.Math.b2Math.Dot(b, a.col1), Box2D.Common.Math.b2Math.Dot(b, a.col2))\n};\nBox2D.Common.Math.b2Math.MulX = function (a, b)\n{\n    var c = Box2D.Common.Math.b2Math.MulMV(a.R, b);\n    c.x += a.position.x;\n    c.y += a.position.y;\n    return c\n};\nBox2D.Common.Math.b2Math.MulXT = function (a, b)\n{\n    var c = Box2D.Common.Math.b2Math.SubtractVV(b, a.position), d = c.x * a.R.col1.x + c.y * a.R.col1.y;\n    c.y = c.x * a.R.col2.x + c.y * a.R.col2.y;\n    c.x = d;\n    return c\n};\nBox2D.Common.Math.b2Math.AddVV = function (a, b)\n{\n    return Box2D.Common.Math.b2Vec2.Get(a.x + b.x, a.y + b.y)\n};\nBox2D.Common.Math.b2Math.SubtractVV = function (a, b)\n{\n    return Box2D.Common.Math.b2Vec2.Get(a.x - b.x, a.y - b.y)\n};\nBox2D.Common.Math.b2Math.Distance = function (a, b)\n{\n    return Math.sqrt(Box2D.Common.Math.b2Math.DistanceSquared(a, b))\n};\nBox2D.Common.Math.b2Math.DistanceSquared = function (a, b)\n{\n    var c = a.x - b.x, d = a.y - b.y;\n    return c * c + d * d\n};\nBox2D.Common.Math.b2Math.MulFV = function (a, b)\n{\n    return Box2D.Common.Math.b2Vec2.Get(a * b.x, a * b.y)\n};\nBox2D.Common.Math.b2Math.AddMM = function (a, b)\n{\n    var c = Box2D.Common.Math.b2Math.AddVV(a.col1, b.col1), d = Box2D.Common.Math.b2Math.AddVV(a.col2, b.col2), e = Box2D.Common.Math.b2Mat22.FromVV(c, d);\n    Box2D.Common.Math.b2Vec2.Free(c);\n    Box2D.Common.Math.b2Vec2.Free(d);\n    return e\n};\nBox2D.Common.Math.b2Math.MulMM = function (a, b)\n{\n    var c = Box2D.Common.Math.b2Math.MulMV(a, b.col1), d = Box2D.Common.Math.b2Math.MulMV(a, b.col2), e = Box2D.Common.Math.b2Mat22.FromVV(c, d);\n    Box2D.Common.Math.b2Vec2.Free(c);\n    Box2D.Common.Math.b2Vec2.Free(d);\n    return e\n};\nBox2D.Common.Math.b2Math.MulTMM = function (a, b)\n{\n    var c = Box2D.Common.Math.b2Vec2.Get(Box2D.Common.Math.b2Math.Dot(a.col1, b.col1), Box2D.Common.Math.b2Math.Dot(a.col2, b.col1)), d = Box2D.Common.Math.b2Vec2.Get(Box2D.Common.Math.b2Math.Dot(a.col1, b.col2), Box2D.Common.Math.b2Math.Dot(a.col2, b.col2)), e = Box2D.Common.Math.b2Mat22.FromVV(c, d);\n    Box2D.Common.Math.b2Vec2.Free(c);\n    Box2D.Common.Math.b2Vec2.Free(d);\n    return e\n};\nBox2D.Common.Math.b2Math.AbsV = function (a)\n{\n    return Box2D.Common.Math.b2Vec2.Get(Math.abs(a.x), Math.abs(a.y))\n};\nBox2D.Common.Math.b2Math.AbsM = function (a)\n{\n    var b = Box2D.Common.Math.b2Math.AbsV(a.col1), a = Box2D.Common.Math.b2Math.AbsV(a.col2), c = Box2D.Common.Math.b2Mat22.FromVV(b, a);\n    Box2D.Common.Math.b2Vec2.Free(b);\n    Box2D.Common.Math.b2Vec2.Free(a);\n    return c\n};\nBox2D.Common.Math.b2Math.Clamp = function (a, b, c)\n{\n    return a < b ? b : a > c ? c : a\n};\nBox2D.Common.Math.b2Math.ClampV = function (a, b, c)\n{\n    var d = Box2D.Common.Math.b2Math.Clamp(a.x, b.x, c.x), a = Box2D.Common.Math.b2Math.Clamp(a.y, b.y, c.y);\n    return Box2D.Common.Math.b2Vec2.Get(d, a)\n};\nBox2D.Dynamics = {};\nBox2D.Dynamics.Joints = {};\nBox2D.Dynamics.Joints.b2JointEdge = function ()\n{\n};\nBox2D.Dynamics.Joints.b2Joint = function (a)\n{\n    this.m_edgeA = new Box2D.Dynamics.Joints.b2JointEdge;\n    this.m_edgeB = new Box2D.Dynamics.Joints.b2JointEdge;\n    this.m_localCenterA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localCenterB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    Box2D.Common.b2Settings.b2Assert(a.bodyA != a.bodyB);\n    this.m_type = a.type;\n    this.m_next = this.m_prev = null;\n    this.m_bodyA = a.bodyA;\n    this.m_bodyB = a.bodyB;\n    this.m_collideConnected = a.collideConnected\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.GetType = function ()\n{\n    return this.m_type\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.GetAnchorA = function ()\n{\n    return null\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.GetAnchorB = function ()\n{\n    return null\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.GetReactionForce = function ()\n{\n    return null\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.GetReactionTorque = function ()\n{\n    return 0\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.GetBodyA = function ()\n{\n    return this.m_bodyA\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.GetBodyB = function ()\n{\n    return this.m_bodyB\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.GetNext = function ()\n{\n    return this.m_next\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.IsActive = function ()\n{\n    return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()\n};\nBox2D.Dynamics.Joints.b2Joint.Create = function (a)\n{\n    return a.Create()\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.InitVelocityConstraints = function ()\n{\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.SolveVelocityConstraints = function ()\n{\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.FinalizeVelocityConstraints = function ()\n{\n};\nBox2D.Dynamics.Joints.b2Joint.prototype.SolvePositionConstraints = function ()\n{\n    return!1\n};\nBox2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;\nBox2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;\nBox2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;\nBox2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;\nBox2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;\nBox2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;\nBox2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;\nBox2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;\nBox2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;\nBox2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;\nBox2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;\nBox2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;\nBox2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;\nBox2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;\nBox2D.Dynamics.Joints.b2LineJoint = function (a)\n{\n    Box2D.Dynamics.Joints.b2Joint.call(this, a);\n    this.m_localAnchor1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localXAxis1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localYAxis1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_axis = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_perp = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_K = new Box2D.Common.Math.b2Mat22;\n    this.m_impulse = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor1.SetV(a.localAnchorA);\n    this.m_localAnchor2.SetV(a.localAnchorB);\n    this.m_localXAxis1.SetV(a.localAxisA);\n    this.m_localYAxis1.x = -this.m_localXAxis1.y;\n    this.m_localYAxis1.y = this.m_localXAxis1.x;\n    this.m_impulse.SetZero();\n    this.m_motorImpulse = this.m_motorMass = 0;\n    this.m_lowerTranslation = a.lowerTranslation;\n    this.m_upperTranslation = a.upperTranslation;\n    this.m_maxMotorForce = a.maxMotorForce;\n    this.m_motorSpeed = a.motorSpeed;\n    this.m_enableLimit = a.enableLimit;\n    this.m_enableMotor = a.enableMotor;\n    this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;\n    this.m_axis.SetZero();\n    this.m_perp.SetZero()\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2LineJoint, Box2D.Dynamics.Joints.b2Joint);\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetAnchorA = function ()\n{\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetAnchorB = function ()\n{\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetReactionForce = function (a)\n{\n    void 0 === a && (a = 0);\n    return Box2D.Common.Math.b2Vec2.Get(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetReactionTorque = function (a)\n{\n    void 0 === a && (a = 0);\n    return a * this.m_impulse.y\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetJointTranslation = function ()\n{\n    var a = this.m_bodyA, b = this.m_bodyB, c = a.GetWorldPoint(this.m_localAnchor1), d = b.GetWorldPoint(this.m_localAnchor2), b = d.x - c.x, c = d.y - c.y, a = a.GetWorldVector(this.m_localXAxis1);\n    return a.x * b + a.y * c\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetJointSpeed = function ()\n{\n    var a = this.m_bodyA, b = this.m_bodyB, c;\n    c = a.m_xf.R;\n    var d = this.m_localAnchor1.x - a.m_sweep.localCenter.x, e = this.m_localAnchor1.y - a.m_sweep.localCenter.y, f = c.col1.x * d + c.col2.x * e, e = c.col1.y * d + c.col2.y * e, d = f;\n    c = b.m_xf.R;\n    var g = this.m_localAnchor2.x - b.m_sweep.localCenter.x, h = this.m_localAnchor2.y - b.m_sweep.localCenter.y, f = c.col1.x * g + c.col2.x * h, h = c.col1.y * g + c.col2.y * h, g = f;\n    c = b.m_sweep.c.x + g - (a.m_sweep.c.x + d);\n    var f = b.m_sweep.c.y + h - (a.m_sweep.c.y + e), i = a.GetWorldVector(this.m_localXAxis1), j = a.m_linearVelocity, k = b.m_linearVelocity, a = a.m_angularVelocity, b = b.m_angularVelocity;\n    return c * -a * i.y + f * a * i.x + (i.x * (k.x + -b * h - j.x - -a * e) + i.y * (k.y + b * g - j.y - a * d))\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.IsLimitEnabled = function ()\n{\n    return this.m_enableLimit\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.EnableLimit = function (a)\n{\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_enableLimit = a\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetLowerLimit = function ()\n{\n    return this.m_lowerTranslation\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetUpperLimit = function ()\n{\n    return this.m_upperTranslation\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.SetLimits = function (a, b)\n{\n    void 0 === a && (a = 0);\n    void 0 === b && (b = 0);\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_lowerTranslation = a;\n    this.m_upperTranslation = b\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.IsMotorEnabled = function ()\n{\n    return this.m_enableMotor\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.EnableMotor = function (a)\n{\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_enableMotor = a\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.SetMotorSpeed = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_motorSpeed = a\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetMotorSpeed = function ()\n{\n    return this.m_motorSpeed\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.SetMaxMotorForce = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_maxMotorForce = a\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetMaxMotorForce = function ()\n{\n    return this.m_maxMotorForce\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.GetMotorForce = function ()\n{\n    return this.m_motorImpulse\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.InitVelocityConstraints = function (a)\n{\n    var b = this.m_bodyA, c = this.m_bodyB, d, e = 0;\n    this.m_localCenterA.SetV(b.GetLocalCenter());\n    this.m_localCenterB.SetV(c.GetLocalCenter());\n    var f = b.GetTransform();\n    c.GetTransform();\n    d = b.m_xf.R;\n    var g = this.m_localAnchor1.x - this.m_localCenterA.x, h = this.m_localAnchor1.y - this.m_localCenterA.y, e = d.col1.x * g + d.col2.x * h, h = d.col1.y * g + d.col2.y * h, g = e;\n    d = c.m_xf.R;\n    var i = this.m_localAnchor2.x - this.m_localCenterB.x, j = this.m_localAnchor2.y - this.m_localCenterB.y, e = d.col1.x * i + d.col2.x * j, j = d.col1.y * i + d.col2.y * j, i = e;\n    d = c.m_sweep.c.x + i - b.m_sweep.c.x - g;\n    e = c.m_sweep.c.y + j - b.m_sweep.c.y - h;\n    this.m_invMassA = b.m_invMass;\n    this.m_invMassB = c.m_invMass;\n    this.m_invIA = b.m_invI;\n    this.m_invIB = c.m_invI;\n    this.m_axis.SetV(Box2D.Common.Math.b2Math.MulMV(f.R, this.m_localXAxis1));\n    this.m_a1 = (d + g) * this.m_axis.y - (e + h) * this.m_axis.x;\n    this.m_a2 = i * this.m_axis.y - j * this.m_axis.x;\n    this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;\n    this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0;\n    this.m_perp.SetV(Box2D.Common.Math.b2Math.MulMV(f.R, this.m_localYAxis1));\n    this.m_s1 = (d + g) * this.m_perp.y - (e + h) * this.m_perp.x;\n    this.m_s2 = i * this.m_perp.y - j * this.m_perp.x;\n    f = this.m_invMassA;\n    g = this.m_invMassB;\n    h = this.m_invIA;\n    i = this.m_invIB;\n    this.m_K.col1.x = f + g + h * this.m_s1 * this.m_s1 + i * this.m_s2 * this.m_s2;\n    this.m_K.col1.y = h * this.m_s1 * this.m_a1 + i * this.m_s2 * this.m_a2;\n    this.m_K.col2.x = this.m_K.col1.y;\n    this.m_K.col2.y = f + g + h * this.m_a1 * this.m_a1 + i * this.m_a2 * this.m_a2;\n    this.m_enableLimit ? (d = this.m_axis.x * d + this.m_axis.y * e, Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * Box2D.Common.b2Settings.b2_linearSlop ? this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_equalLimits : d <= this.m_lowerTranslation ? this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit && (this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit, this.m_impulse.y = 0) : d >= this.m_upperTranslation ? this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit &&\n        (this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit, this.m_impulse.y = 0) : (this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit, this.m_impulse.y = 0)) : this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;\n    !1 == this.m_enableMotor && (this.m_motorImpulse = 0);\n    a.warmStarting ? (this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, this.m_motorImpulse *= a.dtRatio, a = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x, d = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y, e = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1, f = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2, b.m_linearVelocity.x -=\n        this.m_invMassA * a, b.m_linearVelocity.y -= this.m_invMassA * d, b.m_angularVelocity -= this.m_invIA * e, c.m_linearVelocity.x += this.m_invMassB * a, c.m_linearVelocity.y += this.m_invMassB * d, c.m_angularVelocity += this.m_invIB * f) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.SolveVelocityConstraints = function (a)\n{\n    var b = this.m_bodyA, c = this.m_bodyB, d = b.m_linearVelocity, e = b.m_angularVelocity, f = c.m_linearVelocity, g = c.m_angularVelocity, h = 0, i = 0, j = 0, k = 0;\n    this.m_enableMotor && this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_equalLimits && (k = this.m_motorMass * (this.m_motorSpeed - (this.m_axis.x * (f.x - d.x) + this.m_axis.y * (f.y - d.y) + this.m_a2 * g - this.m_a1 * e)), h = this.m_motorImpulse, a = a.dt * this.m_maxMotorForce, this.m_motorImpulse = Box2D.Common.Math.b2Math.Clamp(this.m_motorImpulse + k, -a, a), k = this.m_motorImpulse - h, h = k * this.m_axis.x, i = k * this.m_axis.y, j = k * this.m_a1, k *= this.m_a2, d.x -= this.m_invMassA *\n        h, d.y -= this.m_invMassA * i, e -= this.m_invIA * j, f.x += this.m_invMassB * h, f.y += this.m_invMassB * i, g += this.m_invIB * k);\n    i = this.m_perp.x * (f.x - d.x) + this.m_perp.y * (f.y - d.y) + this.m_s2 * g - this.m_s1 * e;\n    this.m_enableLimit && this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit ? (a = this.m_axis.x * (f.x - d.x) + this.m_axis.y * (f.y - d.y) + this.m_a2 * g - this.m_a1 * e, h = this.m_impulse.Copy(), j = Box2D.Common.Math.b2Vec2.Get(0, 0), a = this.m_K.Solve(j, -i, -a), Box2D.Common.Math.b2Vec2.Free(j), this.m_impulse.Add(a), this.m_limitState == Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit ? this.m_impulse.y = Math.max(this.m_impulse.y, 0) : this.m_limitState == Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit &&\n        (this.m_impulse.y = Math.min(this.m_impulse.y, 0)), i = -i - (this.m_impulse.y - h.y) * this.m_K.col2.x, j = 0, j = 0 != this.m_K.col1.x ? i / this.m_K.col1.x + h.x : h.x, this.m_impulse.x = j, a.x = this.m_impulse.x - h.x, a.y = this.m_impulse.y - h.y, Box2D.Common.Math.b2Vec2.Free(h), h = a.x * this.m_perp.x + a.y * this.m_axis.x, i = a.x * this.m_perp.y + a.y * this.m_axis.y, j = a.x * this.m_s1 + a.y * this.m_a1, k = a.x * this.m_s2 + a.y * this.m_a2) : (a = 0, a = 0 != this.m_K.col1.x ? -i /\n        this.m_K.col1.x : 0, this.m_impulse.x += a, h = a * this.m_perp.x, i = a * this.m_perp.y, j = a * this.m_s1, k = a * this.m_s2);\n    d.x -= this.m_invMassA * h;\n    d.y -= this.m_invMassA * i;\n    e -= this.m_invIA * j;\n    f.x += this.m_invMassB * h;\n    f.y += this.m_invMassB * i;\n    g += this.m_invIB * k;\n    b.m_linearVelocity.SetV(d);\n    b.m_angularVelocity = e;\n    c.m_linearVelocity.SetV(f);\n    c.m_angularVelocity = g\n};\nBox2D.Dynamics.Joints.b2LineJoint.prototype.SolvePositionConstraints = function ()\n{\n    var a = this.m_bodyA, b = this.m_bodyB, c = a.m_sweep.c, d = a.m_sweep.a, e = b.m_sweep.c, f = b.m_sweep.a, g, h = 0, i = 0, j = 0, k = 0, l = g = 0, n = 0, i = !1, m = 0, o = Box2D.Common.Math.b2Mat22.FromAngle(d), j = Box2D.Common.Math.b2Mat22.FromAngle(f);\n    g = o;\n    var n = this.m_localAnchor1.x - this.m_localCenterA.x, p = this.m_localAnchor1.y - this.m_localCenterA.y, h = g.col1.x * n + g.col2.x * p, p = g.col1.y * n + g.col2.y * p, n = h;\n    g = j;\n    j = this.m_localAnchor2.x - this.m_localCenterB.x;\n    k = this.m_localAnchor2.y - this.m_localCenterB.y;\n    h = g.col1.x * j + g.col2.x * k;\n    k = g.col1.y * j + g.col2.y * k;\n    j = h;\n    g = e.x + j - c.x - n;\n    h = e.y + k - c.y - p;\n    if (this.m_enableLimit)\n    {\n        this.m_axis = Box2D.Common.Math.b2Math.MulMV(o, this.m_localXAxis1);\n        this.m_a1 = (g + n) * this.m_axis.y - (h + p) * this.m_axis.x;\n        this.m_a2 = j * this.m_axis.y - k * this.m_axis.x;\n        var q = this.m_axis.x * g + this.m_axis.y * h;\n        Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * Box2D.Common.b2Settings.b2_linearSlop ? (m = Box2D.Common.Math.b2Math.Clamp(q, -Box2D.Common.b2Settings.b2_maxLinearCorrection, Box2D.Common.b2Settings.b2_maxLinearCorrection), l = Math.abs(q), i = !0) : q <= this.m_lowerTranslation ? (m = Box2D.Common.Math.b2Math.Clamp(q - this.m_lowerTranslation + Box2D.Common.b2Settings.b2_linearSlop, -Box2D.Common.b2Settings.b2_maxLinearCorrection, 0), l = this.m_lowerTranslation - q, i = !0) :\n            q >= this.m_upperTranslation && (m = Box2D.Common.Math.b2Math.Clamp(q - this.m_upperTranslation + Box2D.Common.b2Settings.b2_linearSlop, 0, Box2D.Common.b2Settings.b2_maxLinearCorrection), l = q - this.m_upperTranslation, i = !0)\n    }\n    this.m_perp = Box2D.Common.Math.b2Math.MulMV(o, this.m_localYAxis1);\n    this.m_s1 = (g + n) * this.m_perp.y - (h + p) * this.m_perp.x;\n    this.m_s2 = j * this.m_perp.y - k * this.m_perp.x;\n    o = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    p = this.m_perp.x * g + this.m_perp.y * h;\n    l = Math.max(l, Math.abs(p));\n    n = 0;\n    i ? (i = this.m_invMassA, j = this.m_invMassB, k = this.m_invIA, g = this.m_invIB, this.m_K.col1.x = i + j + k * this.m_s1 * this.m_s1 + g * this.m_s2 * this.m_s2, this.m_K.col1.y = k * this.m_s1 * this.m_a1 + g * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = i + j + k * this.m_a1 * this.m_a1 + g * this.m_a2 * this.m_a2, this.m_K.Solve(o, -p, -m)) : (i = this.m_invMassA, j = this.m_invMassB, k = this.m_invIA, g = this.m_invIB, m = i + j + k * this.m_s1 * this.m_s1 +\n        g * this.m_s2 * this.m_s2, o.x = 0 != m ? -p / m : 0, o.y = 0);\n    m = o.x * this.m_perp.x + o.y * this.m_axis.x;\n    i = o.x * this.m_perp.y + o.y * this.m_axis.y;\n    p = o.x * this.m_s1 + o.y * this.m_a1;\n    o = o.x * this.m_s2 + o.y * this.m_a2;\n    c.x -= this.m_invMassA * m;\n    c.y -= this.m_invMassA * i;\n    d -= this.m_invIA * p;\n    e.x += this.m_invMassB * m;\n    e.y += this.m_invMassB * i;\n    f += this.m_invIB * o;\n    a.m_sweep.a = d;\n    b.m_sweep.a = f;\n    a.SynchronizeTransform();\n    b.SynchronizeTransform();\n    return l <= Box2D.Common.b2Settings.b2_linearSlop && n <= Box2D.Common.b2Settings.b2_angularSlop\n};\nBox2D.Dynamics.Joints.b2JointDef = function ()\n{\n    this.type = Box2D.Dynamics.Joints.b2Joint.e_unknownJoint;\n    this.bodyB = this.bodyA = null;\n    this.collideConnected = !1\n};\nBox2D.Dynamics.Joints.b2LineJointDef = function ()\n{\n    Box2D.Dynamics.Joints.b2JointDef.call(this);\n    this.localAnchorA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localAnchorB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localAxisA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.type = Box2D.Dynamics.Joints.b2Joint.e_lineJoint;\n    this.localAxisA.Set(1, 0);\n    this.enableLimit = !1;\n    this.upperTranslation = this.lowerTranslation = 0;\n    this.enableMotor = !1;\n    this.motorSpeed = this.maxMotorForce = 0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);\nBox2D.Dynamics.Joints.b2LineJointDef.prototype.Initialize = function (a, b, c, d)\n{\n    this.bodyA = a;\n    this.bodyB = b;\n    this.localAnchorA = this.bodyA.GetLocalPoint(c);\n    this.localAnchorB = this.bodyB.GetLocalPoint(c);\n    this.localAxisA = this.bodyA.GetLocalVector(d)\n};\nBox2D.Dynamics.Joints.b2LineJointDef.prototype.Create = function ()\n{\n    return new Box2D.Dynamics.Joints.b2LineJoint(this)\n};\nBox2D.Collision = {};\nBox2D.Collision.b2DistanceProxy = function ()\n{\n\n    this.m_radius = this.m_count = 0;\n    this.m_vertices = []\n};\nBox2D.Collision.b2DistanceProxy.prototype.SetValues = function (a, b, c)\n{\n    this.m_count = a;\n    this.m_radius = b;\n    this.m_vertices = c\n};\nBox2D.Collision.b2DistanceProxy.prototype.Set = function (a)\n{\n    a.SetDistanceProxy(this)\n};\nBox2D.Collision.b2DistanceProxy.prototype.GetSupport = function (a)\n{\n    for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_count; d++)\n    {\n        var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;\n        e > c && (b = d, c = e)\n    }\n    return b\n};\nBox2D.Collision.b2DistanceProxy.prototype.GetSupportVertex = function (a)\n{\n    return this.m_vertices[this.GetSupport(a)]\n};\nBox2D.Collision.b2DistanceProxy.prototype.GetVertexCount = function ()\n{\n    return this.m_count\n};\nBox2D.Collision.b2DistanceProxy.prototype.GetVertex = function (a)\n{\n    void 0 === a && (a = 0);\n    Box2D.Common.b2Settings.b2Assert(0 <= a && a < this.m_count);\n    return this.m_vertices[a]\n};\nBox2D.Common.Math.b2Sweep = function ()\n{\n\n    this.localCenter = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.c0 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.c = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.t0 = this.a = this.a0 = null\n};\nBox2D.Common.Math.b2Sweep.prototype.Set = function (a)\n{\n    this.localCenter.SetV(a.localCenter);\n    this.c0.SetV(a.c0);\n    this.c.SetV(a.c);\n    this.a0 = a.a0;\n    this.a = a.a;\n    this.t0 = a.t0\n};\nBox2D.Common.Math.b2Sweep.prototype.Copy = function ()\n{\n    var a = new Box2D.Common.Math.b2Sweep;\n    a.localCenter.SetV(this.localCenter);\n    a.c0.SetV(this.c0);\n    a.c.SetV(this.c);\n    a.a0 = this.a0;\n    a.a = this.a;\n    a.t0 = this.t0;\n    return a\n};\nBox2D.Common.Math.b2Sweep.prototype.GetTransform = function (a, b)\n{\n    void 0 === b && (b = 0);\n    a.position.x = (1 - b) * this.c0.x + b * this.c.x;\n    a.position.y = (1 - b) * this.c0.y + b * this.c.y;\n    a.R.Set((1 - b) * this.a0 + b * this.a);\n    var c = a.R;\n    a.position.x -= c.col1.x * this.localCenter.x + c.col2.x * this.localCenter.y;\n    a.position.y -= c.col1.y * this.localCenter.x + c.col2.y * this.localCenter.y\n};\nBox2D.Common.Math.b2Sweep.prototype.Advance = function (a)\n{\n    void 0 === a && (a = 0);\n    if (this.t0 < a && 1 - this.t0 > Number.MIN_VALUE)\n    {\n        var b = (a - this.t0) / (1 - this.t0);\n        this.c0.x = (1 - b) * this.c0.x + b * this.c.x;\n        this.c0.y = (1 - b) * this.c0.y + b * this.c.y;\n        this.a0 = (1 - b) * this.a0 + b * this.a;\n        this.t0 = a\n    }\n};\nBox2D.Collision.b2TOIInput = function ()\n{\n\n    this.proxyA = new Box2D.Collision.b2DistanceProxy;\n    this.proxyB = new Box2D.Collision.b2DistanceProxy;\n    this.sweepA = new Box2D.Common.Math.b2Sweep;\n    this.sweepB = new Box2D.Common.Math.b2Sweep\n};\nBox2D.Common.Math.b2Vec3 = function (a, b, c)\n{\n\n    this.x = a;\n    this.y = b;\n    this.z = c\n};\nBox2D.Common.Math.b2Vec3._freeCache = [];\nBox2D.Common.Math.b2Vec3.Get = function (a, b, c)\n{\n\n    if (0 < Box2D.Common.Math.b2Vec3._freeCache.length)\n    {\n        var d = Box2D.Common.Math.b2Vec3._freeCache.pop();\n        d.Set(a, b, c);\n        return d\n    }\n    return new Box2D.Common.Math.b2Vec3(a, b, c)\n};\nBox2D.Common.Math.b2Vec3.Free = function (a)\n{\n    null != a && ( Box2D.Common.Math.b2Vec3._freeCache.push(a))\n};\nBox2D.Common.Math.b2Vec3.prototype.SetZero = function ()\n{\n    this.z = this.y = this.x = 0\n};\nBox2D.Common.Math.b2Vec3.prototype.Set = function (a, b, c)\n{\n    this.x = a;\n    this.y = b;\n    this.z = c\n};\nBox2D.Common.Math.b2Vec3.prototype.SetV = function (a)\n{\n    this.x = a.x;\n    this.y = a.y;\n    this.z = a.z\n};\nBox2D.Common.Math.b2Vec3.prototype.GetNegative = function ()\n{\n    return Box2D.Common.Math.b2Vec3.Get(-this.x, -this.y, -this.z)\n};\nBox2D.Common.Math.b2Vec3.prototype.NegativeSelf = function ()\n{\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z\n};\nBox2D.Common.Math.b2Vec3.prototype.Copy = function ()\n{\n    return Box2D.Common.Math.b2Vec3.Get(this.x, this.y, this.z)\n};\nBox2D.Common.Math.b2Vec3.prototype.Add = function (a)\n{\n    this.x += a.x;\n    this.y += a.y;\n    this.z += a.z\n};\nBox2D.Common.Math.b2Vec3.prototype.Subtract = function (a)\n{\n    this.x -= a.x;\n    this.y -= a.y;\n    this.z -= a.z\n};\nBox2D.Common.Math.b2Vec3.prototype.Multiply = function (a)\n{\n    this.x *= a;\n    this.y *= a;\n    this.z *= a\n};\nBox2D.Common.Math.b2Mat33 = function (a, b, c)\n{\n\n    this.col1 = Box2D.Common.Math.b2Vec3.Get(0, 0, 0);\n    this.col2 = Box2D.Common.Math.b2Vec3.Get(0, 0, 0);\n    this.col3 = Box2D.Common.Math.b2Vec3.Get(0, 0, 0);\n    a && this.col1.SetV(a);\n    b && this.col2.SetV(b);\n    c && this.col3.SetV(c)\n};\nBox2D.Common.Math.b2Mat33.prototype.SetVVV = function (a, b, c)\n{\n    this.col1.SetV(a);\n    this.col2.SetV(b);\n    this.col3.SetV(c)\n};\nBox2D.Common.Math.b2Mat33.prototype.Copy = function ()\n{\n    return new Box2D.Common.Math.b2Mat33(this.col1, this.col2, this.col3)\n};\nBox2D.Common.Math.b2Mat33.prototype.SetM = function (a)\n{\n    this.col1.SetV(a.col1);\n    this.col2.SetV(a.col2);\n    this.col3.SetV(a.col3)\n};\nBox2D.Common.Math.b2Mat33.prototype.AddM = function (a)\n{\n    this.col1.x += a.col1.x;\n    this.col1.y += a.col1.y;\n    this.col1.z += a.col1.z;\n    this.col2.x += a.col2.x;\n    this.col2.y += a.col2.y;\n    this.col2.z += a.col2.z;\n    this.col3.x += a.col3.x;\n    this.col3.y += a.col3.y;\n    this.col3.z += a.col3.z\n};\nBox2D.Common.Math.b2Mat33.prototype.SetIdentity = function ()\n{\n    this.col1.Set(1, 0, 0);\n    this.col2.Set(0, 1, 0);\n    this.col3.Set(0, 0, 1)\n};\nBox2D.Common.Math.b2Mat33.prototype.SetZero = function ()\n{\n    this.col1.Set(0, 0, 0);\n    this.col2.Set(0, 0, 0);\n    this.col3.Set(0, 0, 0)\n};\nBox2D.Common.Math.b2Mat33.prototype.Solve22 = function (a, b, c)\n{\n    var d = this.col1.x, e = this.col2.x, f = this.col1.y, g = this.col2.y, h = d * g - e * f;\n    0 != h && (h = 1 / h);\n    a.x = h * (g * b - e * c);\n    a.y = h * (d * c - f * b);\n    return a\n};\nBox2D.Common.Math.b2Mat33.prototype.Solve33 = function (a, b, c, d)\n{\n    var e = this.col1.x, f = this.col1.y, g = this.col1.z, h = this.col2.x, i = this.col2.y, j = this.col2.z, k = this.col3.x, l = this.col3.y, n = this.col3.z, m = e * (i * n - j * l) + f * (j * k - h * n) + g * (h * l - i * k);\n    0 != m && (m = 1 / m);\n    a.x = m * (b * (i * n - j * l) + c * (j * k - h * n) + d * (h * l - i * k));\n    a.y = m * (e * (c * n - d * l) + f * (d * k - b * n) + g * (b * l - c * k));\n    a.z = m * (e * (i * d - j * c) + f * (j * b - h * d) + g * (h * c - i * b));\n    return a\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint = function (a)\n{\n    Box2D.Dynamics.Joints.b2Joint.call(this, a);\n    this.m_localAnchor1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localXAxis1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localYAxis1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_axis = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_perp = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_K = new Box2D.Common.Math.b2Mat33;\n    this.m_impulse = Box2D.Common.Math.b2Vec3.Get(0, 0, 0);\n    this.m_localAnchor1.SetV(a.localAnchorA);\n    this.m_localAnchor2.SetV(a.localAnchorB);\n    this.m_localXAxis1.SetV(a.localAxisA);\n    this.m_localYAxis1.x = -this.m_localXAxis1.y;\n    this.m_localYAxis1.y = this.m_localXAxis1.x;\n    this.m_refAngle = a.referenceAngle;\n    this.m_impulse.SetZero();\n    this.m_motorImpulse = this.m_motorMass = 0;\n    this.m_lowerTranslation = a.lowerTranslation;\n    this.m_upperTranslation = a.upperTranslation;\n    this.m_maxMotorForce = a.maxMotorForce;\n    this.m_motorSpeed = a.motorSpeed;\n    this.m_enableLimit = a.enableLimit;\n    this.m_enableMotor = a.enableMotor;\n    this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;\n    this.m_axis.SetZero();\n    this.m_perp.SetZero()\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetAnchorA = function ()\n{\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetAnchorB = function ()\n{\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetReactionForce = function (a)\n{\n    void 0 === a && (a = 0);\n    return Box2D.Common.Math.b2Vec2.Get(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetReactionTorque = function (a)\n{\n    void 0 === a && (a = 0);\n    return a * this.m_impulse.y\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetJointTranslation = function ()\n{\n    var a = this.m_bodyA, b = this.m_bodyB, c = a.GetWorldPoint(this.m_localAnchor1), d = b.GetWorldPoint(this.m_localAnchor2), b = d.x - c.x, e = d.y - c.y;\n    Box2D.Common.Math.b2Vec2.Free(c);\n    Box2D.Common.Math.b2Vec2.Free(d);\n    a = a.GetWorldVector(this.m_localXAxis1);\n    c = a.x * b + a.y * e;\n    Box2D.Common.Math.b2Vec2.Free(a);\n    return c\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetJointSpeed = function ()\n{\n    var a = this.m_bodyA, b = this.m_bodyB, c;\n    c = a.m_xf.R;\n    var d = this.m_localAnchor1.x - a.m_sweep.localCenter.x, e = this.m_localAnchor1.y - a.m_sweep.localCenter.y, f = c.col1.x * d + c.col2.x * e, e = c.col1.y * d + c.col2.y * e, d = f;\n    c = b.m_xf.R;\n    var g = this.m_localAnchor2.x - b.m_sweep.localCenter.x, h = this.m_localAnchor2.y - b.m_sweep.localCenter.y, f = c.col1.x * g + c.col2.x * h, h = c.col1.y * g + c.col2.y * h, g = f, f = b.m_sweep.c.x + g - (a.m_sweep.c.x + d), i = b.m_sweep.c.y + h - (a.m_sweep.c.y + e);\n    c = a.GetWorldVector(this.m_localXAxis1);\n    var j = a.m_linearVelocity, k = b.m_linearVelocity, a = a.m_angularVelocity, b = b.m_angularVelocity, d = f * -a * c.y + i * a * c.x + (c.x * (k.x + -b * h - j.x - -a * e) + c.y * (k.y + b * g - j.y - a * d));\n    Box2D.Common.Math.b2Vec2.Free(c);\n    return d\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.IsLimitEnabled = function ()\n{\n    return this.m_enableLimit\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.EnableLimit = function (a)\n{\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_enableLimit = a\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetLowerLimit = function ()\n{\n    return this.m_lowerTranslation\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetUpperLimit = function ()\n{\n    return this.m_upperTranslation\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.SetLimits = function (a, b)\n{\n    void 0 === a && (a = 0);\n    void 0 === b && (b = 0);\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_lowerTranslation = a;\n    this.m_upperTranslation = b\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.IsMotorEnabled = function ()\n{\n    return this.m_enableMotor\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.EnableMotor = function (a)\n{\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_enableMotor = a\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.SetMotorSpeed = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_motorSpeed = a\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetMotorSpeed = function ()\n{\n    return this.m_motorSpeed\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.SetMaxMotorForce = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_maxMotorForce = a\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.GetMotorForce = function ()\n{\n    return this.m_motorImpulse\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.InitVelocityConstraints = function (a)\n{\n    var b = this.m_bodyA, c = this.m_bodyB, d, e = 0;\n    this.m_localCenterA.SetV(b.GetLocalCenter());\n    this.m_localCenterB.SetV(c.GetLocalCenter());\n    var f = b.GetTransform();\n    d = b.m_xf.R;\n    var g = this.m_localAnchor1.x - this.m_localCenterA.x, h = this.m_localAnchor1.y - this.m_localCenterA.y, e = d.col1.x * g + d.col2.x * h, h = d.col1.y * g + d.col2.y * h, g = e;\n    d = c.m_xf.R;\n    var i = this.m_localAnchor2.x - this.m_localCenterB.x, j = this.m_localAnchor2.y - this.m_localCenterB.y, e = d.col1.x * i + d.col2.x * j, j = d.col1.y * i + d.col2.y * j, i = e;\n    d = c.m_sweep.c.x + i - b.m_sweep.c.x - g;\n    e = c.m_sweep.c.y + j - b.m_sweep.c.y - h;\n    this.m_invMassA = b.m_invMass;\n    this.m_invMassB = c.m_invMass;\n    this.m_invIA = b.m_invI;\n    this.m_invIB = c.m_invI;\n    var k = Box2D.Common.Math.b2Math.MulMV(f.R, this.m_localXAxis1);\n    this.m_axis.SetV(k);\n    Box2D.Common.Math.b2Vec2.Free(k);\n    this.m_a1 = (d + g) * this.m_axis.y - (e + h) * this.m_axis.x;\n    this.m_a2 = i * this.m_axis.y - j * this.m_axis.x;\n    this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;\n    this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass);\n    f = Box2D.Common.Math.b2Math.MulMV(f.R, this.m_localYAxis1);\n    this.m_perp.SetV(f);\n    Box2D.Common.Math.b2Vec2.Free(f);\n    this.m_s1 = (d + g) * this.m_perp.y - (e + h) * this.m_perp.x;\n    this.m_s2 = i * this.m_perp.y - j * this.m_perp.x;\n    g = this.m_invMassA;\n    h = this.m_invMassB;\n    i = this.m_invIA;\n    j = this.m_invIB;\n    this.m_K.col1.x = g + h + i * this.m_s1 * this.m_s1 + j * this.m_s2 * this.m_s2;\n    this.m_K.col1.y = i * this.m_s1 + j * this.m_s2;\n    this.m_K.col1.z = i * this.m_s1 * this.m_a1 + j * this.m_s2 * this.m_a2;\n    this.m_K.col2.x = this.m_K.col1.y;\n    this.m_K.col2.y = i + j;\n    this.m_K.col2.z = i * this.m_a1 + j * this.m_a2;\n    this.m_K.col3.x = this.m_K.col1.z;\n    this.m_K.col3.y = this.m_K.col2.z;\n    this.m_K.col3.z = g + h + i * this.m_a1 * this.m_a1 + j * this.m_a2 * this.m_a2;\n    this.m_enableLimit ? (d = this.m_axis.x * d + this.m_axis.y * e, Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * Box2D.Common.b2Settings.b2_linearSlop ? this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_equalLimits : d <= this.m_lowerTranslation ? this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit && (this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit, this.m_impulse.z = 0) : d >= this.m_upperTranslation ? this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit &&\n        (this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit, this.m_impulse.z = 0)) : this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;\n    !1 == this.m_enableMotor && (this.m_motorImpulse = 0);\n    a.warmStarting ? (this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, this.m_motorImpulse *= a.dtRatio, a = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x, d = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y, e = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1, g = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) *\n        this.m_a2, b.m_linearVelocity.x -= this.m_invMassA * a, b.m_linearVelocity.y -= this.m_invMassA * d, b.m_angularVelocity -= this.m_invIA * e, c.m_linearVelocity.x += this.m_invMassB * a, c.m_linearVelocity.y += this.m_invMassB * d, c.m_angularVelocity += this.m_invIB * g) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.SolveVelocityConstraints = function (a)\n{\n    var b = this.m_bodyA, c = this.m_bodyB, d = b.m_linearVelocity, e = b.m_angularVelocity, f = c.m_linearVelocity, g = c.m_angularVelocity, h = 0, i = 0, j = 0, k = 0;\n    this.m_enableMotor && this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_equalLimits && (k = this.m_motorMass * (this.m_motorSpeed - (this.m_axis.x * (f.x - d.x) + this.m_axis.y * (f.y - d.y) + this.m_a2 * g - this.m_a1 * e)), h = this.m_motorImpulse, a = a.dt * this.m_maxMotorForce, this.m_motorImpulse = Box2D.Common.Math.b2Math.Clamp(this.m_motorImpulse + k, -a, a), k = this.m_motorImpulse - h, h = k * this.m_axis.x, i = k * this.m_axis.y, j = k * this.m_a1, k *= this.m_a2, d.x -= this.m_invMassA *\n        h, d.y -= this.m_invMassA * i, e -= this.m_invIA * j, f.x += this.m_invMassB * h, f.y += this.m_invMassB * i, g += this.m_invIB * k);\n    j = this.m_perp.x * (f.x - d.x) + this.m_perp.y * (f.y - d.y) + this.m_s2 * g - this.m_s1 * e;\n    i = g - e;\n    this.m_enableLimit && this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit ? (k = this.m_axis.x * (f.x - d.x) + this.m_axis.y * (f.y - d.y) + this.m_a2 * g - this.m_a1 * e, h = this.m_impulse.Copy(), a = Box2D.Common.Math.b2Vec3.Get(0, 0, 0), this.m_K.Solve33(a, -j, -i, -k), this.m_impulse.Add(a), this.m_limitState == Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit ? this.m_impulse.z = Math.max(this.m_impulse.z, 0) : this.m_limitState == Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit &&\n        (this.m_impulse.z = Math.min(this.m_impulse.z, 0)), j = -j - (this.m_impulse.z - h.z) * this.m_K.col3.x, i = -i - (this.m_impulse.z - h.z) * this.m_K.col3.y, k = Box2D.Common.Math.b2Vec2.Get(0, 0), this.m_K.Solve22(k, j, i), k.x += h.x, k.y += h.y, this.m_impulse.x = k.x, this.m_impulse.y = k.y, Box2D.Common.Math.b2Vec2.Free(k), a.x = this.m_impulse.x - h.x, a.y = this.m_impulse.y - h.y, a.z = this.m_impulse.z - h.z, h = a.x * this.m_perp.x + a.z * this.m_axis.x, i = a.x * this.m_perp.y + a.z *\n        this.m_axis.y, j = a.x * this.m_s1 + a.y + a.z * this.m_a1, k = a.x * this.m_s2 + a.y + a.z * this.m_a2, Box2D.Common.Math.b2Vec3.Free(a)) : (a = Box2D.Common.Math.b2Vec2.Get(0, 0), this.m_K.Solve22(a, -j, -i), this.m_impulse.x += a.x, this.m_impulse.y += a.y, h = a.x * this.m_perp.x, i = a.x * this.m_perp.y, j = a.x * this.m_s1 + a.y, k = a.x * this.m_s2 + a.y, Box2D.Common.Math.b2Vec2.Free(a));\n    d.x -= this.m_invMassA * h;\n    d.y -= this.m_invMassA * i;\n    e -= this.m_invIA * j;\n    f.x += this.m_invMassB * h;\n    f.y += this.m_invMassB * i;\n    g += this.m_invIB * k;\n    b.m_linearVelocity.SetV(d);\n    b.m_angularVelocity = e;\n    c.m_linearVelocity.SetV(f);\n    c.m_angularVelocity = g\n};\nBox2D.Dynamics.Joints.b2PrismaticJoint.prototype.SolvePositionConstraints = function ()\n{\n    var a = this.m_bodyA, b = this.m_bodyB, c = a.m_sweep.c, d = a.m_sweep.a, e = b.m_sweep.c, f = b.m_sweep.a, g = 0, h = 0, i = 0, j = g = 0, k = 0, l = 0, h = !1, n = 0, m = Box2D.Common.Math.b2Mat22.FromAngle(d), l = this.m_localAnchor1.x - this.m_localCenterA.x, o = this.m_localAnchor1.y - this.m_localCenterA.y, g = m.col1.x * l + m.col2.x * o, o = m.col1.y * l + m.col2.y * o;\n    Box2D.Common.Math.b2Mat22.Free(m);\n    var l = g, j = Box2D.Common.Math.b2Mat22.FromAngle(f), p = this.m_localAnchor2.x - this.m_localCenterB.x, i = this.m_localAnchor2.y - this.m_localCenterB.y, g = j.col1.x * p + j.col2.x * i, i = j.col1.y * p + j.col2.y * i;\n    Box2D.Common.Math.b2Mat22.Free(j);\n    p = g;\n    g = e.x + p - c.x - l;\n    j = e.y + i - c.y - o;\n    if (this.m_enableLimit)\n    {\n        Box2D.Common.Math.b2Vec2.Free(this.m_axis);\n        this.m_axis = Box2D.Common.Math.b2Math.MulMV(m, this.m_localXAxis1);\n        this.m_a1 = (g + l) * this.m_axis.y - (j + o) * this.m_axis.x;\n        this.m_a2 = p * this.m_axis.y - i * this.m_axis.x;\n        var q = this.m_axis.x * g + this.m_axis.y * j;\n        Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * Box2D.Common.b2Settings.b2_linearSlop ? (n = Box2D.Common.Math.b2Math.Clamp(q, -Box2D.Common.b2Settings.b2_maxLinearCorrection, Box2D.Common.b2Settings.b2_maxLinearCorrection), k = Math.abs(q), h = !0) : q <= this.m_lowerTranslation ? (n = Box2D.Common.Math.b2Math.Clamp(q - this.m_lowerTranslation + Box2D.Common.b2Settings.b2_linearSlop, -Box2D.Common.b2Settings.b2_maxLinearCorrection, 0), k = this.m_lowerTranslation - q, h = !0) :\n            q >= this.m_upperTranslation && (n = Box2D.Common.Math.b2Math.Clamp(q - this.m_upperTranslation + Box2D.Common.b2Settings.b2_linearSlop, 0, Box2D.Common.b2Settings.b2_maxLinearCorrection), k = q - this.m_upperTranslation, h = !0)\n    }\n    Box2D.Common.Math.b2Vec2.Free(this.m_perp);\n    this.m_perp = Box2D.Common.Math.b2Math.MulMV(m, this.m_localYAxis1);\n    this.m_s1 = (g + l) * this.m_perp.y - (j + o) * this.m_perp.x;\n    this.m_s2 = p * this.m_perp.y - i * this.m_perp.x;\n    m = Box2D.Common.Math.b2Vec3.Get(0, 0, 0);\n    o = this.m_perp.x * g + this.m_perp.y * j;\n    p = f - d - this.m_refAngle;\n    k = Math.max(k, Math.abs(o));\n    l = Math.abs(p);\n    h ? (h = this.m_invMassA, i = this.m_invMassB, g = this.m_invIA, j = this.m_invIB, this.m_K.col1.x = h + i + g * this.m_s1 * this.m_s1 + j * this.m_s2 * this.m_s2, this.m_K.col1.y = g * this.m_s1 + j * this.m_s2, this.m_K.col1.z = g * this.m_s1 * this.m_a1 + j * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = g + j, this.m_K.col2.z = g * this.m_a1 + j * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = h + i + g * this.m_a1 *\n        this.m_a1 + j * this.m_a2 * this.m_a2, this.m_K.Solve33(m, -o, -p, -n)) : (h = this.m_invMassA, i = this.m_invMassB, g = this.m_invIA, j = this.m_invIB, n = g * this.m_s1 + j * this.m_s2, q = g + j, this.m_K.col1.Set(h + i + g * this.m_s1 * this.m_s1 + j * this.m_s2 * this.m_s2, n, 0), this.m_K.col2.Set(n, q, 0), n = Box2D.Common.Math.b2Vec2.Get(0, 0), this.m_K.Solve22(n, -o, -p), m.x = n.x, m.y = n.y, Box2D.Common.Math.b2Vec2.Free(n), m.z = 0);\n    n = m.x * this.m_perp.x + m.z * this.m_axis.x;\n    h = m.x * this.m_perp.y + m.z * this.m_axis.y;\n    o = m.x * this.m_s1 + m.y + m.z * this.m_a1;\n    p = m.x * this.m_s2 + m.y + m.z * this.m_a2;\n    Box2D.Common.Math.b2Vec3.Free(m);\n    c.x -= this.m_invMassA * n;\n    c.y -= this.m_invMassA * h;\n    d -= this.m_invIA * o;\n    e.x += this.m_invMassB * n;\n    e.y += this.m_invMassB * h;\n    f += this.m_invIB * p;\n    a.m_sweep.a = d;\n    b.m_sweep.a = f;\n    a.SynchronizeTransform();\n    b.SynchronizeTransform();\n    return k <= Box2D.Common.b2Settings.b2_linearSlop && l <= Box2D.Common.b2Settings.b2_angularSlop\n};\nBox2D.Dynamics.Joints.b2PrismaticJointDef = function ()\n{\n    Box2D.Dynamics.Joints.b2JointDef.call(this);\n    this.localAnchorA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localAnchorB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localAxisA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.type = Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint;\n    this.localAxisA.Set(1, 0);\n    this.referenceAngle = 0;\n    this.enableLimit = !1;\n    this.upperTranslation = this.lowerTranslation = 0;\n    this.enableMotor = !1;\n    this.motorSpeed = this.maxMotorForce = 0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);\nBox2D.Dynamics.Joints.b2PrismaticJointDef.prototype.Initialize = function (a, b, c, d)\n{\n    this.bodyA = a;\n    this.bodyB = b;\n    this.localAnchorA = this.bodyA.GetLocalPoint(c);\n    this.localAnchorB = this.bodyB.GetLocalPoint(c);\n    this.localAxisA = this.bodyA.GetLocalVector(d);\n    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()\n};\nBox2D.Dynamics.Joints.b2PrismaticJointDef.prototype.Create = function ()\n{\n    return new Box2D.Dynamics.Joints.b2PrismaticJoint(this)\n};\nBox2D.Dynamics.Joints.b2WeldJoint = function (a)\n{\n    Box2D.Dynamics.Joints.b2Joint.call(this, a);\n    this.m_localAnchorA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchorB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_impulse = Box2D.Common.Math.b2Vec3.Get(0, 0, 0);\n    this.m_mass = new Box2D.Common.Math.b2Mat33;\n    this.m_localAnchorA.SetV(a.localAnchorA);\n    this.m_localAnchorB.SetV(a.localAnchorB);\n    this.m_referenceAngle = a.referenceAngle\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);\nBox2D.Dynamics.Joints.b2WeldJoint.prototype.GetAnchorA = function ()\n{\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)\n};\nBox2D.Dynamics.Joints.b2WeldJoint.prototype.GetAnchorB = function ()\n{\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)\n};\nBox2D.Dynamics.Joints.b2WeldJoint.prototype.GetReactionForce = function (a)\n{\n    return Box2D.Common.Math.b2Vec2.Get(a * this.m_impulse.x, a * this.m_impulse.y)\n};\nBox2D.Dynamics.Joints.b2WeldJoint.prototype.GetReactionTorque = function (a)\n{\n    return a * this.m_impulse.z\n};\nBox2D.Dynamics.Joints.b2WeldJoint.prototype.InitVelocityConstraints = function (a)\n{\n    var b, c = 0, d = this.m_bodyA, e = this.m_bodyB;\n    b = d.m_xf.R;\n    var f = this.m_localAnchorA.x - d.m_sweep.localCenter.x, g = this.m_localAnchorA.y - d.m_sweep.localCenter.y, c = b.col1.x * f + b.col2.x * g, g = b.col1.y * f + b.col2.y * g, f = c;\n    b = e.m_xf.R;\n    var h = this.m_localAnchorB.x - e.m_sweep.localCenter.x, i = this.m_localAnchorB.y - e.m_sweep.localCenter.y, c = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = c;\n    b = d.m_invMass;\n    var c = e.m_invMass, j = d.m_invI, k = e.m_invI;\n    this.m_mass.col1.x = b + c + g * g * j + i * i * k;\n    this.m_mass.col2.x = -g * f * j - i * h * k;\n    this.m_mass.col3.x = -g * j - i * k;\n    this.m_mass.col1.y = this.m_mass.col2.x;\n    this.m_mass.col2.y = b + c + f * f * j + h * h * k;\n    this.m_mass.col3.y = f * j + h * k;\n    this.m_mass.col1.z = this.m_mass.col3.x;\n    this.m_mass.col2.z = this.m_mass.col3.y;\n    this.m_mass.col3.z = j + k;\n    a.warmStarting ? (this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, this.m_impulse.z *= a.dtRatio, d.m_linearVelocity.x -= b * this.m_impulse.x, d.m_linearVelocity.y -= b * this.m_impulse.y, d.m_angularVelocity -= j * (f * this.m_impulse.y - g * this.m_impulse.x + this.m_impulse.z), e.m_linearVelocity.x += c * this.m_impulse.x, e.m_linearVelocity.y += c * this.m_impulse.y, e.m_angularVelocity += k * (h * this.m_impulse.y - i * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero()\n};\nBox2D.Dynamics.Joints.b2WeldJoint.prototype.SolveVelocityConstraints = function ()\n{\n    var a, b = 0, c = this.m_bodyA, d = this.m_bodyB, e = c.m_linearVelocity, f = c.m_angularVelocity, g = d.m_linearVelocity, h = d.m_angularVelocity, i = c.m_invMass, j = d.m_invMass, k = c.m_invI, l = d.m_invI;\n    a = c.m_xf.R;\n    var n = this.m_localAnchorA.x - c.m_sweep.localCenter.x, m = this.m_localAnchorA.y - c.m_sweep.localCenter.y, b = a.col1.x * n + a.col2.x * m, m = a.col1.y * n + a.col2.y * m, n = b;\n    a = d.m_xf.R;\n    var o = this.m_localAnchorB.x - d.m_sweep.localCenter.x, p = this.m_localAnchorB.y - d.m_sweep.localCenter.y, b = a.col1.x * o + a.col2.x * p, p = a.col1.y * o + a.col2.y * p, o = b;\n    a = g.x - h * p - e.x + f * m;\n    var b = g.y + h * o - e.y - f * n, q = h - f, r = Box2D.Common.Math.b2Vec3.Get(0, 0, 0);\n    this.m_mass.Solve33(r, -a, -b, -q);\n    this.m_impulse.Add(r);\n    e.x -= i * r.x;\n    e.y -= i * r.y;\n    f -= k * (n * r.y - m * r.x + r.z);\n    g.x += j * r.x;\n    g.y += j * r.y;\n    h += l * (o * r.y - p * r.x + r.z);\n    Box2D.Common.Math.b2Vec3.Free(r);\n    c.m_angularVelocity = f;\n    d.m_angularVelocity = h\n};\nBox2D.Dynamics.Joints.b2WeldJoint.prototype.SolvePositionConstraints = function ()\n{\n    var a, b = 0, c = this.m_bodyA, d = this.m_bodyB;\n    a = c.m_xf.R;\n    var e = this.m_localAnchorA.x - c.m_sweep.localCenter.x, f = this.m_localAnchorA.y - c.m_sweep.localCenter.y, b = a.col1.x * e + a.col2.x * f, f = a.col1.y * e + a.col2.y * f, e = b;\n    a = d.m_xf.R;\n    var g = this.m_localAnchorB.x - d.m_sweep.localCenter.x, h = this.m_localAnchorB.y - d.m_sweep.localCenter.y, b = a.col1.x * g + a.col2.x * h, h = a.col1.y * g + a.col2.y * h, g = b;\n    a = c.m_invMass;\n    var b = d.m_invMass, i = c.m_invI, j = d.m_invI, k = d.m_sweep.c.x + g - c.m_sweep.c.x - e, l = d.m_sweep.c.y + h - c.m_sweep.c.y - f, n = d.m_sweep.a - c.m_sweep.a - this.m_referenceAngle, m = 10 * Box2D.Common.b2Settings.b2_linearSlop, o = Math.sqrt(k * k + l * l), p = Math.abs(n);\n    o > m && (i *= 1, j *= 1);\n    this.m_mass.col1.x = a + b + f * f * i + h * h * j;\n    this.m_mass.col2.x = -f * e * i - h * g * j;\n    this.m_mass.col3.x = -f * i - h * j;\n    this.m_mass.col1.y = this.m_mass.col2.x;\n    this.m_mass.col2.y = a + b + e * e * i + g * g * j;\n    this.m_mass.col3.y = e * i + g * j;\n    this.m_mass.col1.z = this.m_mass.col3.x;\n    this.m_mass.col2.z = this.m_mass.col3.y;\n    this.m_mass.col3.z = i + j;\n    m = Box2D.Common.Math.b2Vec3.Get(0, 0, 0);\n    this.m_mass.Solve33(m, -k, -l, -n);\n    c.m_sweep.c.x -= a * m.x;\n    c.m_sweep.c.y -= a * m.y;\n    c.m_sweep.a -= i * (e * m.y - f * m.x + m.z);\n    d.m_sweep.c.x += b * m.x;\n    d.m_sweep.c.y += b * m.y;\n    d.m_sweep.a += j * (g * m.y - h * m.x + m.z);\n    Box2D.Common.Math.b2Vec3.Free(m);\n    c.SynchronizeTransform();\n    d.SynchronizeTransform();\n    return o <= Box2D.Common.b2Settings.b2_linearSlop && p <= Box2D.Common.b2Settings.b2_angularSlop\n};\nBox2D.Dynamics.Joints.b2WeldJointDef = function ()\n{\n    Box2D.Dynamics.Joints.b2JointDef.call(this);\n    this.localAnchorA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localAnchorB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.type = Box2D.Dynamics.Joints.b2Joint.e_weldJoint;\n    this.referenceAngle = 0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);\nBox2D.Dynamics.Joints.b2WeldJointDef.prototype.Initialize = function (a, b, c)\n{\n    this.bodyA = a;\n    this.bodyB = b;\n    this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c));\n    this.localAnchorB.SetV(this.bodyB.GetLocalPoint(c));\n    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()\n};\nBox2D.Dynamics.Joints.b2WeldJointDef.prototype.Create = function ()\n{\n    return new Box2D.Dynamics.Joints.b2WeldJoint(this)\n};\nBox2D.Collision.b2DistanceOutput = function ()\n{\n\n    this.pointA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.pointB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.distance = 0\n};\nBox2D.Collision.b2SimplexVertex = function ()\n{\n\n    this.wA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.wB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.w = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.indexB = this.indexA = this.a = 0\n};\nBox2D.Collision.b2SimplexVertex.prototype.Set = function (a)\n{\n    this.wA.SetV(a.wA);\n    this.wB.SetV(a.wB);\n    this.w.SetV(a.w);\n    this.a = a.a;\n    this.indexA = a.indexA;\n    this.indexB = a.indexB\n};\nBox2D.Collision.b2Simplex = function ()\n{\n\n    this.m_v1 = new Box2D.Collision.b2SimplexVertex;\n    this.m_v2 = new Box2D.Collision.b2SimplexVertex;\n    this.m_v3 = new Box2D.Collision.b2SimplexVertex;\n    this.m_vertices = [this.m_v1, this.m_v2, this.m_v3]\n};\nBox2D.Collision.b2Simplex._freeCache = [];\nBox2D.Collision.b2Simplex.Get = function ()\n{\n    if (0 < Box2D.Collision.b2Simplex._freeCache.length)\n    {\n        for (var a = Box2D.Collision.b2Simplex._freeCache.pop(), b = 0; b < a.m_vertices.length; b++)\n        {\n            var c = a.m_vertices[b];\n            null != c.wA && c.wA.Set(0, 0);\n            null != c.wB && c.wB.Set(0, 0);\n            null != c.w && c.w.Set(0, 0);\n            c.indexA = 0;\n            c.indexB = 0;\n            c.a = 0\n        }\n        return a\n    }\n    return new Box2D.Collision.b2Simplex\n};\nBox2D.Collision.b2Simplex.Free = function (a)\n{\n    null != a && Box2D.Collision.b2Simplex._freeCache.push(a)\n};\nBox2D.Collision.b2Simplex.prototype.ReadCache = function (a, b, c, d, e)\n{\n    Box2D.Common.b2Settings.b2Assert(0 <= a.count && 3 >= a.count);\n    var f, g;\n    this.m_count = a.count;\n    for (var h = this.m_vertices, i = 0; i < this.m_count; i++)\n    {\n        var j = h[i];\n        j.indexA = a.indexA[i];\n        j.indexB = a.indexB[i];\n        f = b.GetVertex(j.indexA);\n        g = d.GetVertex(j.indexB);\n        Box2D.Common.Math.b2Vec2.Free(j.wA);\n        Box2D.Common.Math.b2Vec2.Free(j.wB);\n        Box2D.Common.Math.b2Vec2.Free(j.w);\n        j.wA = Box2D.Common.Math.b2Math.MulX(c, f);\n        j.wB = Box2D.Common.Math.b2Math.MulX(e, g);\n        j.w = Box2D.Common.Math.b2Math.SubtractVV(j.wB, j.wA);\n        j.a = 0\n    }\n    if (1 < this.m_count && (a = a.metric, f = this.GetMetric(), f < 0.5 * a || 2 * a < f || f < Number.MIN_VALUE))\n    {\n        this.m_count = 0\n    }\n    0 == this.m_count && (j = h[0], j.indexA = 0, j.indexB = 0, f = b.GetVertex(0), g = d.GetVertex(0), Box2D.Common.Math.b2Vec2.Free(j.wA), Box2D.Common.Math.b2Vec2.Free(j.wB), Box2D.Common.Math.b2Vec2.Free(j.w), j.wA = Box2D.Common.Math.b2Math.MulX(c, f), j.wB = Box2D.Common.Math.b2Math.MulX(e, g), j.w = Box2D.Common.Math.b2Math.SubtractVV(j.wB, j.wA), this.m_count = 1)\n};\nBox2D.Collision.b2Simplex.prototype.WriteCache = function (a)\n{\n    a.metric = this.GetMetric();\n    a.count = this.m_count;\n    for (var b = this.m_vertices, c = 0; c < this.m_count; c++)\n    {\n        a.indexA[c] = b[c].indexA, a.indexB[c] = b[c].indexB\n    }\n};\nBox2D.Collision.b2Simplex.prototype.GetSearchDirection = function ()\n{\n    if (1 == this.m_count)\n    {\n        return this.m_v1.w.GetNegative()\n    }\n    if (2 == this.m_count)\n    {\n        var a = Box2D.Common.Math.b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b = this.m_v1.w.GetNegative(), c = Box2D.Common.Math.b2Math.CrossVV(a, b);\n        Box2D.Common.Math.b2Vec2.Free(b);\n        b = null;\n        b = 0 < c ? Box2D.Common.Math.b2Math.CrossFV(1, a) : Box2D.Common.Math.b2Math.CrossVF(a, 1);\n        Box2D.Common.Math.b2Vec2.Free(a);\n        return b\n    }\n    Box2D.Common.b2Settings.b2Assert(!1);\n    return Box2D.Common.Math.b2Vec2.Get(0, 0)\n};\nBox2D.Collision.b2Simplex.prototype.GetClosestPoint = function ()\n{\n    if (1 == this.m_count)\n    {\n        return this.m_v1.w\n    }\n    if (2 == this.m_count)\n    {\n        return Box2D.Common.Math.b2Vec2.Get(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y)\n    }\n    Box2D.Common.b2Settings.b2Assert(!1);\n    return Box2D.Common.Math.b2Vec2.Get(0, 0)\n};\nBox2D.Collision.b2Simplex.prototype.GetWitnessPoints = function (a, b)\n{\n    1 == this.m_count ? (a.SetV(this.m_v1.wA), b.SetV(this.m_v1.wB)) : 2 == this.m_count ? (a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, b.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, b.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y) : 3 == this.m_count ? (b.x = a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, b.y = a.y = this.m_v1.a *\n        this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y) : Box2D.Common.b2Settings.b2Assert(!1)\n};\nBox2D.Collision.b2Simplex.prototype.GetMetric = function ()\n{\n    if (1 == this.m_count)\n    {\n        return 0\n    }\n    if (2 == this.m_count)\n    {\n        var a = Box2D.Common.Math.b2Math.SubtractVV(this.m_v1.w, this.m_v2.w), b = a.Length();\n        Box2D.Common.Math.b2Vec2.Free(a);\n        return b\n    }\n    if (3 == this.m_count)\n    {\n        var a = Box2D.Common.Math.b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), c = Box2D.Common.Math.b2Math.SubtractVV(this.m_v3.w, this.m_v1.w), b = Box2D.Common.Math.b2Math.CrossVV(a, c);\n        Box2D.Common.Math.b2Vec2.Free(a);\n        Box2D.Common.Math.b2Vec2.Free(c);\n        return b\n    }\n    Box2D.Common.b2Settings.b2Assert(!1);\n    return 0\n};\nBox2D.Collision.b2Simplex.prototype.Solve2 = function ()\n{\n    var a = this.m_v1.w, b = this.m_v2.w, c = Box2D.Common.Math.b2Math.SubtractVV(b, a), a = -(a.x * c.x + a.y * c.y);\n    0 >= a ? (Box2D.Common.Math.b2Vec2.Free(c), this.m_count = this.m_v1.a = 1) : (b = b.x * c.x + b.y * c.y, Box2D.Common.Math.b2Vec2.Free(c), 0 >= b ? (this.m_count = this.m_v2.a = 1, this.m_v1.Set(this.m_v2)) : (c = 1 / (b + a), this.m_v1.a = b * c, this.m_v2.a = a * c, this.m_count = 2))\n};\nBox2D.Collision.b2Simplex.prototype.Solve3 = function ()\n{\n    var a = this.m_v1.w, b = this.m_v2.w, c = this.m_v3.w, d = Box2D.Common.Math.b2Math.SubtractVV(b, a), e = Box2D.Common.Math.b2Math.Dot(a, d), f = Box2D.Common.Math.b2Math.Dot(b, d), e = -e, g = Box2D.Common.Math.b2Math.SubtractVV(c, a), h = Box2D.Common.Math.b2Math.Dot(a, g), i = Box2D.Common.Math.b2Math.Dot(c, g), j = Box2D.Common.Math.b2Math.CrossVV(d, g);\n    Box2D.Common.Math.b2Vec2.Free(d);\n    Box2D.Common.Math.b2Vec2.Free(g);\n    var d = -h, h = Box2D.Common.Math.b2Math.SubtractVV(c, b), k = Box2D.Common.Math.b2Math.Dot(b, h), g = Box2D.Common.Math.b2Math.Dot(c, h);\n    Box2D.Common.Math.b2Vec2.Free(h);\n    h = -k;\n    k = j * Box2D.Common.Math.b2Math.CrossVV(b, c);\n    c = j * Box2D.Common.Math.b2Math.CrossVV(c, a);\n    a = j * Box2D.Common.Math.b2Math.CrossVV(a, b);\n    0 >= e && 0 >= d ? this.m_count = this.m_v1.a = 1 : 0 < f && 0 < e && 0 >= a ? (i = 1 / (f + e), this.m_v1.a = f * i, this.m_v2.a = e * i, this.m_count = 2) : 0 < i && 0 < d && 0 >= c ? (f = 1 / (i + d), this.m_v1.a = i * f, this.m_v3.a = d * f, this.m_count = 2, this.m_v2.Set(this.m_v3)) : 0 >= f && 0 >= h ? (this.m_count = this.m_v2.a = 1, this.m_v1.Set(this.m_v2)) : 0 >= i && 0 >= g ? (this.m_count = this.m_v3.a = 1, this.m_v1.Set(this.m_v3)) : 0 < g && 0 < h && 0 >= k ? (f = 1 / (g + h), this.m_v2.a =\n        g * f, this.m_v3.a = h * f, this.m_count = 2, this.m_v1.Set(this.m_v3)) : (f = 1 / (k + c + a), this.m_v1.a = k * f, this.m_v2.a = c * f, this.m_v3.a = a * f, this.m_count = 3)\n};\nBox2D.Collision.b2Distance = {};\nBox2D.Collision.b2Distance.Distance = function (a, b, c)\n{\n    var d = Box2D.Collision.b2Simplex.Get();\n    d.ReadCache(b, c.proxyA, c.transformA, c.proxyB, c.transformB);\n    (1 > d.m_count || 3 < d.m_count) && Box2D.Common.b2Settings.b2Assert(!1);\n    for (var e = 0; 20 > e;)\n    {\n        for (var f = [], g = 0; g < d.m_count; g++)\n        {\n            f[g] = {}, f[g].indexA = d.m_vertices[g].indexA, f[g].indexB = d.m_vertices[g].indexB\n        }\n        2 == d.m_count ? d.Solve2() : 3 == d.m_count && d.Solve3();\n        if (3 == d.m_count)\n        {\n            break\n        }\n        g = d.GetSearchDirection();\n        if (g.LengthSquared() < Box2D.Common.b2Settings.MIN_VALUE_SQUARED)\n        {\n            Box2D.Common.Math.b2Vec2.Free(g);\n            break\n        }\n        Box2D.Common.Math.b2Vec2.Free(d.m_vertices[d.m_count].wA);\n        Box2D.Common.Math.b2Vec2.Free(d.m_vertices[d.m_count].wB);\n        Box2D.Common.Math.b2Vec2.Free(d.m_vertices[d.m_count].w);\n        var h = g.GetNegative(), i = Box2D.Common.Math.b2Math.MulTMV(c.transformA.R, h);\n        Box2D.Common.Math.b2Vec2.Free(h);\n        d.m_vertices[d.m_count].indexA = c.proxyA.GetSupport(i);\n        Box2D.Common.Math.b2Vec2.Free(i);\n        d.m_vertices[d.m_count].wA = Box2D.Common.Math.b2Math.MulX(c.transformA, c.proxyA.GetVertex(d.m_vertices[d.m_count].indexA));\n        h = Box2D.Common.Math.b2Math.MulTMV(c.transformB.R, g);\n        Box2D.Common.Math.b2Vec2.Free(g);\n        d.m_vertices[d.m_count].indexB = c.proxyB.GetSupport(h);\n        Box2D.Common.Math.b2Vec2.Free(h);\n        d.m_vertices[d.m_count].wB = Box2D.Common.Math.b2Math.MulX(c.transformB, c.proxyB.GetVertex(d.m_vertices[d.m_count].indexB));\n        d.m_vertices[d.m_count].w = Box2D.Common.Math.b2Math.SubtractVV(d.m_vertices[d.m_count].wB, d.m_vertices[d.m_count].wA);\n        e++;\n        h = !1;\n        for (g = 0; g < f.length; g++)\n        {\n            if (d.m_vertices[d.m_count].indexA == f[g].indexA && d.m_vertices[d.m_count].indexB == f[g].indexB)\n            {\n                h = !0;\n                break\n            }\n        }\n        if (h)\n        {\n            break\n        }\n        d.m_count++\n    }\n    d.GetWitnessPoints(a.pointA, a.pointB);\n    e = Box2D.Common.Math.b2Math.SubtractVV(a.pointA, a.pointB);\n    a.distance = e.Length();\n    Box2D.Common.Math.b2Vec2.Free(e);\n    d.WriteCache(b);\n    Box2D.Collision.b2Simplex.Free(d);\n    c.useRadii && (b = c.proxyA.m_radius, c = c.proxyB.m_radius, a.distance > b + c && a.distance > Number.MIN_VALUE ? (a.distance -= b + c, d = Box2D.Common.Math.b2Math.SubtractVV(a.pointB, a.pointA), d.Normalize(), a.pointA.x += b * d.x, a.pointA.y += b * d.y, a.pointB.x -= c * d.x, a.pointB.y -= c * d.y, Box2D.Common.Math.b2Vec2.Free(d)) : (c = Box2D.Common.Math.b2Vec2.Get(0, 0), c.x = 0.5 * (a.pointA.x + a.pointB.x), c.y = 0.5 * (a.pointA.y + a.pointB.y), a.pointA.x = a.pointB.x = c.x, a.pointA.y =\n        a.pointB.y = c.y, a.distance = 0, Box2D.Common.Math.b2Vec2.Free(c)))\n};\nBox2D.Collision.b2SimplexCache = function ()\n{\n\n    this.indexA = [0, 0, 0];\n    this.indexB = [0, 0, 0]\n};\nBox2D.Collision.b2DistanceInput = function ()\n{\n\n    this.useRadii = !1;\n    this.transformB = this.transformA = this.proxyB = this.proxyA = null\n};\nBox2D.Collision.Shapes = {};\nBox2D.Collision.Shapes.b2Shape = function ()\n{\n\n    this.m_radius = Box2D.Common.b2Settings.b2_linearSlop\n};\nBox2D.Collision.Shapes.b2Shape.prototype.Set = function (a)\n{\n    this.m_radius = a.m_radius\n};\nBox2D.Collision.Shapes.b2Shape.TestOverlap = function (a, b, c, d)\n{\n    var e = new Box2D.Collision.b2DistanceInput;\n    e.proxyA = new Box2D.Collision.b2DistanceProxy;\n    e.proxyA.Set(a);\n    e.proxyB = new Box2D.Collision.b2DistanceProxy;\n    e.proxyB.Set(c);\n    e.transformA = b;\n    e.transformB = d;\n    e.useRadii = !0;\n    a = new Box2D.Collision.b2SimplexCache;\n    a.count = 0;\n    b = new Box2D.Collision.b2DistanceOutput;\n    Box2D.Collision.b2Distance.Distance(b, a, e);\n    Box2D.Common.Math.b2Vec2.Free(b.pointA);\n    Box2D.Common.Math.b2Vec2.Free(b.pointB);\n    return b.distance < 10 * Number.MIN_VALUE\n};\nBox2D.Collision.Shapes.b2Shape.e_startsInsideCollide = -1;\nBox2D.Collision.Shapes.b2Shape.e_missCollide = 0;\nBox2D.Collision.Shapes.b2Shape.e_hitCollide = 1;\nBox2D.Collision.Shapes.b2CircleShape = function (a)\n{\n\n    Box2D.Collision.Shapes.b2Shape.call(this);\n    this.m_radius = a;\n    this.m_radiusSquared = a * a;\n    this.m_p = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_vertices = [this.m_p]\n};\ngoog.inherits(Box2D.Collision.Shapes.b2CircleShape, Box2D.Collision.Shapes.b2Shape);\nBox2D.Collision.Shapes.b2CircleShape.prototype.GetTypeName = function ()\n{\n    return Box2D.Collision.Shapes.b2CircleShape.NAME\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.Copy = function ()\n{\n    var a = new Box2D.Collision.Shapes.b2CircleShape(this.m_radius);\n    a.Set(this);\n    return a\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.Set = function (a)\n{\n    Box2D.Collision.Shapes.b2Shape.prototype.Set.call(this, a);\n    a instanceof Box2D.Collision.Shapes.b2CircleShape && this.m_p.SetV(a.m_p)\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.TestPoint = function (a, b)\n{\n    var c = b.x - (a.position.x + (a.R.col1.x * this.m_p.x + a.R.col2.x * this.m_p.y)), d = b.y - (a.position.y + (a.R.col1.y * this.m_p.x + a.R.col2.y * this.m_p.y));\n    return c * c + d * d <= this.m_radiusSquared\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.RayCast = function (a, b, c)\n{\n    var d = c.R, e = b.p1.x - (c.position.x + (d.col1.x * this.m_p.x + d.col2.x * this.m_p.y)), c = b.p1.y - (c.position.y + (d.col1.y * this.m_p.x + d.col2.y * this.m_p.y)), d = b.p2.x - b.p1.x, f = b.p2.y - b.p1.y, g = e * d + c * f, h = d * d + f * f, i = g * g - h * (e * e + c * c - this.m_radiusSquared);\n    if (0 > i || h < Number.MIN_VALUE)\n    {\n        return!1\n    }\n    g = -(g + Math.sqrt(i));\n    return 0 <= g && g <= b.maxFraction * h ? (g /= h, a.fraction = g, a.normal.x = e + g * d, a.normal.y = c + g * f, a.normal.Normalize(), !0) : !1\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.ComputeAABB = function (a, b)\n{\n    var c = b.R, d = b.position.x + (c.col1.x * this.m_p.x + c.col2.x * this.m_p.y), c = b.position.y + (c.col1.y * this.m_p.x + c.col2.y * this.m_p.y);\n    a.lowerBound.Set(d - this.m_radius, c - this.m_radius);\n    a.upperBound.Set(d + this.m_radius, c + this.m_radius)\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.ComputeMass = function (a, b)\n{\n    var c = b * Math.PI * this.m_radiusSquared;\n    a.SetV(c, this.m_p, c * (0.5 * this.m_radiusSquared + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y)))\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.ComputeSubmergedArea = function (a, b, c, d)\n{\n    var c = Box2D.Common.Math.b2Math.MulX(c, this.m_p), e = -(Box2D.Common.Math.b2Math.Dot(a, c) - b);\n    if (e < -this.m_radius + Number.MIN_VALUE)\n    {\n        return Box2D.Common.Math.b2Vec2.Free(c), 0\n    }\n    if (e > this.m_radius)\n    {\n        return Box2D.Common.Math.b2Vec2.Free(c), d.SetV(c), Math.PI * this.m_radiusSquared\n    }\n    b = e * e;\n    e = this.m_radiusSquared * (Math.asin(e / this.m_radius) + Math.PI / 2) + e * Math.sqrt(this.m_radiusSquared - b);\n    b = -2 / 3 * Math.pow(this.m_radiusSquared - b, 1.5) / e;\n    d.x = c.x + a.x * b;\n    d.y = c.y + a.y * b;\n    Box2D.Common.Math.b2Vec2.Free(c);\n    return e\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.SetDistanceProxy = function (a)\n{\n    a.SetValues(1, this.m_radius, this.m_vertices)\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.GetLocalPosition = function ()\n{\n    return this.m_p\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.SetLocalPosition = function (a)\n{\n    this.m_p.SetV(a)\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.GetRadius = function ()\n{\n    return this.m_radius\n};\nBox2D.Collision.Shapes.b2CircleShape.prototype.SetRadius = function (a)\n{\n    this.m_radius = a;\n    this.m_radiusSquared = a * a\n};\nBox2D.Collision.Shapes.b2CircleShape.NAME = \"b2CircleShape\";\nBox2D.Consts = {};\nBox2D.Consts.MIN_VALUE_SQUARED = Number.MIN_VALUE * Number.MIN_VALUE;\nBox2D.Collision.b2AABB = function ()\n{\n\n    this.lowerBound = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.upperBound = Box2D.Common.Math.b2Vec2.Get(0, 0)\n};\nBox2D.Collision.b2AABB._freeCache = [];\nBox2D.Collision.b2AABB.Get = function ()\n{\n\n    if (0 < Box2D.Collision.b2AABB._freeCache.length)\n    {\n        var a = Box2D.Collision.b2AABB._freeCache.pop();\n        a.SetZero();\n        return a\n    }\n    return new Box2D.Collision.b2AABB\n};\nBox2D.Collision.b2AABB.Free = function (a)\n{\n    null != a && ( Box2D.Collision.b2AABB._freeCache.push(a))\n};\nBox2D.Collision.b2AABB.prototype.SetZero = function ()\n{\n    this.lowerBound.Set(0, 0);\n    this.upperBound.Set(0, 0)\n};\nBox2D.Collision.b2AABB.prototype.IsValid = function ()\n{\n    return 0 > this.upperBound.x - this.lowerBound.x || 0 > this.upperBound.y - this.lowerBound.y ? !1 : this.lowerBound.IsValid() && this.upperBound.IsValid()\n};\nBox2D.Collision.b2AABB.prototype.GetCenter = function ()\n{\n    return Box2D.Common.Math.b2Vec2.Get((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)\n};\nBox2D.Collision.b2AABB.prototype.SetCenter = function (a)\n{\n    var b = this.GetCenter();\n    this.lowerBound.Subtract(b);\n    this.upperBound.Subtract(b);\n    this.lowerBound.Add(a);\n    this.upperBound.Add(a);\n    Box2D.Common.Math.b2Vec2.Free(b)\n};\nBox2D.Collision.b2AABB.prototype.GetExtents = function ()\n{\n    return Box2D.Common.Math.b2Vec2.Get((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)\n};\nBox2D.Collision.b2AABB.prototype.Contains = function (a)\n{\n    var b;\n    return b = (b = (b = (b = this.lowerBound.x <= a.lowerBound.x) && this.lowerBound.y <= a.lowerBound.y) && a.upperBound.x <= this.upperBound.x) && a.upperBound.y <= this.upperBound.y\n};\nBox2D.Collision.b2AABB.prototype.RayCast = function (a, b)\n{\n    var c = -Number.MAX_VALUE, d = Number.MAX_VALUE, e = b.p2.x - b.p1.x;\n    if (Math.abs(e) < Number.MIN_VALUE)\n    {\n        if (b.p1.x < this.lowerBound.x || this.upperBound.x < b.p1.x)\n        {\n            return!1\n        }\n    } else\n    {\n        var f = 1 / e, e = (this.lowerBound.x - b.p1.x) * f, f = (this.upperBound.x - b.p1.x) * f, g = -1;\n        e > f && (g = e, e = f, f = g, g = 1);\n        e > c && (a.normal.x = g, a.normal.y = 0, c = e);\n        d = Math.min(d, f);\n        if (c > d)\n        {\n            return!1\n        }\n    }\n    e = b.p2.y - b.p1.y;\n    if (Math.abs(e) < Number.MIN_VALUE)\n    {\n        if (b.p1.y < this.lowerBound.y || this.upperBound.y < b.p1.y)\n        {\n            return!1\n        }\n    } else\n    {\n        if (f = 1 / e, e = (this.lowerBound.y - b.p1.y) * f, f *= this.upperBound.y - b.p1.y, g = -1, e > f && (g = e, e = f, f = g, g = 1), e > c && (a.normal.y = g, a.normal.x = 0, c = e), d = Math.min(d, f), c > d)\n        {\n            return!1\n        }\n    }\n    a.fraction = c;\n    return!0\n};\nBox2D.Collision.b2AABB.prototype.TestOverlap = function (a)\n{\n    return 0 < a.lowerBound.x - this.upperBound.x || 0 < a.lowerBound.y - this.upperBound.y || 0 < this.lowerBound.x - a.upperBound.x || 0 < this.lowerBound.y - a.upperBound.y ? !1 : !0\n};\nBox2D.Collision.b2AABB.Combine = function (a, b)\n{\n    var c = Box2D.Collision.b2AABB.Get();\n    c.Combine(a, b);\n    return c\n};\nBox2D.Collision.b2AABB.prototype.Combine = function (a, b)\n{\n    this.lowerBound.x = Math.min(a.lowerBound.x, b.lowerBound.x);\n    this.lowerBound.y = Math.min(a.lowerBound.y, b.lowerBound.y);\n    this.upperBound.x = Math.max(a.upperBound.x, b.upperBound.x);\n    this.upperBound.y = Math.max(a.upperBound.y, b.upperBound.y)\n};\nBox2D.Dynamics.b2FixtureListNode = function (a)\n{\n\n    this.fixture = a;\n    this.previous = this.next = null\n};\nBox2D.Dynamics.b2FixtureListNode.prototype.SetNextNode = function (a)\n{\n    this.next = a\n};\nBox2D.Dynamics.b2FixtureListNode.prototype.SetPreviousNode = function (a)\n{\n    this.previous = a\n};\nBox2D.Dynamics.b2FixtureListNode.prototype.GetNextNode = function ()\n{\n    return this.next\n};\nBox2D.Dynamics.b2FixtureListNode.prototype.GetPreviousNode = function ()\n{\n    return this.previous\n};\nBox2D.Collision.b2ContactID = function ()\n{\n\n    this._incidentVertex = this._incidentEdge = this._referenceEdge = this._key = 0\n};\nBox2D.Collision.b2ContactID.prototype.GetKey = function ()\n{\n    return this._key\n};\nBox2D.Collision.b2ContactID.prototype.SetKey = function (a)\n{\n    this._key = a;\n    this._referenceEdge = this._key & 255;\n    this._incidentEdge = (this._key & 65280) >> 8 & 255;\n    this._incidentVertex = (this._key & 16711680) >> 16 & 255;\n    this._flip = (this._key & 4278190080) >> 24 & 255\n};\nBox2D.Collision.b2ContactID.prototype.Set = function (a)\n{\n    this.SetKey(a._key)\n};\nBox2D.Collision.b2ContactID.prototype.SetReferenceEdge = function (a)\n{\n    this._referenceEdge = a;\n    this._key = this._key & 4294967040 | this._referenceEdge & 255\n};\nBox2D.Collision.b2ContactID.prototype.SetIncidentEdge = function (a)\n{\n    this._incidentEdge = a;\n    this._key = this._key & 4294902015 | this._incidentEdge << 8 & 65280\n};\nBox2D.Collision.b2ContactID.prototype.SetIncidentVertex = function (a)\n{\n    this._incidentVertex = a;\n    this._key = this._key & 4278255615 | this._incidentVertex << 16 & 16711680\n};\nBox2D.Collision.b2ContactID.prototype.SetFlip = function (a)\n{\n    this._flip = a;\n    this._key = this._key & 16777215 | this._flip << 24 & 4278190080\n};\nBox2D.Collision.b2ContactID.prototype.Copy = function ()\n{\n    var a = new Box2D.Collision.b2ContactID;\n    a.Set(this);\n    return a\n};\nBox2D.Collision.b2ManifoldPoint = function ()\n{\n\n    this.m_localPoint = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_id = new Box2D.Collision.b2ContactID;\n    this.m_tangentImpulse = this.m_normalImpulse = 0\n};\nBox2D.Collision.b2ManifoldPoint.prototype.Reset = function ()\n{\n    this.m_localPoint.SetZero();\n    this.m_tangentImpulse = this.m_normalImpulse = 0;\n    this.m_id.SetKey(0)\n};\nBox2D.Collision.b2ManifoldPoint.prototype.Set = function (a)\n{\n    this.m_localPoint.SetV(a.m_localPoint);\n    this.m_normalImpulse = a.m_normalImpulse;\n    this.m_tangentImpulse = a.m_tangentImpulse;\n    this.m_id.Set(a.m_id)\n};\nBox2D.Collision.b2DynamicTreeNode = function (a)\n{\n\n    this.aabb = Box2D.Collision.b2AABB.Get();\n    this.parent = this.child2 = this.child1 = null;\n    this.fixture = a\n};\nBox2D.Collision.b2DynamicTreeNode._freeCache = [];\nBox2D.Collision.b2DynamicTreeNode.Get = function (a)\n{\n    \"undefined\" == typeof a && (a = null);\n    if (0 < Box2D.Collision.b2DynamicTreeNode._freeCache.length)\n    {\n        var b = Box2D.Collision.b2DynamicTreeNode._freeCache.pop();\n        b.fixture = a;\n        b.aabb.SetZero();\n        return b\n    }\n    return new Box2D.Collision.b2DynamicTreeNode(a)\n};\nBox2D.Collision.b2DynamicTreeNode.prototype.Destroy = function ()\n{\n    this.fixture = this.parent = this.child2 = this.child1 = null;\n    Box2D.Collision.b2DynamicTreeNode._freeCache.push(this)\n};\nBox2D.Collision.b2DynamicTreeNode.prototype.IsLeaf = function ()\n{\n    return null === this.child1\n};\nBox2D.Collision.b2RayCastInput = function (a, b, c)\n{\n\n    this.p1 = Box2D.Common.Math.b2Vec2.Get(a.x, a.y);\n    this.p2 = Box2D.Common.Math.b2Vec2.Get(b.x, b.y);\n    this.maxFraction = c\n};\nBox2D.Collision.b2DynamicTree = function ()\n{\n\n    this.m_root = null;\n    this.m_insertionCount = this.m_path = 0\n};\nBox2D.Collision.b2DynamicTree.prototype.CreateProxy = function (a, b)\n{\n    var c = Box2D.Collision.b2DynamicTreeNode.Get(b), d = Box2D.Common.b2Settings.b2_aabbExtension, e = Box2D.Common.b2Settings.b2_aabbExtension;\n    c.aabb.lowerBound.x = a.lowerBound.x - d;\n    c.aabb.lowerBound.y = a.lowerBound.y - e;\n    c.aabb.upperBound.x = a.upperBound.x + d;\n    c.aabb.upperBound.y = a.upperBound.y + e;\n    this.InsertLeaf(c);\n    return c\n};\nBox2D.Collision.b2DynamicTree.prototype.DestroyProxy = function (a)\n{\n    this.RemoveLeaf(a);\n    a.Destroy()\n};\nBox2D.Collision.b2DynamicTree.prototype.MoveProxy = function (a, b, c)\n{\n    Box2D.Common.b2Settings.b2Assert(a.IsLeaf());\n    if (a.aabb.Contains(b))\n    {\n        return!1\n    }\n    this.RemoveLeaf(a);\n    var d = Box2D.Common.b2Settings.b2_aabbExtension + Box2D.Common.b2Settings.b2_aabbMultiplier * Math.abs(c.x), c = Box2D.Common.b2Settings.b2_aabbExtension + Box2D.Common.b2Settings.b2_aabbMultiplier * Math.abs(c.y);\n    a.aabb.lowerBound.x = b.lowerBound.x - d;\n    a.aabb.lowerBound.y = b.lowerBound.y - c;\n    a.aabb.upperBound.x = b.upperBound.x + d;\n    a.aabb.upperBound.y = b.upperBound.y + c;\n    this.InsertLeaf(a);\n    return!0\n};\nBox2D.Collision.b2DynamicTree.prototype.Rebalance = function (a)\n{\n    if (null !== this.m_root)\n    {\n        for (var b = 0; b < a; b++)\n        {\n            for (var c = this.m_root, d = 0; !c.IsLeaf();)\n            {\n                c = this.m_path >> d & 1 ? c.child2 : c.child1, d = d + 1 & 31\n            }\n            this.m_path++;\n            this.RemoveLeaf(c);\n            this.InsertLeaf(c)\n        }\n    }\n};\nBox2D.Collision.b2DynamicTree.prototype.GetFatAABB = function (a)\n{\n    return a.aabb\n};\nBox2D.Collision.b2DynamicTree.prototype.Query = function (a, b, c)\n{\n    if (null !== this.m_root)\n    {\n        var d = [];\n        for (d.push(this.m_root); 0 < d.length;)\n        {\n            var e = d.pop();\n            if (e.aabb.TestOverlap(b))\n            {\n                if (e.IsLeaf())\n                {\n                    if (!a.call(c, e.fixture))\n                    {\n                        break\n                    }\n                } else\n                {\n                    d.push(e.child1), d.push(e.child2)\n                }\n            }\n        }\n    }\n};\nBox2D.Collision.b2DynamicTree.prototype.RayCast = function (a, b)\n{\n    if (null !== this.m_root)\n    {\n        var c = Box2D.Common.Math.b2Math.SubtractVV(b.p1, b.p2);\n        c.Normalize();\n        var d = Box2D.Common.Math.b2Math.CrossFV(1, c);\n        Box2D.Common.Math.b2Vec2.Free(c);\n        var c = Box2D.Common.Math.b2Math.AbsV(d), e = b.maxFraction, f = b.p1.x + e * (b.p2.x - b.p1.x), e = b.p1.y + e * (b.p2.y - b.p1.y), g = Box2D.Collision.b2AABB.Get();\n        g.lowerBound.x = Math.min(b.p1.x, f);\n        g.lowerBound.y = Math.min(b.p1.y, e);\n        g.upperBound.x = Math.max(b.p1.x, f);\n        g.upperBound.y = Math.max(b.p1.y, e);\n        var h = [];\n        for (h.push(this.m_root); 0 < h.length;)\n        {\n            if (f = h.pop(), f.aabb.TestOverlap(g))\n            {\n                var e = f.aabb.GetCenter(), i = f.aabb.GetExtents(), j = Math.abs(d.x * (b.p1.x - e.x) + d.y * (b.p1.y - e.y)) - c.x * i.x - c.y * i.y;\n                Box2D.Common.Math.b2Vec2.Free(e);\n                Box2D.Common.Math.b2Vec2.Free(i);\n                if (!(0 < j))\n                {\n                    if (f.IsLeaf())\n                    {\n                        new Box2D.Collision.b2RayCastInput(b.p1, b.p2, b.maxFraction);\n                        e = a(b, f.fixture);\n                        if (0 == e)\n                        {\n                            break\n                        }\n                        0 < e && (f = b.p1.x + e * (b.p2.x - b.p1.x), e = b.p1.y + e * (b.p2.y - b.p1.y), g.lowerBound.x = Math.min(b.p1.x, f), g.lowerBound.y = Math.min(b.p1.y, e), g.upperBound.x = Math.max(b.p1.x, f), g.upperBound.y = Math.max(b.p1.y, e))\n                    } else\n                    {\n                        h.push(f.child1), h.push(f.child2)\n                    }\n                }\n            }\n        }\n        Box2D.Common.Math.b2Vec2.Free(d);\n        Box2D.Common.Math.b2Vec2.Free(c);\n        Box2D.Collision.b2AABB.Free(g)\n    }\n};\nBox2D.Collision.b2DynamicTree.prototype.InsertLeaf = function (a)\n{\n    this.m_insertionCount++;\n    if (null === this.m_root)\n    {\n        this.m_root = a, this.m_root.parent = null\n    } else\n    {\n        var b = this.GetBestSibling(a), c = b.parent, d = Box2D.Collision.b2DynamicTreeNode.Get();\n        d.parent = c;\n        d.aabb.Combine(a.aabb, b.aabb);\n        if (c)\n        {\n            b.parent.child1 == b ? c.child1 = d : c.child2 = d;\n            d.child1 = b;\n            d.child2 = a;\n            b.parent = d;\n            for (a.parent = d; c && !c.aabb.Contains(d.aabb);)\n            {\n                c.aabb.Combine(c.child1.aabb, c.child2.aabb), d = c, c = c.parent\n            }\n        } else\n        {\n            d.child1 = b, d.child2 = a, b.parent = d, this.m_root = a.parent = d\n        }\n    }\n};\nBox2D.Collision.b2DynamicTree.prototype.GetBestSibling = function (a)\n{\n    for (var a = a.aabb.GetCenter(), b = this.m_root; !b.IsLeaf();)\n    {\n        var c = b.child1, b = b.child2, d = Math.abs((c.aabb.lowerBound.x + c.aabb.upperBound.x) / 2 - a.x) + Math.abs((c.aabb.lowerBound.y + c.aabb.upperBound.y) / 2 - a.y), e = Math.abs((b.aabb.lowerBound.x + b.aabb.upperBound.x) / 2 - a.x) + Math.abs((b.aabb.lowerBound.y + b.aabb.upperBound.y) / 2 - a.y), b = d < e ? c : b\n    }\n    Box2D.Common.Math.b2Vec2.Free(a);\n    return b\n};\nBox2D.Collision.b2DynamicTree.prototype.RemoveLeaf = function (a)\n{\n    if (a == this.m_root)\n    {\n        this.m_root = null\n    } else\n    {\n        var b = a.parent, c = b.parent, a = b.child1 == a ? b.child2 : b.child1;\n        if (c)\n        {\n            c.child1 == b ? c.child1 = a : c.child2 = a;\n            for (a.parent = c; c;)\n            {\n                a = c.aabb;\n                c.aabb.Combine(c.child1.aabb, c.child2.aabb);\n                if (a.Contains(c.aabb))\n                {\n                    break\n                }\n                c = c.parent\n            }\n        } else\n        {\n            this.m_root = a, a.parent = null\n        }\n        b.Destroy()\n    }\n};\nBox2D.Collision.ClipVertex = function ()\n{\n\n    this.v = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.id = new Box2D.Collision.b2ContactID\n};\nBox2D.Collision.ClipVertex.prototype.Set = function (a)\n{\n    this.v.SetV(a.v);\n    this.id.Set(a.id)\n};\nBox2D.Collision.b2Manifold = function ()\n{\n\n    this.m_type = this.m_pointCount = 0;\n    this.m_points = [];\n    for (var a = 0; a < Box2D.Common.b2Settings.b2_maxManifoldPoints; a++)\n    {\n        this.m_points[a] = new Box2D.Collision.b2ManifoldPoint\n    }\n    this.m_localPlaneNormal = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localPoint = Box2D.Common.Math.b2Vec2.Get(0, 0)\n};\nBox2D.Collision.b2Manifold.prototype.Reset = function ()\n{\n    for (var a = 0; a < Box2D.Common.b2Settings.b2_maxManifoldPoints; a++)\n    {\n        this.m_points[a].Reset()\n    }\n    this.m_localPlaneNormal.SetZero();\n    this.m_localPoint.SetZero();\n    this.m_pointCount = this.m_type = 0\n};\nBox2D.Collision.b2Manifold.prototype.Set = function (a)\n{\n    this.m_pointCount = a.m_pointCount;\n    for (var b = 0; b < Box2D.Common.b2Settings.b2_maxManifoldPoints; b++)\n    {\n        this.m_points[b].Set(a.m_points[b])\n    }\n    this.m_localPlaneNormal.SetV(a.m_localPlaneNormal);\n    this.m_localPoint.SetV(a.m_localPoint);\n    this.m_type = a.m_type\n};\nBox2D.Collision.b2Manifold.prototype.Copy = function ()\n{\n    var a = new Box2D.Collision.b2Manifold;\n    a.Set(this);\n    return a\n};\nBox2D.Collision.b2Manifold.e_circles = 1;\nBox2D.Collision.b2Manifold.e_faceA = 2;\nBox2D.Collision.b2Manifold.e_faceB = 4;\nBox2D.Collision.b2Collision = {};\nBox2D.Collision.b2Collision.ClipSegmentToLine = function (a, b, c, d)\n{\n    var e = 0, f = b[0].v, g = b[1].v, h = c.x * f.x + c.y * f.y - d, c = c.x * g.x + c.y * g.y - d;\n    0 >= h && a[e++].Set(b[0]);\n    0 >= c && a[e++].Set(b[1]);\n    0 > h * c && (c = h / (h - c), d = a[e].v, d.x = f.x + c * (g.x - f.x), d.y = f.y + c * (g.y - f.y), a[e].id = 0 < h ? b[0].id : b[1].id, e++);\n    return e\n};\nBox2D.Collision.b2Collision.EdgeSeparation = function (a, b, c, d, e)\n{\n    for (var f = b.R.col1.x * a.m_normals[c].x + b.R.col2.x * a.m_normals[c].y, g = b.R.col1.y * a.m_normals[c].x + b.R.col2.y * a.m_normals[c].y, h = e.R.col1.x * f + e.R.col1.y * g, i = e.R.col2.x * f + e.R.col2.y * g, j = 0, k = Number.MAX_VALUE, l = 0; l < d.m_vertexCount; l++)\n    {\n        var n = d.m_vertices[l].x * h + d.m_vertices[l].y * i;\n        n < k && (k = n, j = l)\n    }\n    return(e.position.x + (e.R.col1.x * d.m_vertices[j].x + e.R.col2.x * d.m_vertices[j].y) - (b.position.x + (b.R.col1.x * a.m_vertices[c].x + b.R.col2.x * a.m_vertices[c].y))) * f + (e.position.y + (e.R.col1.y * d.m_vertices[j].x + e.R.col2.y * d.m_vertices[j].y) - (b.position.y + (b.R.col1.y * a.m_vertices[c].x + b.R.col2.y * a.m_vertices[c].y))) * g\n};\nBox2D.Collision.b2Collision.FindMaxSeparation = function (a, b, c, d)\n{\n    for (var e = d.position.x + (d.R.col1.x * c.m_centroid.x + d.R.col2.x * c.m_centroid.y), f = d.position.y + (d.R.col1.y * c.m_centroid.x + d.R.col2.y * c.m_centroid.y), e = e - (b.position.x + (b.R.col1.x * a.m_centroid.x + b.R.col2.x * a.m_centroid.y)), f = f - (b.position.y + (b.R.col1.y * a.m_centroid.x + b.R.col2.y * a.m_centroid.y)), g = e * b.R.col1.x + f * b.R.col1.y, f = e * b.R.col2.x + f * b.R.col2.y, e = 0, h = -Number.MAX_VALUE, i = 0; i < a.m_vertexCount; ++i)\n    {\n        var j = a.m_normals[i].x * g + a.m_normals[i].y * f;\n        j > h && (h = j, e = i)\n    }\n    g = Box2D.Collision.b2Collision.EdgeSeparation(a, b, e, c, d);\n    f = e - 1;\n    0 > f && (f = a.m_vertexCount - 1);\n    h = Box2D.Collision.b2Collision.EdgeSeparation(a, b, f, c, d);\n    i = e + 1;\n    i >= a.m_vertexCount && (i = 0);\n    var j = Box2D.Collision.b2Collision.EdgeSeparation(a, b, i, c, d), k = 0, l = 0;\n    if (h > g && h > j)\n    {\n        k = f;\n        for (l = h; ;)\n        {\n            if (e = k - 1, 0 > e && (e = a.m_vertexCount - 1), g = Box2D.Collision.b2Collision.EdgeSeparation(a, b, e, c, d), g > l)\n            {\n                k = e, l = g\n            } else\n            {\n                break\n            }\n        }\n    } else\n    {\n        if (j > g)\n        {\n            k = i;\n            for (l = j; ;)\n            {\n                if (e = k + 1, e >= a.m_vertexCount && (e = 0), g = Box2D.Collision.b2Collision.EdgeSeparation(a, b, e, c, d), g > l)\n                {\n                    k = e, l = g\n                } else\n                {\n                    break\n                }\n            }\n        } else\n        {\n            k = e, l = g\n        }\n    }\n    return{bestEdge:k, separation:l}\n};\nBox2D.Collision.b2Collision.FindIncidentEdge = function (a, b, c, d, e, f)\n{\n    for (var g = c.R.col1.x * b.m_normals[d].x + c.R.col2.x * b.m_normals[d].y, b = c.R.col1.y * b.m_normals[d].x + c.R.col2.y * b.m_normals[d].y, c = f.R.col1.x * g + f.R.col1.y * b, b = f.R.col2.x * g + f.R.col2.y * b, g = c, c = 0, h = Number.MAX_VALUE, i = 0; i < e.m_vertexCount; i++)\n    {\n        var j = g * e.m_normals[i].x + b * e.m_normals[i].y;\n        j < h && (h = j, c = i)\n    }\n    g = c + 1;\n    g >= e.m_vertexCount && (g = 0);\n    a[0].v.x = f.position.x + (f.R.col1.x * e.m_vertices[c].x + f.R.col2.x * e.m_vertices[c].y);\n    a[0].v.y = f.position.y + (f.R.col1.y * e.m_vertices[c].x + f.R.col2.y * e.m_vertices[c].y);\n    a[0].id.SetReferenceEdge(d);\n    a[0].id.SetIncidentEdge(c);\n    a[0].id.SetIncidentVertex(0);\n    a[1].v.x = f.position.x + (f.R.col1.x * e.m_vertices[g].x + f.R.col2.x * e.m_vertices[g].y);\n    a[1].v.y = f.position.y + (f.R.col1.y * e.m_vertices[g].x + f.R.col2.y * e.m_vertices[g].y);\n    a[1].id.SetReferenceEdge(d);\n    a[1].id.SetIncidentEdge(g);\n    a[1].id.SetIncidentVertex(1)\n};\nBox2D.Collision.b2Collision.MakeClipPointVector = function ()\n{\n    return[new Box2D.Collision.ClipVertex, new Box2D.Collision.ClipVertex]\n};\nBox2D.Collision.b2Collision.CollidePolygons = function (a, b, c, d, e)\n{\n    a.m_pointCount = 0;\n    var f = b.m_radius + d.m_radius, g = Box2D.Collision.b2Collision.FindMaxSeparation(b, c, d, e);\n    if (!(g.separation > f))\n    {\n        var h = Box2D.Collision.b2Collision.FindMaxSeparation(d, e, b, c);\n        if (!(h.separation > f))\n        {\n            var i = b, j = d, k = c, l = e, n = 0, m = g.bestEdge;\n            a.m_type = Box2D.Collision.b2Manifold.e_faceA;\n            h.separation > 0.98 * g.separation + 0.0010 && (i = d, j = b, k = e, l = c, m = h.bestEdge, a.m_type = Box2D.Collision.b2Manifold.e_faceB, n = 1);\n            b = Box2D.Collision.b2Collision.s_incidentEdge;\n            Box2D.Collision.b2Collision.FindIncidentEdge(b, i, k, m, j, l);\n            j = i.m_vertices[m];\n            i = m + 1 < i.m_vertexCount ? i.m_vertices[m + 1] : i.m_vertices[0];\n            Box2D.Collision.b2Collision.s_localTangent.Set(i.x - j.x, i.y - j.y);\n            Box2D.Collision.b2Collision.s_localTangent.Normalize();\n            Box2D.Collision.b2Collision.s_localNormal.x = Box2D.Collision.b2Collision.s_localTangent.y;\n            Box2D.Collision.b2Collision.s_localNormal.y = -Box2D.Collision.b2Collision.s_localTangent.x;\n            Box2D.Collision.b2Collision.s_planePoint.Set(0.5 * (j.x + i.x), 0.5 * (j.y + i.y));\n            Box2D.Collision.b2Collision.s_tangent.x = k.R.col1.x * Box2D.Collision.b2Collision.s_localTangent.x + k.R.col2.x * Box2D.Collision.b2Collision.s_localTangent.y;\n            Box2D.Collision.b2Collision.s_tangent.y = k.R.col1.y * Box2D.Collision.b2Collision.s_localTangent.x + k.R.col2.y * Box2D.Collision.b2Collision.s_localTangent.y;\n            Box2D.Collision.b2Collision.s_tangent2.x = -Box2D.Collision.b2Collision.s_tangent.x;\n            Box2D.Collision.b2Collision.s_tangent2.y = -Box2D.Collision.b2Collision.s_tangent.y;\n            Box2D.Collision.b2Collision.s_normal.x = Box2D.Collision.b2Collision.s_tangent.y;\n            Box2D.Collision.b2Collision.s_normal.y = -Box2D.Collision.b2Collision.s_tangent.x;\n            Box2D.Collision.b2Collision.s_v11.x = k.position.x + (k.R.col1.x * j.x + k.R.col2.x * j.y);\n            Box2D.Collision.b2Collision.s_v11.y = k.position.y + (k.R.col1.y * j.x + k.R.col2.y * j.y);\n            Box2D.Collision.b2Collision.s_v12.x = k.position.x + (k.R.col1.x * i.x + k.R.col2.x * i.y);\n            Box2D.Collision.b2Collision.s_v12.y = k.position.y + (k.R.col1.y * i.x + k.R.col2.y * i.y);\n            if (!(2 > Box2D.Collision.b2Collision.ClipSegmentToLine(Box2D.Collision.b2Collision.s_clipPoints1, b, Box2D.Collision.b2Collision.s_tangent2, -Box2D.Collision.b2Collision.s_tangent.x * Box2D.Collision.b2Collision.s_v11.x - Box2D.Collision.b2Collision.s_tangent.y * Box2D.Collision.b2Collision.s_v11.y + f)) && !(2 > Box2D.Collision.b2Collision.ClipSegmentToLine(Box2D.Collision.b2Collision.s_clipPoints2, Box2D.Collision.b2Collision.s_clipPoints1, Box2D.Collision.b2Collision.s_tangent, Box2D.Collision.b2Collision.s_tangent.x *\n                Box2D.Collision.b2Collision.s_v12.x + Box2D.Collision.b2Collision.s_tangent.y * Box2D.Collision.b2Collision.s_v12.y + f)))\n            {\n                a.m_localPlaneNormal.SetV(Box2D.Collision.b2Collision.s_localNormal);\n                a.m_localPoint.SetV(Box2D.Collision.b2Collision.s_planePoint);\n                k = Box2D.Collision.b2Collision.s_normal.x * Box2D.Collision.b2Collision.s_v11.x + Box2D.Collision.b2Collision.s_normal.y * Box2D.Collision.b2Collision.s_v11.y;\n                for (m = i = 0; m < Box2D.Common.b2Settings.b2_maxManifoldPoints; ++m)\n                {\n                    Box2D.Collision.b2Collision.s_normal.x * Box2D.Collision.b2Collision.s_clipPoints2[m].v.x + Box2D.Collision.b2Collision.s_normal.y * Box2D.Collision.b2Collision.s_clipPoints2[m].v.y - k <= f && (j = Box2D.Collision.b2Collision.s_clipPoints2[m].v.x - l.position.x, b = Box2D.Collision.b2Collision.s_clipPoints2[m].v.y - l.position.y, a.m_points[i].m_localPoint.x = j * l.R.col1.x + b * l.R.col1.y, a.m_points[i].m_localPoint.y = j * l.R.col2.x + b * l.R.col2.y, a.m_points[i].m_id.Set(Box2D.Collision.b2Collision.s_clipPoints2[m].id),\n                        a.m_points[i].m_id.SetFlip(n), i++)\n                }\n                a.m_pointCount = i\n            }\n        }\n    }\n};\nBox2D.Collision.b2Collision.CollideCircles = function (a, b, c, d, e)\n{\n    a.m_pointCount = 0;\n    var f = e.position.x + (e.R.col1.x * d.m_p.x + e.R.col2.x * d.m_p.y) - (c.position.x + (c.R.col1.x * b.m_p.x + c.R.col2.x * b.m_p.y)), c = e.position.y + (e.R.col1.y * d.m_p.x + e.R.col2.y * d.m_p.y) - (c.position.y + (c.R.col1.y * b.m_p.x + c.R.col2.y * b.m_p.y)), e = b.m_radius + d.m_radius;\n    f * f + c * c > e * e || (a.m_type = Box2D.Collision.b2Manifold.e_circles, a.m_localPoint.SetV(b.m_p), a.m_localPlaneNormal.SetZero(), a.m_pointCount = 1, a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.SetKey(0))\n};\nBox2D.Collision.b2Collision.CollidePolygonAndCircle = function (a, b, c, d, e)\n{\n    a.m_pointCount = 0;\n    for (var f = e.position.x + (e.R.col1.x * d.m_p.x + e.R.col2.x * d.m_p.y) - c.position.x, g = e.position.y + (e.R.col1.y * d.m_p.x + e.R.col2.y * d.m_p.y) - c.position.y, e = f * c.R.col1.x + g * c.R.col1.y, c = f * c.R.col2.x + g * c.R.col2.y, f = 0, g = -Number.MAX_VALUE, h = b.m_radius + d.m_radius, i = 0; i < b.m_vertexCount; ++i)\n    {\n        var j = b.m_normals[i].x * (e - b.m_vertices[i].x) + b.m_normals[i].y * (c - b.m_vertices[i].y);\n        if (j > h)\n        {\n            return\n        }\n        j > g && (g = j, f = i)\n    }\n    j = f + 1;\n    j >= b.m_vertexCount && (j = 0);\n    var i = b.m_vertices[f], k = b.m_vertices[j];\n    g < Number.MIN_VALUE ? (a.m_pointCount = 1, a.m_type = Box2D.Collision.b2Manifold.e_faceA, a.m_localPlaneNormal.SetV(b.m_normals[f]), a.m_localPoint.x = 0.5 * (i.x + k.x), a.m_localPoint.y = 0.5 * (i.y + k.y), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.SetKey(0)) : 0 >= (e - i.x) * (k.x - i.x) + (c - i.y) * (k.y - i.y) ? (e - i.x) * (e - i.x) + (c - i.y) * (c - i.y) > h * h || (a.m_pointCount = 1, a.m_type = Box2D.Collision.b2Manifold.e_faceA, a.m_localPlaneNormal.x = e - i.x, a.m_localPlaneNormal.y =\n        c - i.y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.SetV(i), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.SetKey(0)) : 0 >= (e - k.x) * (i.x - k.x) + (c - k.y) * (i.y - k.y) ? (e - k.x) * (e - k.x) + (c - k.y) * (c - k.y) > h * h || (a.m_pointCount = 1, a.m_type = Box2D.Collision.b2Manifold.e_faceA, a.m_localPlaneNormal.x = e - k.x, a.m_localPlaneNormal.y = c - k.y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.SetV(k), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.SetKey(0)) :\n        (j = 0.5 * (i.x + k.x), i = 0.5 * (i.y + k.y), g = (e - j) * b.m_normals[f].x + (c - i) * b.m_normals[f].y, g > h || (a.m_pointCount = 1, a.m_type = Box2D.Collision.b2Manifold.e_faceA, a.m_localPlaneNormal.x = b.m_normals[f].x, a.m_localPlaneNormal.y = b.m_normals[f].y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.Set(j, i), a.m_points[0].m_localPoint.SetV(d.m_p), a.m_points[0].m_id.SetKey(0)))\n};\nBox2D.Collision.b2Collision.s_incidentEdge = Box2D.Collision.b2Collision.MakeClipPointVector();\nBox2D.Collision.b2Collision.s_clipPoints1 = Box2D.Collision.b2Collision.MakeClipPointVector();\nBox2D.Collision.b2Collision.s_clipPoints2 = Box2D.Collision.b2Collision.MakeClipPointVector();\nBox2D.Collision.b2Collision.s_localTangent = Box2D.Common.Math.b2Vec2.Get(0, 0);\nBox2D.Collision.b2Collision.s_localNormal = Box2D.Common.Math.b2Vec2.Get(0, 0);\nBox2D.Collision.b2Collision.s_planePoint = Box2D.Common.Math.b2Vec2.Get(0, 0);\nBox2D.Collision.b2Collision.s_normal = Box2D.Common.Math.b2Vec2.Get(0, 0);\nBox2D.Collision.b2Collision.s_tangent = Box2D.Common.Math.b2Vec2.Get(0, 0);\nBox2D.Collision.b2Collision.s_tangent2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\nBox2D.Collision.b2Collision.s_v11 = Box2D.Common.Math.b2Vec2.Get(0, 0);\nBox2D.Collision.b2Collision.s_v12 = Box2D.Common.Math.b2Vec2.Get(0, 0);\nBox2D.Collision.b2SeparationFunction = function ()\n{\n\n    this.m_localPoint = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_axis = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_proxyB = this.m_proxyA = null\n};\nBox2D.Collision.b2SeparationFunction.prototype.Initialize = function (a, b, c, d, e)\n{\n    this.m_proxyA = b;\n    this.m_proxyB = d;\n    var f = a.count;\n    Box2D.Common.b2Settings.b2Assert(0 < f && 3 > f);\n    var g, h, i = h = g = 0, j = 0, d = b = 0, k, l, i = 0;\n    1 == f ? (this.m_type = Box2D.Collision.b2SeparationFunction.e_points, f = this.m_proxyA.GetVertex(a.indexA[0]), a = this.m_proxyB.GetVertex(a.indexB[0]), l = f, k = c.R, g = c.position.x + (k.col1.x * l.x + k.col2.x * l.y), h = c.position.y + (k.col1.y * l.x + k.col2.y * l.y), l = a, k = e.R, i = e.position.x + (k.col1.x * l.x + k.col2.x * l.y), j = e.position.y + (k.col1.y * l.x + k.col2.y * l.y), this.m_axis.x = i - g, this.m_axis.y = j - h, this.m_axis.Normalize()) : a.indexB[0] == a.indexB[1] ?\n        (this.m_type = Box2D.Collision.b2SeparationFunction.e_faceA, b = this.m_proxyA.GetVertex(a.indexA[0]), d = this.m_proxyA.GetVertex(a.indexA[1]), a = this.m_proxyB.GetVertex(a.indexB[0]), this.m_localPoint.x = 0.5 * (b.x + d.x), this.m_localPoint.y = 0.5 * (b.y + d.y), j = Box2D.Common.Math.b2Math.SubtractVV(d, b), Box2D.Common.Math.b2Vec2.Free(this.m_axis), this.m_axis = Box2D.Common.Math.b2Math.CrossVF(j, 1), Box2D.Common.Math.b2Vec2.Free(j), this.m_axis.Normalize(), l = this.m_axis, k = c.R,\n            b = k.col1.x * l.x + k.col2.x * l.y, d = k.col1.y * l.x + k.col2.y * l.y, l = this.m_localPoint, k = c.R, g = c.position.x + (k.col1.x * l.x + k.col2.x * l.y), h = c.position.y + (k.col1.y * l.x + k.col2.y * l.y), l = a, k = e.R, i = e.position.x + (k.col1.x * l.x + k.col2.x * l.y), j = e.position.y + (k.col1.y * l.x + k.col2.y * l.y), 0 > (i - g) * b + (j - h) * d && this.m_axis.NegativeSelf()) : a.indexA[0] == a.indexA[0] ? (this.m_type = Box2D.Collision.b2SeparationFunction.e_faceB, g = this.m_proxyB.GetVertex(a.indexB[0]),\n        h = this.m_proxyB.GetVertex(a.indexB[1]), f = this.m_proxyA.GetVertex(a.indexA[0]), this.m_localPoint.x = 0.5 * (g.x + h.x), this.m_localPoint.y = 0.5 * (g.y + h.y), j = Box2D.Common.Math.b2Math.SubtractVV(h, g), Box2D.Common.Math.b2Vec2.Free(this.m_axis), this.m_axis = Box2D.Common.Math.b2Math.CrossVF(j, 1), Box2D.Common.Math.b2Vec2.Free(j), this.m_axis.Normalize(), l = this.m_axis, k = e.R, b = k.col1.x * l.x + k.col2.x * l.y, d = k.col1.y * l.x + k.col2.y * l.y, l = this.m_localPoint, k = e.R,\n        i = e.position.x + (k.col1.x * l.x + k.col2.x * l.y), j = e.position.y + (k.col1.y * l.x + k.col2.y * l.y), l = f, k = c.R, g = c.position.x + (k.col1.x * l.x + k.col2.x * l.y), h = c.position.y + (k.col1.y * l.x + k.col2.y * l.y), 0 > (g - i) * b + (h - j) * d && this.m_axis.NegativeSelf()) : (b = this.m_proxyA.GetVertex(a.indexA[0]), d = this.m_proxyA.GetVertex(a.indexA[1]), g = this.m_proxyB.GetVertex(a.indexB[0]), h = this.m_proxyB.GetVertex(a.indexB[1]), j = Box2D.Common.Math.b2Math.SubtractVV(d,\n        b), i = Box2D.Common.Math.b2Math.MulMV(c.R, j), Box2D.Common.Math.b2Vec2.Free(j), j = Box2D.Common.Math.b2Math.SubtractVV(h, g), k = Box2D.Common.Math.b2Math.MulMV(e.R, j), Box2D.Common.Math.b2Vec2.Free(j), e = i.x * i.x + i.y * i.y, c = k.x * k.x + k.y * k.y, j = Box2D.Common.Math.b2Math.SubtractVV(k, i), a = i.x * j.x + i.y * j.y, f = k.x * j.x + k.y * j.y, Box2D.Common.Math.b2Vec2.Free(j), j = i.x * k.x + i.y * k.y, k = e * c - j * j, i = 0, 0 != k && (i = Box2D.Common.Math.b2Math.Clamp((j *\n        f - a * c) / k, 0, 1)), 0 > (j * i + f) / c && (i = Box2D.Common.Math.b2Math.Clamp((j - a) / e, 0, 1)), f = Box2D.Common.Math.b2Vec2.Get(0, 0), f.x = b.x + i * (d.x - b.x), f.y = b.y + i * (d.y - b.y), a = Box2D.Common.Math.b2Vec2.Get(0, 0), a.x = g.x + i * (h.x - g.x), a.y = g.y + i * (h.y - g.y), 0 == i || 1 == i ? (this.m_type = Box2D.Collision.b2SeparationFunction.e_faceB, j = Box2D.Common.Math.b2Math.SubtractVV(h, g), Box2D.Common.Math.b2Vec2.Free(this.m_axis), this.m_axis = Box2D.Common.Math.b2Math.CrossVF(j,\n        1), Box2D.Common.Math.b2Vec2.Free(j), this.m_axis.Normalize(), this.m_localPoint = a) : (this.m_type = Box2D.Collision.b2SeparationFunction.e_faceA, j = Box2D.Common.Math.b2Math.SubtractVV(d, b), Box2D.Common.Math.b2Vec2.Free(this.m_axis), this.m_axis = Box2D.Common.Math.b2Math.CrossVF(j, 1), Box2D.Common.Math.b2Vec2.Free(j), this.m_localPoint = f), 0 > i && this.m_axis.NegativeSelf(), Box2D.Common.Math.b2Vec2.Free(f), Box2D.Common.Math.b2Vec2.Free(a))\n};\nBox2D.Collision.b2SeparationFunction.prototype.Evaluate = function (a, b)\n{\n    var c = 0;\n    switch (this.m_type)\n    {\n        case Box2D.Collision.b2SeparationFunction.e_points:\n            var c = Box2D.Common.Math.b2Math.MulTMV(a.R, this.m_axis), d = this.m_axis.GetNegative(), e = Box2D.Common.Math.b2Math.MulTMV(b.R, d);\n            Box2D.Common.Math.b2Vec2.Free(d);\n            var f = this.m_proxyA.GetSupportVertex(c);\n            Box2D.Common.Math.b2Vec2.Free(c);\n            c = this.m_proxyB.GetSupportVertex(e);\n            Box2D.Common.Math.b2Vec2.Free(e);\n            e = Box2D.Common.Math.b2Math.MulX(a, f);\n            f = Box2D.Common.Math.b2Math.MulX(b, c);\n            c = (f.x - e.x) * this.m_axis.x + (f.y - e.y) * this.m_axis.y;\n            Box2D.Common.Math.b2Vec2.Free(e);\n            Box2D.Common.Math.b2Vec2.Free(f);\n            break;\n        case Box2D.Collision.b2SeparationFunction.e_faceA:\n            d = Box2D.Common.Math.b2Math.MulMV(a.R, this.m_axis);\n            f = d.GetNegative();\n            e = Box2D.Common.Math.b2Math.MulTMV(b.R, f);\n            Box2D.Common.Math.b2Vec2.Free(f);\n            c = this.m_proxyB.GetSupportVertex(e);\n            Box2D.Common.Math.b2Vec2.Free(e);\n            e = Box2D.Common.Math.b2Math.MulX(a, this.m_localPoint);\n            f = Box2D.Common.Math.b2Math.MulX(b, c);\n            c = (f.x - e.x) * d.x + (f.y - e.y) * d.y;\n            Box2D.Common.Math.b2Vec2.Free(d);\n            Box2D.Common.Math.b2Vec2.Free(e);\n            Box2D.Common.Math.b2Vec2.Free(f);\n            break;\n        case Box2D.Collision.b2SeparationFunction.e_faceB:\n            d = Box2D.Common.Math.b2Math.MulMV(b.R, this.m_axis);\n            f = d.GetNegative();\n            c = Box2D.Common.Math.b2Math.MulTMV(a.R, f);\n            Box2D.Common.Math.b2Vec2.Free(f);\n            f = this.m_proxyA.GetSupportVertex(c);\n            Box2D.Common.Math.b2Vec2.Free(c);\n            e = Box2D.Common.Math.b2Math.MulX(a, f);\n            f = Box2D.Common.Math.b2Math.MulX(b, this.m_localPoint);\n            c = (e.x - f.x) * d.x + (e.y - f.y) * d.y;\n            Box2D.Common.Math.b2Vec2.Free(d);\n            Box2D.Common.Math.b2Vec2.Free(e);\n            Box2D.Common.Math.b2Vec2.Free(f);\n            break;\n        default:\n            Box2D.Common.b2Settings.b2Assert(!1)\n    }\n    return c\n};\nBox2D.Collision.b2SeparationFunction.e_points = 1;\nBox2D.Collision.b2SeparationFunction.e_faceA = 2;\nBox2D.Collision.b2SeparationFunction.e_faceB = 4;\nBox2D.Common.Math.b2Transform = function (a, b)\n{\n\n    this.position = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.R = new Box2D.Common.Math.b2Mat22;\n    a && this.position.SetV(a);\n    b && this.R.SetM(b)\n};\nBox2D.Common.Math.b2Transform.prototype.Initialize = function (a, b)\n{\n    this.position.SetV(a);\n    this.R.SetM(b)\n};\nBox2D.Common.Math.b2Transform.prototype.SetIdentity = function ()\n{\n    this.position.SetZero();\n    this.R.SetIdentity()\n};\nBox2D.Common.Math.b2Transform.prototype.Set = function (a)\n{\n    this.position.SetV(a.position);\n    this.R.SetM(a.R)\n};\nBox2D.Common.Math.b2Transform.prototype.GetAngle = function ()\n{\n    return Math.atan2(this.R.col1.y, this.R.col1.x)\n};\nBox2D.Collision.b2TimeOfImpact = {};\nBox2D.Collision.b2TimeOfImpact.TimeOfImpact = function (a)\n{\n    Box2D.Collision.b2TimeOfImpact.b2_toiCalls++;\n    var b = a.proxyA, c = a.proxyB, d = a.sweepA, e = a.sweepB;\n    Box2D.Common.b2Settings.b2Assert(d.t0 == e.t0);\n    Box2D.Common.b2Settings.b2Assert(1 - d.t0 > Number.MIN_VALUE);\n    var f = b.m_radius + c.m_radius, a = a.tolerance, g = 0, h = 0, i = 0;\n    Box2D.Collision.b2TimeOfImpact.s_cache.count = 0;\n    for (Box2D.Collision.b2TimeOfImpact.s_distanceInput.useRadii = !1; ;)\n    {\n        d.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfA, g);\n        e.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfB, g);\n        Box2D.Collision.b2TimeOfImpact.s_distanceInput.proxyA = b;\n        Box2D.Collision.b2TimeOfImpact.s_distanceInput.proxyB = c;\n        Box2D.Collision.b2TimeOfImpact.s_distanceInput.transformA = Box2D.Collision.b2TimeOfImpact.s_xfA;\n        Box2D.Collision.b2TimeOfImpact.s_distanceInput.transformB = Box2D.Collision.b2TimeOfImpact.s_xfB;\n        Box2D.Collision.b2Distance.Distance(Box2D.Collision.b2TimeOfImpact.s_distanceOutput, Box2D.Collision.b2TimeOfImpact.s_cache, Box2D.Collision.b2TimeOfImpact.s_distanceInput);\n        if (0 >= Box2D.Collision.b2TimeOfImpact.s_distanceOutput.distance)\n        {\n            g = 1;\n            break\n        }\n        Box2D.Collision.b2TimeOfImpact.s_fcn.Initialize(Box2D.Collision.b2TimeOfImpact.s_cache, b, Box2D.Collision.b2TimeOfImpact.s_xfA, c, Box2D.Collision.b2TimeOfImpact.s_xfB);\n        var j = Box2D.Collision.b2TimeOfImpact.s_fcn.Evaluate(Box2D.Collision.b2TimeOfImpact.s_xfA, Box2D.Collision.b2TimeOfImpact.s_xfB);\n        if (0 >= j)\n        {\n            g = 1;\n            break\n        }\n        0 == h && (i = j > f ? Math.max(f - a, 0.75 * f) : Math.max(j - a, 0.02 * f));\n        if (j - i < 0.5 * a)\n        {\n            if (0 == h)\n            {\n                g = 1;\n                break\n            }\n            break\n        }\n        var k = g, l = g, n = 1;\n        d.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfA, n);\n        e.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfB, n);\n        var m = Box2D.Collision.b2TimeOfImpact.s_fcn.Evaluate(Box2D.Collision.b2TimeOfImpact.s_xfA, Box2D.Collision.b2TimeOfImpact.s_xfB);\n        if (m >= i)\n        {\n            g = 1;\n            break\n        }\n        for (var o = 0; ;)\n        {\n            var p = 0, p = o & 1 ? l + (i - j) * (n - l) / (m - j) : 0.5 * (l + n);\n            d.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfA, p);\n            e.GetTransform(Box2D.Collision.b2TimeOfImpact.s_xfB, p);\n            var q = Box2D.Collision.b2TimeOfImpact.s_fcn.Evaluate(Box2D.Collision.b2TimeOfImpact.s_xfA, Box2D.Collision.b2TimeOfImpact.s_xfB);\n            if (Math.abs(q - i) < 0.025 * a)\n            {\n                k = p;\n                break\n            }\n            q > i ? (l = p, j = q) : (n = p, m = q);\n            o++;\n            Box2D.Collision.b2TimeOfImpact.b2_toiRootIters++;\n            if (50 == o)\n            {\n                break\n            }\n        }\n        Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = Math.max(Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters, o);\n        if (k < (1 + 100 * Number.MIN_VALUE) * g)\n        {\n            break\n        }\n        g = k;\n        h++;\n        Box2D.Collision.b2TimeOfImpact.b2_toiIters++;\n        if (1E3 == h)\n        {\n            break\n        }\n    }\n    Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = Math.max(Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters, h);\n    return g\n};\nBox2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;\nBox2D.Collision.b2TimeOfImpact.b2_toiIters = 0;\nBox2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;\nBox2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;\nBox2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;\nBox2D.Collision.b2TimeOfImpact.s_cache = new Box2D.Collision.b2SimplexCache;\nBox2D.Collision.b2TimeOfImpact.s_distanceInput = new Box2D.Collision.b2DistanceInput;\nBox2D.Collision.b2TimeOfImpact.s_xfA = new Box2D.Common.Math.b2Transform;\nBox2D.Collision.b2TimeOfImpact.s_xfB = new Box2D.Common.Math.b2Transform;\nBox2D.Collision.b2TimeOfImpact.s_fcn = new Box2D.Collision.b2SeparationFunction;\nBox2D.Collision.b2TimeOfImpact.s_distanceOutput = new Box2D.Collision.b2DistanceOutput;\nBox2D.Dynamics.b2BodyDef = function ()\n{\n\n    this.position = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.linearVelocity = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.angularDamping = this.linearDamping = this.angularVelocity = this.angle = 0;\n    this.awake = this.allowSleep = !0;\n    this.bullet = this.fixedRotation = !1;\n    this.type = Box2D.Dynamics.b2BodyDef.b2_staticBody;\n    this.active = !0;\n    this.inertiaScale = 1\n};\nBox2D.Dynamics.b2BodyDef.b2_staticBody = 0;\nBox2D.Dynamics.b2BodyDef.b2_kinematicBody = 1;\nBox2D.Dynamics.b2BodyDef.b2_dynamicBody = 2;\nBox2D.Dynamics.Contacts = {};\nBox2D.Dynamics.Contacts.b2Contact = function (a, b)\n{\n\n    this.ID = \"Contact\" + Box2D.Dynamics.Contacts.b2Contact.NEXT_ID++;\n    this.m_manifold = new Box2D.Collision.b2Manifold;\n    this.m_oldManifold = new Box2D.Collision.b2Manifold;\n    this.touching = !1;\n    var c = a.GetBody(), d = b.GetBody();\n    this.continuous = c.GetType() != Box2D.Dynamics.b2BodyDef.b2_dynamicBody || c.IsBullet() || d.GetType() != Box2D.Dynamics.b2BodyDef.b2_dynamicBody || d.IsBullet();\n    this.sensor = a.IsSensor() || b.IsSensor();\n    this.filtering = !1;\n    this.m_fixtureA = a;\n    this.m_fixtureB = b;\n    this.enabled = !0;\n    this.bodyAList = c.GetContactList();\n    this.bodyBList = d.GetContactList();\n    this.worldList = d.GetWorld().GetContactList();\n    this.AddToLists()\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.Reset = function (a, b)\n{\n    this.m_manifold.Reset();\n    this.m_oldManifold.Reset();\n    this.touching = !1;\n    var c = a.GetBody(), d = b.GetBody();\n    this.continuous = c.GetType() != Box2D.Dynamics.b2BodyDef.b2_dynamicBody || c.IsBullet() || d.GetType() != Box2D.Dynamics.b2BodyDef.b2_dynamicBody || d.IsBullet();\n    this.sensor = a.IsSensor() || b.IsSensor();\n    this.filtering = !1;\n    this.m_fixtureA = a;\n    this.m_fixtureB = b;\n    this.enabled = !0;\n    this.bodyAList = c.GetContactList();\n    this.bodyBList = d.GetContactList();\n    this.worldList = d.GetWorld().GetContactList();\n    this.AddToLists()\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.AddToLists = function ()\n{\n    this.bodyAList.AddContact(this);\n    this.bodyBList.AddContact(this);\n    this.worldList.AddContact(this);\n    this.UpdateLists()\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.UpdateLists = function ()\n{\n    var a = !1, b = !1;\n    !this.IsSensor() && this.IsEnabled() && (this.IsTouching() && (a = !0), this.IsContinuous() && (b = !0));\n    this.bodyAList.UpdateContact(this, a, b);\n    this.bodyBList.UpdateContact(this, a, b);\n    this.worldList.UpdateContact(this, a, b)\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.RemoveFromLists = function ()\n{\n    this.bodyAList.RemoveContact(this);\n    this.bodyBList.RemoveContact(this);\n    this.worldList.RemoveContact(this)\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.GetManifold = function ()\n{\n    return this.m_manifold\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.GetWorldManifold = function (a)\n{\n    var b = this.m_fixtureA.GetBody(), c = this.m_fixtureB.GetBody(), d = this.m_fixtureA.GetShape(), e = this.m_fixtureB.GetShape();\n    a.Initialize(this.m_manifold, b.GetTransform(), d.m_radius, c.GetTransform(), e.m_radius)\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.IsTouching = function ()\n{\n    return this.touching\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.IsContinuous = function ()\n{\n    return this.continuous\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.SetSensor = function (a)\n{\n    this.sensor = a;\n    this.UpdateLists()\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.IsSensor = function ()\n{\n    return this.sensor\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.SetEnabled = function (a)\n{\n    this.enabled = a;\n    this.UpdateLists()\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.IsEnabled = function ()\n{\n    return this.enabled\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.GetNext = function ()\n{\n    return this.m_next\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.GetFixtureA = function ()\n{\n    return this.m_fixtureA\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.GetFixtureB = function ()\n{\n    return this.m_fixtureB\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.GetOther = function (a)\n{\n    var b = this.m_fixtureA.GetBody();\n    return b != a ? b : this.m_fixtureB.GetBody()\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.FlagForFiltering = function ()\n{\n    this.filtering = !0\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.ClearFiltering = function ()\n{\n    this.filtering = !1\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.IsFiltering = function ()\n{\n    return this.filtering\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.Update = function (a)\n{\n    var b = this.m_oldManifold;\n    this.m_oldManifold = this.m_manifold;\n    this.m_manifold = b;\n    this.enabled = !0;\n    var b = !1, c = this.IsTouching(), d = this.m_fixtureA.GetBody(), e = this.m_fixtureB.GetBody(), f = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);\n    if (this.sensor)\n    {\n        f && (b = Box2D.Collision.Shapes.b2Shape.TestOverlap(this.m_fixtureA.GetShape(), d.GetTransform(), this.m_fixtureB.GetShape(), e.GetTransform())), this.m_manifold.m_pointCount = 0\n    } else\n    {\n        this.continuous = d.GetType() != Box2D.Dynamics.b2BodyDef.b2_dynamicBody || d.IsBullet() || e.GetType() != Box2D.Dynamics.b2BodyDef.b2_dynamicBody || e.IsBullet() ? !0 : !1;\n        if (f)\n        {\n            this.Evaluate();\n            b = 0 < this.m_manifold.m_pointCount;\n            for (f = 0; f < this.m_manifold.m_pointCount; f++)\n            {\n                var g = this.m_manifold.m_points[f];\n                g.m_normalImpulse = 0;\n                for (var h = g.m_tangentImpulse = 0; h < this.m_oldManifold.m_pointCount; h++)\n                {\n                    var i = this.m_oldManifold.m_points[h];\n                    if (i.m_id.GetKey() == g.m_id.GetKey())\n                    {\n                        g.m_normalImpulse = i.m_normalImpulse;\n                        g.m_tangentImpulse = i.m_tangentImpulse;\n                        break\n                    }\n                }\n            }\n        } else\n        {\n            this.m_manifold.m_pointCount = 0\n        }\n        b != c && (d.SetAwake(!0), e.SetAwake(!0))\n    }\n    this.touching = b;\n    b != c && this.UpdateLists();\n    !c && b && a.BeginContact(this);\n    c && !b && a.EndContact(this);\n    this.sensor || a.PreSolve(this, this.m_oldManifold)\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.Evaluate = function ()\n{\n};\nBox2D.Dynamics.Contacts.b2Contact.prototype.ComputeTOI = function (a, b)\n{\n    Box2D.Dynamics.Contacts.b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());\n    Box2D.Dynamics.Contacts.b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());\n    Box2D.Dynamics.Contacts.b2Contact.s_input.sweepA = a;\n    Box2D.Dynamics.Contacts.b2Contact.s_input.sweepB = b;\n    Box2D.Dynamics.Contacts.b2Contact.s_input.tolerance = Box2D.Common.b2Settings.b2_linearSlop;\n    return Box2D.Collision.b2TimeOfImpact.TimeOfImpact(Box2D.Dynamics.Contacts.b2Contact.s_input)\n};\nBox2D.Dynamics.Contacts.b2Contact.s_input = new Box2D.Collision.b2TOIInput;\nBox2D.Dynamics.Contacts.b2Contact.NEXT_ID = 0;\nBox2D.Collision.Shapes.b2MassData = function ()\n{\n\n    this.mass = 0;\n    this.center = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.I = 0\n};\nBox2D.Collision.Shapes.b2MassData._freeCache = [];\nBox2D.Collision.Shapes.b2MassData.Get = function ()\n{\n\n    if (0 < Box2D.Collision.Shapes.b2MassData._freeCache.length)\n    {\n        var a = Box2D.Collision.Shapes.b2MassData._freeCache.pop();\n        a.mass = 0;\n        a.center.SetZero();\n        a.I = 0;\n        return a\n    }\n    return new Box2D.Collision.Shapes.b2MassData\n};\nBox2D.Collision.Shapes.b2MassData.Free = function (a)\n{\n    null != a && ( Box2D.Collision.Shapes.b2MassData._freeCache.push(a))\n};\nBox2D.Collision.Shapes.b2MassData.prototype.SetV = function (a, b, c)\n{\n    this.mass = a;\n    this.center.SetV(b);\n    this.I = c\n};\nBox2D.Collision.Shapes.b2MassData.prototype.Set = function (a, b, c, d)\n{\n    this.mass = a;\n    this.center.Set(b, c);\n    this.I = d\n};\nBox2D.Collision.Shapes.b2PolygonShape = function ()\n{\n\n    Box2D.Collision.Shapes.b2Shape.call(this);\n    this.m_centroid = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_vertices = [];\n    this.m_normals = []\n};\ngoog.inherits(Box2D.Collision.Shapes.b2PolygonShape, Box2D.Collision.Shapes.b2Shape);\nBox2D.Collision.Shapes.b2PolygonShape.prototype.GetTypeName = function ()\n{\n    return Box2D.Collision.Shapes.b2PolygonShape.NAME\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.Copy = function ()\n{\n    var a = new Box2D.Collision.Shapes.b2PolygonShape;\n    a.Set(this);\n    return a\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.Set = function (a)\n{\n    Box2D.Collision.Shapes.b2Shape.prototype.Set.call(this, a);\n    if (a instanceof Box2D.Collision.Shapes.b2PolygonShape)\n    {\n        this.m_centroid.SetV(a.m_centroid);\n        this.m_vertexCount = a.m_vertexCount;\n        this.Reserve(this.m_vertexCount);\n        for (var b = 0; b < this.m_vertexCount; b++)\n        {\n            this.m_vertices[b].SetV(a.m_vertices[b]), this.m_normals[b].SetV(a.m_normals[b])\n        }\n    }\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.SetAsArray = function (a)\n{\n    this.SetAsVector(a)\n};\nBox2D.Collision.Shapes.b2PolygonShape.AsArray = function (a)\n{\n    var b = new Box2D.Collision.Shapes.b2PolygonShape;\n    b.SetAsArray(a);\n    return b\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.SetAsVector = function (a)\n{\n    var b = a.length;\n    Box2D.Common.b2Settings.b2Assert(2 <= b);\n    this.m_vertexCount = b;\n    this.Reserve(b);\n    for (b = b = 0; b < this.m_vertexCount; b++)\n    {\n        this.m_vertices[b].SetV(a[b])\n    }\n    for (b = 0; b < this.m_vertexCount; ++b)\n    {\n        a = Box2D.Common.Math.b2Math.SubtractVV(this.m_vertices[b + 1 < this.m_vertexCount ? b + 1 : 0], this.m_vertices[b]);\n        Box2D.Common.b2Settings.b2Assert(a.LengthSquared() > Number.MIN_VALUE);\n        var c = Box2D.Common.Math.b2Math.CrossVF(a, 1);\n        Box2D.Common.Math.b2Vec2.Free(a);\n        this.m_normals[b].SetV(c);\n        Box2D.Common.Math.b2Vec2.Free(c);\n        this.m_normals[b].Normalize()\n    }\n    this.m_centroid = Box2D.Collision.Shapes.b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount)\n};\nBox2D.Collision.Shapes.b2PolygonShape.AsVector = function (a)\n{\n    var b = new Box2D.Collision.Shapes.b2PolygonShape;\n    b.SetAsVector(a);\n    return b\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.SetAsBox = function (a, b)\n{\n    this.m_vertexCount = 4;\n    this.Reserve(4);\n    this.m_vertices[0].Set(-a, -b);\n    this.m_vertices[1].Set(a, -b);\n    this.m_vertices[2].Set(a, b);\n    this.m_vertices[3].Set(-a, b);\n    this.m_normals[0].Set(0, -1);\n    this.m_normals[1].Set(1, 0);\n    this.m_normals[2].Set(0, 1);\n    this.m_normals[3].Set(-1, 0);\n    this.m_centroid.SetZero()\n};\nBox2D.Collision.Shapes.b2PolygonShape.AsBox = function (a, b)\n{\n    var c = new Box2D.Collision.Shapes.b2PolygonShape;\n    c.SetAsBox(a, b);\n    return c\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.SetAsOrientedBox = function (a, b, c, d)\n{\n    this.m_vertexCount = 4;\n    this.Reserve(4);\n    this.m_vertices[0].Set(-a, -b);\n    this.m_vertices[1].Set(a, -b);\n    this.m_vertices[2].Set(a, b);\n    this.m_vertices[3].Set(-a, b);\n    this.m_normals[0].Set(0, -1);\n    this.m_normals[1].Set(1, 0);\n    this.m_normals[2].Set(0, 1);\n    this.m_normals[3].Set(-1, 0);\n    this.m_centroid = c;\n    a = new Box2D.Common.Math.b2Mat22;\n    a.Set(d);\n    c = new Box2D.Common.Math.b2Transform(c, a);\n    for (d = 0; d < this.m_vertexCount; ++d)\n    {\n        this.m_vertices[d] = Box2D.Common.Math.b2Math.MulX(c, this.m_vertices[d]), this.m_normals[d] = Box2D.Common.Math.b2Math.MulMV(c.R, this.m_normals[d])\n    }\n};\nBox2D.Collision.Shapes.b2PolygonShape.AsOrientedBox = function (a, b, c, d)\n{\n    var e = new Box2D.Collision.Shapes.b2PolygonShape;\n    e.SetAsOrientedBox(a, b, c, d);\n    return e\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.SetAsEdge = function (a, b)\n{\n    this.m_vertexCount = 2;\n    this.Reserve(2);\n    this.m_vertices[0].SetV(a);\n    this.m_vertices[1].SetV(b);\n    this.m_centroid.x = 0.5 * (a.x + b.x);\n    this.m_centroid.y = 0.5 * (a.y + b.y);\n    var c = Box2D.Common.Math.b2Math.SubtractVV(b, a), d = Box2D.Common.Math.b2Math.CrossVF(c, 1);\n    Box2D.Common.Math.b2Vec2.Free(c);\n    this.m_normals[0] = d;\n    Box2D.Common.Math.b2Vec2.Free(d);\n    this.m_normals[0].Normalize();\n    this.m_normals[1].x = -this.m_normals[0].x;\n    this.m_normals[1].y = -this.m_normals[0].y\n};\nBox2D.Collision.Shapes.b2PolygonShape.AsEdge = function (a, b)\n{\n    var c = new Box2D.Collision.Shapes.b2PolygonShape;\n    c.SetAsEdge(a, b);\n    return c\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.TestPoint = function (a, b)\n{\n    var c;\n    c = a.R;\n    for (var d = b.x - a.position.x, e = b.y - a.position.y, f = d * c.col1.x + e * c.col1.y, g = d * c.col2.x + e * c.col2.y, h = 0; h < this.m_vertexCount; ++h)\n    {\n        if (c = this.m_vertices[h], d = f - c.x, e = g - c.y, c = this.m_normals[h], 0 < c.x * d + c.y * e)\n        {\n            return!1\n        }\n    }\n    return!0\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.RayCast = function (a, b, c)\n{\n    var d = 0, e = b.maxFraction, f = 0, g = 0, h, i, f = b.p1.x - c.position.x, g = b.p1.y - c.position.y;\n    h = c.R;\n    var j = f * h.col1.x + g * h.col1.y, k = f * h.col2.x + g * h.col2.y, f = b.p2.x - c.position.x, g = b.p2.y - c.position.y;\n    h = c.R;\n    b = f * h.col1.x + g * h.col1.y - j;\n    h = f * h.col2.x + g * h.col2.y - k;\n    for (var l = -1, n = 0; n < this.m_vertexCount; ++n)\n    {\n        i = this.m_vertices[n];\n        f = i.x - j;\n        g = i.y - k;\n        i = this.m_normals[n];\n        f = i.x * f + i.y * g;\n        g = i.x * b + i.y * h;\n        if (0 == g)\n        {\n            if (0 > f)\n            {\n                return!1\n            }\n        } else\n        {\n            0 > g && f < d * g ? (d = f / g, l = n) : 0 < g && f < e * g && (e = f / g)\n        }\n        if (e < d - Number.MIN_VALUE)\n        {\n            return!1\n        }\n    }\n    return 0 <= l ? (a.fraction = d, h = c.R, i = this.m_normals[l], a.normal.x = h.col1.x * i.x + h.col2.x * i.y, a.normal.y = h.col1.y * i.x + h.col2.y * i.y, !0) : !1\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.ComputeAABB = function (a, b)\n{\n    for (var c = b.R, d = this.m_vertices[0], e = b.position.x + (c.col1.x * d.x + c.col2.x * d.y), f = b.position.y + (c.col1.y * d.x + c.col2.y * d.y), g = e, h = f, i = 1; i < this.m_vertexCount; ++i)\n    {\n        var d = this.m_vertices[i], j = b.position.x + (c.col1.x * d.x + c.col2.x * d.y), d = b.position.y + (c.col1.y * d.x + c.col2.y * d.y), e = e < j ? e : j, f = f < d ? f : d, g = g > j ? g : j, h = h > d ? h : d\n    }\n    a.lowerBound.x = e - this.m_radius;\n    a.lowerBound.y = f - this.m_radius;\n    a.upperBound.x = g + this.m_radius;\n    a.upperBound.y = h + this.m_radius\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.ComputeMass = function (a, b)\n{\n    if (2 == this.m_vertexCount)\n    {\n        a.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x), a.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y), a.mass = 0, a.I = 0\n    } else\n    {\n        for (var c = 0, d = 0, e = 0, f = 0, g = 1 / 3, h = 0; h < this.m_vertexCount; ++h)\n        {\n            var i = this.m_vertices[h], j = h + 1 < this.m_vertexCount ? this.m_vertices[h + 1] : this.m_vertices[0], k = i.x - 0, l = i.y - 0, n = j.x - 0, m = j.y - 0, o = k * m - l * n, p = 0.5 * o, e = e + p, c = c + p * g * (0 + i.x + j.x), d = d + p * g * (0 + i.y + j.y), i = k, f = f + o * (g * (0.25 * (i * i + n * i + n * n) + (0 * i + 0 * n)) + 0 + (g * (0.25 * (l * l + m * l + m * m) + (0 * l + 0 * m)) + 0))\n        }\n        a.Set(b * e, c * (1 / e), d * (1 / e), b * f)\n    }\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.ComputeSubmergedArea = function (a, b, c, d)\n{\n    for (var e = Box2D.Common.Math.b2Math.MulTMV(c.R, a), f = b - Box2D.Common.Math.b2Math.Dot(a, c.position), g = [], h = 0, i = -1, b = -1, j = !1, a = a = 0; a < this.m_vertexCount; ++a)\n    {\n        g[a] = Box2D.Common.Math.b2Math.Dot(e, this.m_vertices[a]) - f;\n        var k = g[a] < -Number.MIN_VALUE;\n        0 < a && (k ? j || (i = a - 1, h++) : j && (b = a - 1, h++));\n        j = k\n    }\n    Box2D.Common.Math.b2Vec2.Free(e);\n    switch (h)\n    {\n        case 0:\n            return j ? (a = Box2D.Collision.Shapes.b2MassData.Get(), this.ComputeMass(a, 1), c = Box2D.Common.Math.b2Math.MulX(c, a.center), d.SetV(c), Box2D.Common.Math.b2Vec2.Free(c), d = a.mass, Box2D.Collision.Shapes.b2MassData.Free(a), d) : 0;\n        case 1:\n            -1 == i ? i = this.m_vertexCount - 1 : b = this.m_vertexCount - 1\n    }\n    a = (i + 1) % this.m_vertexCount;\n    e = (b + 1) % this.m_vertexCount;\n    f = (0 - g[i]) / (g[a] - g[i]);\n    g = (0 - g[b]) / (g[e] - g[b]);\n    i = Box2D.Common.Math.b2Vec2.Get(this.m_vertices[i].x * (1 - f) + this.m_vertices[a].x * f, this.m_vertices[i].y * (1 - f) + this.m_vertices[a].y * f);\n    f = Box2D.Common.Math.b2Vec2.Get(this.m_vertices[b].x * (1 - g) + this.m_vertices[e].x * g, this.m_vertices[b].y * (1 - g) + this.m_vertices[e].y * g);\n    b = 0;\n    g = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    for (h = this.m_vertices[a]; a != e;)\n    {\n        a = (a + 1) % this.m_vertexCount, j = a == e ? f : this.m_vertices[a], k = 0.5 * ((h.x - i.x) * (j.y - i.y) - (h.y - i.y) * (j.x - i.x)), b += k, g.x += k * (i.x + h.x + j.x) / 3, g.y += k * (i.y + h.y + j.y) / 3, h = j\n    }\n    Box2D.Common.Math.b2Vec2.Free(i);\n    Box2D.Common.Math.b2Vec2.Free(f);\n    g.Multiply(1 / b);\n    c = Box2D.Common.Math.b2Math.MulX(c, g);\n    Box2D.Common.Math.b2Vec2.Free(g);\n    d.SetV(c);\n    Box2D.Common.Math.b2Vec2.Free(c);\n    return b\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.SetDistanceProxy = function (a)\n{\n    a.SetValues(this.m_vertexCount, this.m_radius, this.m_vertices)\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.GetVertexCount = function ()\n{\n    return this.m_vertexCount\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.GetVertices = function ()\n{\n    return this.m_vertices\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.GetNormals = function ()\n{\n    return this.m_normals\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.GetSupport = function (a)\n{\n    for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_vertexCount; ++d)\n    {\n        var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;\n        e > c && (b = d, c = e)\n    }\n    return b\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.GetSupportVertex = function (a)\n{\n    for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_vertexCount; ++d)\n    {\n        var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;\n        e > c && (b = d, c = e)\n    }\n    return this.m_vertices[b]\n};\nBox2D.Collision.Shapes.b2PolygonShape.prototype.Reserve = function (a)\n{\n    for (var b = 0; b < this.m_vertices.length; b++)\n    {\n        Box2D.Common.Math.b2Vec2.Free(this.m_vertices[b]), Box2D.Common.Math.b2Vec2.Free(this.m_normals[b])\n    }\n    this.m_vertices = [];\n    this.m_normals = [];\n    for (b = 0; b < a; b++)\n    {\n        this.m_vertices[b] = Box2D.Common.Math.b2Vec2.Get(0, 0), this.m_normals[b] = Box2D.Common.Math.b2Vec2.Get(0, 0)\n    }\n};\nBox2D.Collision.Shapes.b2PolygonShape.ComputeCentroid = function (a, b)\n{\n    for (var c = Box2D.Common.Math.b2Vec2.Get(0, 0), d = 0, e = 1 / 3, f = 0; f < b; ++f)\n    {\n        var g = a[f], h = f + 1 < b ? a[f + 1] : a[0], i = 0.5 * ((g.x - 0) * (h.y - 0) - (g.y - 0) * (h.x - 0)), d = d + i;\n        c.x += i * e * (0 + g.x + h.x);\n        c.y += i * e * (0 + g.y + h.y)\n    }\n    c.x *= 1 / d;\n    c.y *= 1 / d;\n    return c\n};\nBox2D.Collision.Shapes.b2PolygonShape.s_mat = new Box2D.Common.Math.b2Mat22;\nBox2D.Collision.Shapes.b2PolygonShape.NAME = \"b2PolygonShape\";\nBox2D.Collision.Shapes.b2EdgeShape = function (a, b)\n{\n\n    Box2D.Collision.Shapes.b2Shape.call(this);\n    this.m_nextEdge = this.m_prevEdge = null;\n    this.m_v1 = a;\n    this.m_v2 = b;\n    this.m_direction = Box2D.Common.Math.b2Vec2.Get(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);\n    this.m_length = this.m_direction.Normalize();\n    this.m_normal = Box2D.Common.Math.b2Vec2.Get(this.m_direction.y, -this.m_direction.x);\n    this.m_coreV1 = Box2D.Common.Math.b2Vec2.Get(-Box2D.Common.b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -Box2D.Common.b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);\n    this.m_coreV2 = Box2D.Common.Math.b2Vec2.Get(-Box2D.Common.b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -Box2D.Common.b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);\n    this.m_cornerDir1 = this.m_normal;\n    this.m_cornerDir2 = Box2D.Common.Math.b2Vec2.Get(-this.m_normal.x, -this.m_normal.y);\n    this.m_cornerConvex2 = this.m_cornerConvex1 = !1\n};\ngoog.inherits(Box2D.Collision.Shapes.b2EdgeShape, Box2D.Collision.Shapes.b2Shape);\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetTypeName = function ()\n{\n    return Box2D.Collision.Shapes.b2EdgeShape.NAME\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.TestPoint = function ()\n{\n    return!1\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.RayCast = function (a, b, c)\n{\n    var d = b.p2.x - b.p1.x, e = b.p2.y - b.p1.y, f = c.R, g = c.position.x + (f.col1.x * this.m_v1.x + f.col2.x * this.m_v1.y), h = c.position.y + (f.col1.y * this.m_v1.x + f.col2.y * this.m_v1.y), i = c.position.y + (f.col1.y * this.m_v2.x + f.col2.y * this.m_v2.y) - h, c = -(c.position.x + (f.col1.x * this.m_v2.x + f.col2.x * this.m_v2.y) - g), f = 100 * Number.MIN_VALUE, j = -(d * i + e * c);\n    if (j > f)\n    {\n        var g = b.p1.x - g, k = b.p1.y - h, h = g * i + k * c;\n        if (0 <= h && h <= b.maxFraction * j && (b = -d * k + e * g, -f * j <= b && b <= j * (1 + f)))\n        {\n            return a.fraction = h / j, b = Math.sqrt(i * i + c * c), a.normal.x = i / b, a.normal.y = c / b, !0\n        }\n    }\n    return!1\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.ComputeAABB = function (a, b)\n{\n    var c = b.R, d = b.position.x + (c.col1.x * this.m_v1.x + c.col2.x * this.m_v1.y), e = b.position.y + (c.col1.y * this.m_v1.x + c.col2.y * this.m_v1.y), f = b.position.x + (c.col1.x * this.m_v2.x + c.col2.x * this.m_v2.y), c = b.position.y + (c.col1.y * this.m_v2.x + c.col2.y * this.m_v2.y);\n    d < f ? (a.lowerBound.x = d, a.upperBound.x = f) : (a.lowerBound.x = f, a.upperBound.x = d);\n    e < c ? (a.lowerBound.y = e, a.upperBound.y = c) : (a.lowerBound.y = c, a.upperBound.y = e)\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.ComputeMass = function (a)\n{\n    a.mass = 0;\n    a.center.SetV(this.m_v1);\n    a.I = 0\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.ComputeSubmergedArea = function (a, b, c, d)\n{\n    void 0 === b && (b = 0);\n    var e = Box2D.Common.Math.b2Vec2.Get(a.x * b, a.y * b), f = Box2D.Common.Math.b2Math.MulX(c, this.m_v1), c = Box2D.Common.Math.b2Math.MulX(c, this.m_v2), g = Box2D.Common.Math.b2Math.Dot(a, f) - b, a = Box2D.Common.Math.b2Math.Dot(a, c) - b;\n    if (0 < g)\n    {\n        if (0 < a)\n        {\n            return 0\n        }\n        f.x = -a / (g - a) * f.x + g / (g - a) * c.x;\n        f.y = -a / (g - a) * f.y + g / (g - a) * c.y\n    } else\n    {\n        0 < a && (c.x = -a / (g - a) * f.x + g / (g - a) * c.x, c.y = -a / (g - a) * f.y + g / (g - a) * c.y)\n    }\n    d.x = (e.x + f.x + c.x) / 3;\n    d.y = (e.y + f.y + c.y) / 3;\n    return 0.5 * ((f.x - e.x) * (c.y - e.y) - (f.y - e.y) * (c.x - e.x))\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetLength = function ()\n{\n    return this.m_length\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetVertex1 = function ()\n{\n    return this.m_v1\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetVertex2 = function ()\n{\n    return this.m_v2\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetCoreVertex1 = function ()\n{\n    return this.m_coreV1\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetCoreVertex2 = function ()\n{\n    return this.m_coreV2\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetNormalVector = function ()\n{\n    return this.m_normal\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetDirectionVector = function ()\n{\n    return this.m_direction\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetCorner1Vector = function ()\n{\n    return this.m_cornerDir1\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetCorner2Vector = function ()\n{\n    return this.m_cornerDir2\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.Corner1IsConvex = function ()\n{\n    return this.m_cornerConvex1\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.Corner2IsConvex = function ()\n{\n    return this.m_cornerConvex2\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetFirstVertex = function (a)\n{\n    var b = a.R;\n    return Box2D.Common.Math.b2Vec2.Get(a.position.x + (b.col1.x * this.m_coreV1.x + b.col2.x * this.m_coreV1.y), a.position.y + (b.col1.y * this.m_coreV1.x + b.col2.y * this.m_coreV1.y))\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetNextEdge = function ()\n{\n    return this.m_nextEdge\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.GetPrevEdge = function ()\n{\n    return this.m_prevEdge\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.Support = function (a, b, c)\n{\n    var d = a.R, e = a.position.x + (d.col1.x * this.m_coreV1.x + d.col2.x * this.m_coreV1.y), f = a.position.y + (d.col1.y * this.m_coreV1.x + d.col2.y * this.m_coreV1.y), g = a.position.x + (d.col1.x * this.m_coreV2.x + d.col2.x * this.m_coreV2.y), a = a.position.y + (d.col1.y * this.m_coreV2.x + d.col2.y * this.m_coreV2.y);\n    return e * b + f * c > g * b + a * c ? Box2D.Common.Math.b2Vec2.Get(e, f) : Box2D.Common.Math.b2Vec2.Get(g, a)\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.SetPrevEdge = function (a, b, c, d)\n{\n    this.m_prevEdge = a;\n    this.m_coreV1 = b;\n    this.m_cornerDir1 = c;\n    this.m_cornerConvex1 = d\n};\nBox2D.Collision.Shapes.b2EdgeShape.prototype.SetNextEdge = function (a, b, c, d)\n{\n    this.m_nextEdge = a;\n    this.m_coreV2 = b;\n    this.m_cornerDir2 = c;\n    this.m_cornerConvex2 = d\n};\nBox2D.Collision.Shapes.b2EdgeShape.NAME = \"b2EdgeShape\";\nBox2D.Dynamics.Contacts.b2PolyAndEdgeContact = function (a, b)\n{\n    Box2D.Common.b2Settings.b2Assert(a.GetShape() instanceof Box2D.Collision.Shapes.b2PolygonShape);\n    Box2D.Common.b2Settings.b2Assert(b.GetShape() instanceof Box2D.Collision.Shapes.b2EdgeShape);\n    Box2D.Dynamics.Contacts.b2Contact.call(this, a, b)\n};\ngoog.inherits(Box2D.Dynamics.Contacts.b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);\nBox2D.Dynamics.Contacts.b2PolyAndEdgeContact.prototype.Reset = function (a, b)\n{\n    Box2D.Common.b2Settings.b2Assert(a.GetShape() instanceof Box2D.Collision.Shapes.b2PolygonShape);\n    Box2D.Common.b2Settings.b2Assert(b.GetShape() instanceof Box2D.Collision.Shapes.b2EdgeShape);\n    Box2D.Dynamics.Contacts.b2Contact.prototype.Reset.call(this, a, b)\n};\nBox2D.Dynamics.Contacts.b2PolyAndEdgeContact.prototype.Evaluate = function ()\n{\n    this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape(), this.m_fixtureA.GetBody().m_xf, this.m_fixtureB.GetShape(), this.m_fixtureB.GetBody().m_xf)\n};\nBox2D.Dynamics.Contacts.b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function ()\n{\n};\nBox2D.Dynamics.b2TimeStep = function (a, b, c, d, e)\n{\n\n    this.Reset(a, b, c, d, e)\n};\nBox2D.Dynamics.b2TimeStep.prototype.Reset = function (a, b, c, d, e)\n{\n    this.dt = a;\n    var f = 0;\n    0 < a && (f = 1 / a);\n    this.inv_dt = f;\n    this.dtRatio = b;\n    this.positionIterations = c;\n    this.velocityIterations = d;\n    this.warmStarting = e\n};\nBox2D.Dynamics.Joints.b2FrictionJoint = function (a)\n{\n    Box2D.Dynamics.Joints.b2Joint.call(this, a);\n    this.m_localAnchorA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchorB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_linearMass = new Box2D.Common.Math.b2Mat22;\n    this.m_linearImpulse = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchorA.SetV(a.localAnchorA);\n    this.m_localAnchorB.SetV(a.localAnchorB);\n    this.m_linearMass.SetZero();\n    this.m_angularMass = 0;\n    this.m_linearImpulse.SetZero();\n    this.m_angularImpulse = 0;\n    this.m_maxForce = a.maxForce;\n    this.m_maxTorque = a.maxTorque\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.GetAnchorA = function ()\n{\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)\n};\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.GetAnchorB = function ()\n{\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)\n};\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.GetReactionForce = function (a)\n{\n    void 0 === a && (a = 0);\n    return new Box2D.Common.Math.b2Vec2.Get(a * this.m_linearImpulse.x, a * this.m_linearImpulse.y)\n};\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.GetReactionTorque = function (a)\n{\n    void 0 === a && (a = 0);\n    return a * this.m_angularImpulse\n};\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.SetMaxForce = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_maxForce = a\n};\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.GetMaxForce = function ()\n{\n    return this.m_maxForce\n};\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.SetMaxTorque = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_maxTorque = a\n};\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.GetMaxTorque = function ()\n{\n    return this.m_maxTorque\n};\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.InitVelocityConstraints = function (a)\n{\n    var b, c = 0, d = this.m_bodyA, e = this.m_bodyB;\n    b = d.m_xf.R;\n    var f = this.m_localAnchorA.x - d.m_sweep.localCenter.x, g = this.m_localAnchorA.y - d.m_sweep.localCenter.y, c = b.col1.x * f + b.col2.x * g, g = b.col1.y * f + b.col2.y * g, f = c;\n    b = e.m_xf.R;\n    var h = this.m_localAnchorB.x - e.m_sweep.localCenter.x, i = this.m_localAnchorB.y - e.m_sweep.localCenter.y, c = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = c;\n    b = d.m_invMass;\n    var c = e.m_invMass, j = d.m_invI, k = e.m_invI, l = new b2Mat22;\n    l.col1.x = b + c;\n    l.col2.x = 0;\n    l.col1.y = 0;\n    l.col2.y = b + c;\n    l.col1.x += j * g * g;\n    l.col2.x += -j * f * g;\n    l.col1.y += -j * f * g;\n    l.col2.y += j * f * f;\n    l.col1.x += k * i * i;\n    l.col2.x += -k * h * i;\n    l.col1.y += -k * h * i;\n    l.col2.y += k * h * h;\n    l.GetInverse(this.m_linearMass);\n    this.m_angularMass = j + k;\n    0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass);\n    a.warmStarting ? (this.m_linearImpulse.x *= a.dtRatio, this.m_linearImpulse.y *= a.dtRatio, this.m_angularImpulse *= a.dtRatio, a = this.m_linearImpulse, d.m_linearVelocity.x -= b * a.x, d.m_linearVelocity.y -= b * a.y, d.m_angularVelocity -= j * (f * a.y - g * a.x + this.m_angularImpulse), e.m_linearVelocity.x += c * a.x, e.m_linearVelocity.y += c * a.y, e.m_angularVelocity += k * (h * a.y - i * a.x + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0)\n};\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.SolveVelocityConstraints = function (a)\n{\n    var b, c = 0, d = this.m_bodyA, e = this.m_bodyB, f = d.m_linearVelocity, g = d.m_angularVelocity, h = e.m_linearVelocity, i = e.m_angularVelocity, j = d.m_invMass, k = e.m_invMass, l = d.m_invI, n = e.m_invI;\n    b = d.m_xf.R;\n    var m = this.m_localAnchorA.x - d.m_sweep.localCenter.x, o = this.m_localAnchorA.y - d.m_sweep.localCenter.y, c = b.col1.x * m + b.col2.x * o, o = b.col1.y * m + b.col2.y * o, m = c;\n    b = e.m_xf.R;\n    var p = this.m_localAnchorB.x - e.m_sweep.localCenter.x, q = this.m_localAnchorB.y - e.m_sweep.localCenter.y, c = b.col1.x * p + b.col2.x * q, q = b.col1.y * p + b.col2.y * q, p = c;\n    b = 0;\n    var c = -this.m_angularMass * (i - g), r = this.m_angularImpulse;\n    b = a.dt * this.m_maxTorque;\n    this.m_angularImpulse = Box2D.Common.Math.b2Math.Clamp(this.m_angularImpulse + c, -b, b);\n    c = this.m_angularImpulse - r;\n    g -= l * c;\n    i += n * c;\n    b = Box2D.Common.Math.b2Vec2.Get(-(h.x - i * q - f.x + g * o), -(h.y + i * p - f.y - g * m));\n    b.MulM(this.m_linearMass);\n    c = this.m_linearImpulse.Copy();\n    this.m_linearImpulse.Add(b);\n    Box2D.Common.Math.b2Vec2.Free(b);\n    b = a.dt * this.m_maxForce;\n    this.m_linearImpulse.LengthSquared() > b * b && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(b));\n    b = Box2D.Common.Math.b2Math.SubtractVV(this.m_linearImpulse, c);\n    Box2D.Common.Math.b2Vec2.Free(c);\n    f.x -= j * b.x;\n    f.y -= j * b.y;\n    g -= l * (m * b.y - o * b.x);\n    h.x += k * b.x;\n    h.y += k * b.y;\n    i += n * (p * b.y - q * b.x);\n    Box2D.Common.Math.b2Vec2.Free(b);\n    d.m_angularVelocity = g;\n    e.m_angularVelocity = i\n};\nBox2D.Dynamics.Joints.b2FrictionJoint.prototype.SolvePositionConstraints = function ()\n{\n    return!0\n};\nBox2D.Dynamics.b2DestructionListener = function ()\n{\n};\nBox2D.Dynamics.b2DestructionListener.prototype.SayGoodbyeJoint = function ()\n{\n};\nBox2D.Dynamics.b2DestructionListener.prototype.SayGoodbyeFixture = function ()\n{\n};\nBox2D.Dynamics.b2FilterData = function ()\n{\n\n    this.categoryBits = 1;\n    this.maskBits = 65535;\n    this.groupIndex = 0\n};\nBox2D.Dynamics.b2FilterData.prototype.Copy = function ()\n{\n    var a = new Box2D.Dynamics.b2FilterData;\n    a.categoryBits = this.categoryBits;\n    a.maskBits = this.maskBits;\n    a.groupIndex = this.groupIndex;\n    return a\n};\nBox2D.Dynamics.b2Fixture = function (a, b, c)\n{\n\n    this.ID = \"Fixture\" + Box2D.Dynamics.b2Fixture.NEXT_ID++;\n    this.m_filter = c.filter.Copy();\n    this.m_aabb = Box2D.Collision.b2AABB.Get();\n    this.m_aabb_temp = Box2D.Collision.b2AABB.Get();\n    this.m_body = a;\n    this.m_shape = c.shape.Copy();\n    this.m_density = c.density;\n    this.m_friction = c.friction;\n    this.m_restitution = c.restitution;\n    this.m_isSensor = c.isSensor\n};\nBox2D.Dynamics.b2Fixture.prototype.GetShape = function ()\n{\n    return this.m_shape\n};\nBox2D.Dynamics.b2Fixture.prototype.SetSensor = function (a)\n{\n    if (this.m_isSensor != a && (this.m_isSensor = a, null != this.m_body))\n    {\n        for (a = this.m_body.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); a; a = a.GetNextNode())\n        {\n            var b = a.contact.GetFixtureA(), c = a.contact.GetFixtureB();\n            if (b == this || c == this)\n            {\n                a.contact.SetSensor(b.IsSensor() || c.IsSensor())\n            }\n        }\n    }\n};\nBox2D.Dynamics.b2Fixture.prototype.IsSensor = function ()\n{\n    return this.m_isSensor\n};\nBox2D.Dynamics.b2Fixture.prototype.SetFilterData = function (a)\n{\n    this.m_filter = a.Copy();\n    if (null != this.m_body)\n    {\n        for (a = this.m_body.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); a; a = a.GetNextNode())\n        {\n            (a.contact.GetFixtureA() == this || a.contact.GetFixtureB() == this) && a.contact.FlagForFiltering()\n        }\n    }\n};\nBox2D.Dynamics.b2Fixture.prototype.GetFilterData = function ()\n{\n    return this.m_filter\n};\nBox2D.Dynamics.b2Fixture.prototype.GetBody = function ()\n{\n    return this.m_body\n};\nBox2D.Dynamics.b2Fixture.prototype.TestPoint = function (a)\n{\n    return this.m_shape.TestPoint(this.m_body.GetTransform(), a)\n};\nBox2D.Dynamics.b2Fixture.prototype.RayCast = function (a, b)\n{\n    return this.m_shape.RayCast(a, b, this.m_body.GetTransform())\n};\nBox2D.Dynamics.b2Fixture.prototype.GetMassData = function (a)\n{\n    a || (a = Box2D.Collision.Shapes.b2MassData.Get());\n    this.m_shape.ComputeMass(a, this.m_density);\n    return a\n};\nBox2D.Dynamics.b2Fixture.prototype.SetDensity = function (a)\n{\n    this.m_density = a\n};\nBox2D.Dynamics.b2Fixture.prototype.GetDensity = function ()\n{\n    return this.m_density\n};\nBox2D.Dynamics.b2Fixture.prototype.GetFriction = function ()\n{\n    return this.m_friction\n};\nBox2D.Dynamics.b2Fixture.prototype.SetFriction = function (a)\n{\n    this.m_friction = a\n};\nBox2D.Dynamics.b2Fixture.prototype.GetRestitution = function ()\n{\n    return this.m_restitution\n};\nBox2D.Dynamics.b2Fixture.prototype.SetRestitution = function (a)\n{\n    this.m_restitution = a\n};\nBox2D.Dynamics.b2Fixture.prototype.GetAABB = function ()\n{\n    return this.m_aabb\n};\nBox2D.Dynamics.b2Fixture.prototype.Destroy = function ()\n{\n    Box2D.Collision.b2AABB.Free(this.m_aabb)\n};\nBox2D.Dynamics.b2Fixture.prototype.CreateProxy = function (a, b)\n{\n    this.m_shape.ComputeAABB(this.m_aabb, b);\n    this.m_proxy = a.CreateProxy(this.m_aabb, this)\n};\nBox2D.Dynamics.b2Fixture.prototype.DestroyProxy = function (a)\n{\n    null != this.m_proxy && (a.DestroyProxy(this.m_proxy), this.m_proxy = null)\n};\nBox2D.Dynamics.b2Fixture.prototype.Synchronize = function (a, b, c)\n{\n    this.m_proxy && (this.m_shape.ComputeAABB(this.m_aabb, b), this.m_shape.ComputeAABB(this.m_aabb_temp, c), this.m_aabb.Combine(this.m_aabb, this.m_aabb_temp), b = Box2D.Common.Math.b2Math.SubtractVV(c.position, b.position), a.MoveProxy(this.m_proxy, this.m_aabb, b), Box2D.Common.Math.b2Vec2.Free(b))\n};\nBox2D.Dynamics.b2Fixture.NEXT_ID = 0;\nBox2D.Dynamics.iContactListener = function ()\n{\n};\nBox2D.Dynamics.iContactListener.prototype.BeginContact = function ()\n{\n};\nBox2D.Dynamics.iContactListener.prototype.EndContact = function ()\n{\n};\nBox2D.Dynamics.iContactListener.prototype.PreSolve = function ()\n{\n};\nBox2D.Dynamics.iContactListener.prototype.PostSolve = function ()\n{\n};\nBox2D.Dynamics.Contacts.b2CircleContact = function (a, b)\n{\n    Box2D.Dynamics.Contacts.b2Contact.call(this, a, b)\n};\ngoog.inherits(Box2D.Dynamics.Contacts.b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);\nBox2D.Dynamics.Contacts.b2CircleContact.prototype.Reset = function (a, b)\n{\n    Box2D.Dynamics.Contacts.b2Contact.prototype.Reset.call(this, a, b)\n};\nBox2D.Dynamics.Contacts.b2CircleContact.prototype.Evaluate = function ()\n{\n    var a = this.m_fixtureA.GetShape(), b = this.m_fixtureB.GetShape();\n    Box2D.Collision.b2Collision.CollideCircles(this.m_manifold, a, this.m_fixtureA.GetBody().m_xf, b, this.m_fixtureB.GetBody().m_xf)\n};\nBox2D.Dynamics.Contacts.b2EdgeAndCircleContact = function (a, b)\n{\n    Box2D.Dynamics.Contacts.b2Contact.call(this, a, b)\n};\ngoog.inherits(Box2D.Dynamics.Contacts.b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);\nBox2D.Dynamics.Contacts.b2EdgeAndCircleContact.prototype.Reset = function (a, b)\n{\n    Box2D.Dynamics.Contacts.b2Contact.prototype.Reset.call(this, a, b)\n};\nBox2D.Dynamics.Contacts.b2EdgeAndCircleContact.prototype.Evaluate = function ()\n{\n    this.m_fixtureA.GetBody();\n    this.m_fixtureB.GetBody();\n    this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape(), this.m_fixtureA.GetBody().m_xf, this.m_fixtureB.GetShape(), this.m_fixtureB.GetBody().m_xf)\n};\nBox2D.Dynamics.Contacts.b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function ()\n{\n};\nBox2D.Dynamics.Joints.b2FrictionJointDef = function ()\n{\n    Box2D.Dynamics.Joints.b2JointDef.call(this);\n    this.localAnchorA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localAnchorB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.type = Box2D.Dynamics.Joints.b2Joint.e_frictionJoint;\n    this.maxTorque = this.maxForce = 0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);\nBox2D.Dynamics.Joints.b2FrictionJointDef.prototype.Initialize = function (a, b, c)\n{\n    this.bodyA = a;\n    this.bodyB = b;\n    this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c));\n    this.localAnchorB.SetV(this.bodyB.GetLocalPoint(c))\n};\nBox2D.Dynamics.Joints.b2FrictionJointDef.prototype.Create = function ()\n{\n    return new Box2D.Dynamics.Joints.b2FrictionJoint(this)\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint = function (a)\n{\n    Box2D.Dynamics.Joints.b2Joint.call(this, a);\n    this.K = new Box2D.Common.Math.b2Mat22;\n    this.K1 = new Box2D.Common.Math.b2Mat22;\n    this.K2 = new Box2D.Common.Math.b2Mat22;\n    this.K3 = new Box2D.Common.Math.b2Mat22;\n    this.impulse3 = Box2D.Common.Math.b2Vec3.Get(0, 0, 0);\n    this.impulse2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.reduced = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_impulse = Box2D.Common.Math.b2Vec3.Get(0, 0, 0);\n    this.m_mass = new Box2D.Common.Math.b2Mat33;\n    this.m_localAnchor1.SetV(a.localAnchorA);\n    this.m_localAnchor2.SetV(a.localAnchorB);\n    this.m_referenceAngle = a.referenceAngle;\n    this.m_impulse.SetZero();\n    this.m_motorImpulse = 0;\n    this.m_lowerAngle = a.lowerAngle;\n    this.m_upperAngle = a.upperAngle;\n    this.m_maxMotorTorque = a.maxMotorTorque;\n    this.m_motorSpeed = a.motorSpeed;\n    this.m_enableLimit = a.enableLimit;\n    this.m_enableMotor = a.enableMotor;\n    this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;\n    this.m_motorMass = 0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetAnchorA = function ()\n{\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetAnchorB = function ()\n{\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetReactionForce = function (a)\n{\n    void 0 === a && (a = 0);\n    return Box2D.Common.Math.b2Vec2.Get(a * this.m_impulse.x, a * this.m_impulse.y)\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetReactionTorque = function (a)\n{\n    void 0 === a && (a = 0);\n    return a * this.m_impulse.z\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetJointAngle = function ()\n{\n    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetJointSpeed = function ()\n{\n    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.IsLimitEnabled = function ()\n{\n    return this.m_enableLimit\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.EnableLimit = function (a)\n{\n    this.m_enableLimit = a\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetLowerLimit = function ()\n{\n    return this.m_lowerAngle\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetUpperLimit = function ()\n{\n    return this.m_upperAngle\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.SetLimits = function (a, b)\n{\n    void 0 === a && (a = 0);\n    void 0 === b && (b = 0);\n    this.m_lowerAngle = a;\n    this.m_upperAngle = b\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.IsMotorEnabled = function ()\n{\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    return this.m_enableMotor\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.EnableMotor = function (a)\n{\n    this.m_enableMotor = a\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.SetMotorSpeed = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_bodyA.SetAwake(!0);\n    this.m_bodyB.SetAwake(!0);\n    this.m_motorSpeed = a\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetMotorSpeed = function ()\n{\n    return this.m_motorSpeed\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.SetMaxMotorTorque = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_maxMotorTorque = a\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.GetMotorTorque = function ()\n{\n    return this.m_maxMotorTorque\n};\n\n\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.InitVelocityConstraints = function (step)\n{\n    var bA = this.m_bodyA;\n    var bB = this.m_bodyB;\n    var tMat;\n    var tX = 0;\n    tMat = bA.m_xf.R;\n    var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;\n    var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;\n    tX = (tMat.col1.x * r1X + tMat.col2.x * r1Y);\n    r1Y = (tMat.col1.y * r1X + tMat.col2.y * r1Y);\n    r1X = tX;\n    tMat = bB.m_xf.R;\n    var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;\n    var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;\n    tX = (tMat.col1.x * r2X + tMat.col2.x * r2Y);\n    r2Y = (tMat.col1.y * r2X + tMat.col2.y * r2Y);\n    r2X = tX;\n    var m1 = bA.m_invMass;\n    var m2 = bB.m_invMass;\n    var i1 = bA.m_invI;\n    var i2 = bB.m_invI;\n    this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;\n    this.m_mass.col2.x = (-r1Y * r1X * i1) - r2Y * r2X * i2;\n    this.m_mass.col3.x = (-r1Y * i1) - r2Y * i2;\n    this.m_mass.col1.y = this.m_mass.col2.x;\n    this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;\n    this.m_mass.col3.y = r1X * i1 + r2X * i2;\n    this.m_mass.col1.z = this.m_mass.col3.x;\n    this.m_mass.col2.z = this.m_mass.col3.y;\n    this.m_mass.col3.z = i1 + i2;\n    if (i1 + i2 == 0)\n    {\n        this.m_motorMass = 0;\n    } else\n    {\n        this.m_motorMass = 0.01;//1.0 / (i1 + i2);\n    }\n    if (!this.m_enableMotor)\n    {\n        this.m_motorImpulse = 0.0;\n    }\n    if (this.m_enableLimit)\n    {\n        var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n        if (Math.abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Box2D.Common.b2Settings.b2_angularSlop)\n        {\n            this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_equalLimits;\n        } else if (jointAngle <= this.m_lowerAngle)\n        {\n            if (this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit)\n            {\n                this.m_impulse.z = 0.0;\n            }\n            this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit;\n        } else if (jointAngle >= this.m_upperAngle)\n        {\n            if (this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit)\n            {\n                this.m_impulse.z = 0.0;\n            }\n            this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit;\n        } else\n        {\n            this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;\n            this.m_impulse.z = 0.0;\n        }\n    } else\n    {\n        this.m_limitState = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit;\n    }\n    if (step.warmStarting)\n    {\n        this.m_impulse.x *= step.dtRatio;\n        this.m_impulse.y *= step.dtRatio;\n        this.m_motorImpulse *= step.dtRatio;\n        var PX = this.m_impulse.x;\n        var PY = this.m_impulse.y;\n        bA.m_linearVelocity.x -= m1 * PX;\n        bA.m_linearVelocity.y -= m1 * PY;\n        bA.m_angularVelocity -= i1 * ((r1X * PY - r1Y * PX) + this.m_motorImpulse + this.m_impulse.z);\n        bB.m_linearVelocity.x += m2 * PX;\n        bB.m_linearVelocity.y += m2 * PY;\n        bB.m_angularVelocity += i2 * ((r2X * PY - r2Y * PX) + this.m_motorImpulse + this.m_impulse.z);\n    } else\n    {\n        this.m_impulse.SetZero();\n        this.m_motorImpulse = 0.0;\n    }\n};\n\n\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.SolveVelocityConstraints = function (a)\n{\n    var b = this.m_bodyA, c = this.m_bodyB, d = 0, e = d = 0, f = 0, g = 0, h = 0, i = b.m_linearVelocity, j = b.m_angularVelocity, k = c.m_linearVelocity, l = c.m_angularVelocity, n = b.m_invMass, m = c.m_invMass, o = b.m_invI, p = c.m_invI;\n    this.m_enableMotor && this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_equalLimits && (e = this.m_motorMass * -(l - j - this.m_motorSpeed), f = this.m_motorImpulse, g = a.dt * this.m_maxMotorTorque, this.m_motorImpulse = Box2D.Common.Math.b2Math.Clamp(this.m_motorImpulse + e, -g, g), e = this.m_motorImpulse - f, j -= o * e, l += p * e);\n    if (this.m_enableLimit && this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit)\n    {\n        var a = b.m_xf.R, e = this.m_localAnchor1.x - b.m_sweep.localCenter.x, f = this.m_localAnchor1.y - b.m_sweep.localCenter.y, d = a.col1.x * e + a.col2.x * f, f = a.col1.y * e + a.col2.y * f, e = d, a = c.m_xf.R, g = this.m_localAnchor2.x - c.m_sweep.localCenter.x, h = this.m_localAnchor2.y - c.m_sweep.localCenter.y, d = a.col1.x * g + a.col2.x * h, h = a.col1.y * g + a.col2.y * h, g = d, a = k.x + -l * h - i.x - -j * f, q = k.y + l * g - i.y - j * e;\n        this.m_mass.Solve33(this.impulse3, -a, -q, -(l - j));\n        this.m_limitState == Box2D.Dynamics.Joints.b2Joint.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit ? (d = this.m_impulse.z + this.impulse3.z, 0 > d && (this.m_mass.Solve22(this.reduced, -a, -q), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0)) : this.m_limitState == Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit &&\n            (d = this.m_impulse.z + this.impulse3.z, 0 < d && (this.m_mass.Solve22(this.reduced, -a, -q), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0));\n        i.x -= n * this.impulse3.x;\n        i.y -= n * this.impulse3.y;\n        j -= o * (e * this.impulse3.y - f * this.impulse3.x + this.impulse3.z);\n        k.x += m * this.impulse3.x;\n        k.y += m * this.impulse3.y;\n        l += p * (g * this.impulse3.y - h * this.impulse3.x + this.impulse3.z)\n    } else\n    {\n        a = b.m_xf.R, e = this.m_localAnchor1.x - b.m_sweep.localCenter.x, f = this.m_localAnchor1.y - b.m_sweep.localCenter.y, d = a.col1.x * e + a.col2.x * f, f = a.col1.y * e + a.col2.y * f, e = d, a = c.m_xf.R, g = this.m_localAnchor2.x - c.m_sweep.localCenter.x, h = this.m_localAnchor2.y - c.m_sweep.localCenter.y, d = a.col1.x * g + a.col2.x * h, h = a.col1.y * g + a.col2.y * h, g = d, this.m_mass.Solve22(this.impulse2, -(k.x + -l * h - i.x - -j * f), -(k.y + l * g - i.y - j * e)), this.m_impulse.x +=\n            this.impulse2.x, this.m_impulse.y += this.impulse2.y, i.x -= n * this.impulse2.x, i.y -= n * this.impulse2.y, j -= o * (e * this.impulse2.y - f * this.impulse2.x), k.x += m * this.impulse2.x, k.y += m * this.impulse2.y, l += p * (g * this.impulse2.y - h * this.impulse2.x)\n    }\n    b.m_linearVelocity.SetV(i);\n    b.m_angularVelocity = j;\n    c.m_linearVelocity.SetV(k);\n    c.m_angularVelocity = l\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.prototype.SolvePositionConstraints = function ()\n{\n    var a = 0, b, c = this.m_bodyA, d = this.m_bodyB, e = 0, f = b = 0, g = 0, h = 0;\n    if (this.m_enableLimit && this.m_limitState != Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit)\n    {\n        var a = d.m_sweep.a - c.m_sweep.a - this.m_referenceAngle, i = 0;\n        this.m_limitState == Box2D.Dynamics.Joints.b2Joint.e_equalLimits ? (a = Box2D.Common.Math.b2Math.Clamp(a - this.m_lowerAngle, -Box2D.Common.b2Settings.b2_maxAngularCorrection, Box2D.Common.b2Settings.b2_maxAngularCorrection), i = -this.m_motorMass * a, e = Math.abs(a)) : this.m_limitState == Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit ? (a -= this.m_lowerAngle, e = -a, a = Box2D.Common.Math.b2Math.Clamp(a + Box2D.Common.b2Settings.b2_angularSlop, -Box2D.Common.b2Settings.b2_maxAngularCorrection,\n            0), i = -this.m_motorMass * a) : this.m_limitState == Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit && (e = a -= this.m_upperAngle, a = Box2D.Common.Math.b2Math.Clamp(a - Box2D.Common.b2Settings.b2_angularSlop, 0, Box2D.Common.b2Settings.b2_maxAngularCorrection), i = -this.m_motorMass * a);\n        c.m_sweep.a -= c.m_invI * i;\n        d.m_sweep.a += d.m_invI * i;\n        c.SynchronizeTransform();\n        d.SynchronizeTransform()\n    }\n    b = c.m_xf.R;\n    i = this.m_localAnchor1.x - c.m_sweep.localCenter.x;\n    a = this.m_localAnchor1.y - c.m_sweep.localCenter.y;\n    f = b.col1.x * i + b.col2.x * a;\n    a = b.col1.y * i + b.col2.y * a;\n    i = f;\n    b = d.m_xf.R;\n    var j = this.m_localAnchor2.x - d.m_sweep.localCenter.x, k = this.m_localAnchor2.y - d.m_sweep.localCenter.y, f = b.col1.x * j + b.col2.x * k, k = b.col1.y * j + b.col2.y * k, j = f, g = d.m_sweep.c.x + j - c.m_sweep.c.x - i, h = d.m_sweep.c.y + k - c.m_sweep.c.y - a, l = g * g + h * h;\n    b = Math.sqrt(l);\n    var f = c.m_invMass, n = d.m_invMass, m = c.m_invI, o = d.m_invI, p = 10 * Box2D.Common.b2Settings.b2_linearSlop;\n    l > p * p && (l = 1 / (f + n), g = l * -g, h = l * -h, c.m_sweep.c.x -= 0.5 * f * g, c.m_sweep.c.y -= 0.5 * f * h, d.m_sweep.c.x += 0.5 * n * g, d.m_sweep.c.y += 0.5 * n * h, g = d.m_sweep.c.x + j - c.m_sweep.c.x - i, h = d.m_sweep.c.y + k - c.m_sweep.c.y - a);\n    this.K1.col1.x = f + n;\n    this.K1.col2.x = 0;\n    this.K1.col1.y = 0;\n    this.K1.col2.y = f + n;\n    this.K2.col1.x = m * a * a;\n    this.K2.col2.x = -m * i * a;\n    this.K2.col1.y = -m * i * a;\n    this.K2.col2.y = m * i * i;\n    this.K3.col1.x = o * k * k;\n    this.K3.col2.x = -o * j * k;\n    this.K3.col1.y = -o * j * k;\n    this.K3.col2.y = o * j * j;\n    this.K.SetM(this.K1);\n    this.K.AddM(this.K2);\n    this.K.AddM(this.K3);\n    this.K.Solve(Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse, -g, -h);\n    g = Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse.x;\n    h = Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse.y;\n    c.m_sweep.c.x -= c.m_invMass * g;\n    c.m_sweep.c.y -= c.m_invMass * h;\n    c.m_sweep.a -= c.m_invI * (i * h - a * g);\n    d.m_sweep.c.x += d.m_invMass * g;\n    d.m_sweep.c.y += d.m_invMass * h;\n    d.m_sweep.a += d.m_invI * (j * h - k * g);\n    c.SynchronizeTransform();\n    d.SynchronizeTransform();\n    return b <= Box2D.Common.b2Settings.b2_linearSlop && e <= Box2D.Common.b2Settings.b2_angularSlop\n};\nBox2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = Box2D.Common.Math.b2Vec2.Get(0, 0);\nBox2D.Dynamics.Joints.b2RevoluteJointDef = function ()\n{\n    Box2D.Dynamics.Joints.b2JointDef.call(this);\n    this.localAnchorA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localAnchorB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.type = Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint;\n    this.localAnchorA.SetZero();\n    this.localAnchorB.SetZero();\n    this.motorSpeed = this.maxMotorTorque = this.upperAngle = this.lowerAngle = this.referenceAngle = 0;\n    this.enableMotor = this.enableLimit = !1\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);\nBox2D.Dynamics.Joints.b2RevoluteJointDef.prototype.Initialize = function (a, b, c)\n{\n    this.bodyA = a;\n    this.bodyB = b;\n    this.localAnchorA = this.bodyA.GetLocalPoint(c);\n    this.localAnchorB = this.bodyB.GetLocalPoint(c);\n    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()\n};\nBox2D.Dynamics.Joints.b2RevoluteJointDef.prototype.Create = function ()\n{\n    return new Box2D.Dynamics.Joints.b2RevoluteJoint(this)\n};\nBox2D.Dynamics.Contacts.b2PositionSolverManifold = function ()\n{\n    this.m_normal = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_separations = [];\n    this.m_points = [];\n    for (var a = 0; a < Box2D.Common.b2Settings.b2_maxManifoldPoints; a++)\n    {\n        this.m_points[a] = Box2D.Common.Math.b2Vec2.Get(0, 0)\n    }\n};\nBox2D.Dynamics.Contacts.b2PositionSolverManifold.prototype.Initialize = function (a)\n{\n    Box2D.Common.b2Settings.b2Assert(0 < a.pointCount);\n    switch (a.type)\n    {\n        case Box2D.Collision.b2Manifold.e_circles:\n            this._InitializeCircles(a);\n            break;\n        case Box2D.Collision.b2Manifold.e_faceA:\n            this._InitializeFaceA(a);\n            break;\n        case Box2D.Collision.b2Manifold.e_faceB:\n            this._InitializeFaceB(a)\n    }\n};\nBox2D.Dynamics.Contacts.b2PositionSolverManifold.prototype._InitializeCircles = function (a)\n{\n    var b = a.bodyA.m_xf.R, c = a.localPoint, d = a.bodyA.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y), e = a.bodyA.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y), b = a.bodyB.m_xf.R, c = a.points[0].localPoint, f = a.bodyB.m_xf.position.x + (b.col1.x * c.x + b.col2.x * c.y), b = a.bodyB.m_xf.position.y + (b.col1.y * c.x + b.col2.y * c.y), c = f - d, g = b - e, h = c * c + g * g;\n    h > Box2D.Common.b2Settings.MIN_VALUE_SQUARED ? (h = Math.sqrt(h), this.m_normal.x = c / h, this.m_normal.y = g / h) : (this.m_normal.x = 1, this.m_normal.y = 0);\n    this.m_points[0].x = 0.5 * (d + f);\n    this.m_points[0].y = 0.5 * (e + b);\n    this.m_separations[0] = c * this.m_normal.x + g * this.m_normal.y - a.radius\n};\nBox2D.Dynamics.Contacts.b2PositionSolverManifold.prototype._InitializeFaceA = function (a)\n{\n    this.m_normal.x = a.bodyA.m_xf.R.col1.x * a.localPlaneNormal.x + a.bodyA.m_xf.R.col2.x * a.localPlaneNormal.y;\n    this.m_normal.y = a.bodyA.m_xf.R.col1.y * a.localPlaneNormal.x + a.bodyA.m_xf.R.col2.y * a.localPlaneNormal.y;\n    for (var b = a.bodyA.m_xf.position.x + (a.bodyA.m_xf.R.col1.x * a.localPoint.x + a.bodyA.m_xf.R.col2.x * a.localPoint.y), c = a.bodyA.m_xf.position.y + (a.bodyA.m_xf.R.col1.y * a.localPoint.x + a.bodyA.m_xf.R.col2.y * a.localPoint.y), d = 0; d < a.pointCount; d++)\n    {\n        var e = a.bodyB.m_xf.position.x + (a.bodyB.m_xf.R.col1.x * a.points[d].localPoint.x + a.bodyB.m_xf.R.col2.x * a.points[d].localPoint.y), f = a.bodyB.m_xf.position.y + (a.bodyB.m_xf.R.col1.y * a.points[d].localPoint.x + a.bodyB.m_xf.R.col2.y * a.points[d].localPoint.y);\n        this.m_separations[d] = (e - b) * this.m_normal.x + (f - c) * this.m_normal.y - a.radius;\n        this.m_points[d].x = e;\n        this.m_points[d].y = f\n    }\n};\nBox2D.Dynamics.Contacts.b2PositionSolverManifold.prototype._InitializeFaceB = function (a)\n{\n    this.m_normal.x = a.bodyB.m_xf.R.col1.x * a.localPlaneNormal.x + a.bodyB.m_xf.R.col2.x * a.localPlaneNormal.y;\n    this.m_normal.y = a.bodyB.m_xf.R.col1.y * a.localPlaneNormal.x + a.bodyB.m_xf.R.col2.y * a.localPlaneNormal.y;\n    for (var b = a.bodyB.m_xf.position.x + (a.bodyB.m_xf.R.col1.x * a.localPoint.x + a.bodyB.m_xf.R.col2.x * a.localPoint.y), c = a.bodyB.m_xf.position.y + (a.bodyB.m_xf.R.col1.y * a.localPoint.x + a.bodyB.m_xf.R.col2.y * a.localPoint.y), d = 0; d < a.pointCount; d++)\n    {\n        var e = a.bodyA.m_xf.position.x + (a.bodyA.m_xf.R.col1.x * a.points[d].localPoint.x + a.bodyA.m_xf.R.col2.x * a.points[d].localPoint.y), f = a.bodyA.m_xf.position.y + (a.bodyA.m_xf.R.col1.y * a.points[d].localPoint.x + a.bodyA.m_xf.R.col2.y * a.points[d].localPoint.y);\n        this.m_separations[d] = (e - b) * this.m_normal.x + (f - c) * this.m_normal.y - a.radius;\n        this.m_points[d].Set(e, f)\n    }\n    this.m_normal.x *= -1;\n    this.m_normal.y *= -1\n};\nBox2D.Dynamics.Contacts.b2PolyAndCircleContact = function (a, b)\n{\n    Box2D.Common.b2Settings.b2Assert(a.GetShape() instanceof Box2D.Collision.Shapes.b2PolygonShape);\n    Box2D.Common.b2Settings.b2Assert(b.GetShape() instanceof Box2D.Collision.Shapes.b2CircleShape);\n    Box2D.Dynamics.Contacts.b2Contact.call(this, a, b)\n};\ngoog.inherits(Box2D.Dynamics.Contacts.b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);\nBox2D.Dynamics.Contacts.b2PolyAndCircleContact.prototype.Reset = function (a, b)\n{\n    Box2D.Common.b2Settings.b2Assert(a.GetShape() instanceof Box2D.Collision.Shapes.b2PolygonShape);\n    Box2D.Common.b2Settings.b2Assert(b.GetShape() instanceof Box2D.Collision.Shapes.b2CircleShape);\n    Box2D.Dynamics.Contacts.b2Contact.prototype.Reset.call(this, a, b)\n};\nBox2D.Dynamics.Contacts.b2PolyAndCircleContact.prototype.Evaluate = function ()\n{\n    var a = this.m_fixtureA.GetShape(), b = this.m_fixtureB.GetShape();\n    Box2D.Collision.b2Collision.CollidePolygonAndCircle(this.m_manifold, a, this.m_fixtureA.GetBody().m_xf, b, this.m_fixtureB.GetBody().m_xf)\n};\nBox2D.Dynamics.Contacts.b2ContactConstraintPoint = function ()\n{\n\n    this.localPoint = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.rA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.rB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.tangentImpulse = this.normalImpulse = 0\n};\nBox2D.Dynamics.Contacts.b2ContactConstraintPoint.prototype.Reset = function ()\n{\n    this.localPoint.Set(0, 0);\n    this.rA.Set(0, 0);\n    this.rB.Set(0, 0);\n    this.tangentImpulse = this.normalImpulse = 0\n};\nBox2D.Dynamics.Contacts.b2ContactConstraint = function ()\n{\n\n    this.localPlaneNormal = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localPoint = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.normal = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.normalMass = new Box2D.Common.Math.b2Mat22;\n    this.K = new Box2D.Common.Math.b2Mat22;\n    this.points = [];\n    for (var a = 0; a < Box2D.Common.b2Settings.b2_maxManifoldPoints; a++)\n    {\n        this.points[a] = new Box2D.Dynamics.Contacts.b2ContactConstraintPoint\n    }\n};\nBox2D.Dynamics.b2FixtureList = function ()\n{\n\n    this.fixtureLastNode = this.fixtureFirstNode = null;\n    this.fixtureNodeLookup = {};\n    this.fixtureCount = 0\n};\nBox2D.Dynamics.b2FixtureList.prototype.GetFirstNode = function ()\n{\n    return this.fixtureFirstNode\n};\nBox2D.Dynamics.b2FixtureList.prototype.AddFixture = function (a)\n{\n    var b = a.ID;\n    if (null == this.fixtureNodeLookup[b])\n    {\n        var a = new Box2D.Dynamics.b2FixtureListNode(a), c = this.fixtureLastNode;\n        null != c ? c.SetNextNode(a) : this.fixtureFirstNode = a;\n        a.SetPreviousNode(c);\n        this.fixtureLastNode = a;\n        this.fixtureNodeLookup[b] = a;\n        this.fixtureCount++\n    }\n};\nBox2D.Dynamics.b2FixtureList.prototype.RemoveFixture = function (a)\n{\n    var a = a.ID, b = this.fixtureNodeLookup[a];\n    if (null != b)\n    {\n        var c = b.GetPreviousNode(), b = b.GetNextNode();\n        null == c ? this.fixtureFirstNode = b : c.SetNextNode(b);\n        null == b ? this.fixtureLastNode = c : b.SetPreviousNode(c);\n        delete this.fixtureNodeLookup[a];\n        this.fixtureCount--\n    }\n};\nBox2D.Dynamics.b2FixtureList.prototype.GetFixtureCount = function ()\n{\n    return this.fixtureCount\n};\nBox2D.Dynamics.Joints.b2Jacobian = function ()\n{\n    this.linearA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.linearB = Box2D.Common.Math.b2Vec2.Get(0, 0)\n};\nBox2D.Dynamics.Joints.b2Jacobian.prototype.SetZero = function ()\n{\n    this.linearA.SetZero();\n    this.angularA = 0;\n    this.linearB.SetZero();\n    this.angularB = 0\n};\nBox2D.Dynamics.Joints.b2Jacobian.prototype.Set = function (a, b, c, d)\n{\n    void 0 === b && (b = 0);\n    void 0 === d && (d = 0);\n    this.linearA.SetV(a);\n    this.angularA = b;\n    this.linearB.SetV(c);\n    this.angularB = d\n};\nBox2D.Dynamics.Joints.b2Jacobian.prototype.Compute = function (a, b, c, d)\n{\n    void 0 === b && (b = 0);\n    void 0 === d && (d = 0);\n    return this.linearA.x * a.x + this.linearA.y * a.y + this.angularA * b + (this.linearB.x * c.x + this.linearB.y * c.y) + this.angularB * d\n};\nBox2D.Dynamics.Joints.b2GearJoint = function (a)\n{\n    Box2D.Dynamics.Joints.b2Joint.call(this, a);\n    this.m_groundAnchor1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_groundAnchor2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_J = new Box2D.Dynamics.Joints.b2Jacobian;\n    var b = a.joint1.m_type, c = a.joint2.m_type;\n    this.m_prismatic2 = this.m_revolute2 = this.m_prismatic1 = this.m_revolute1 = null;\n    var d = 0, e = 0;\n    this.m_ground1 = a.joint1.GetBodyA();\n    this.m_bodyA = a.joint1.GetBodyB();\n    b == Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint ? (this.m_revolute1 = a.joint1, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), d = this.m_revolute1.GetJointAngle()) : (this.m_prismatic1 = a.joint1, this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), d = this.m_prismatic1.GetJointTranslation());\n    this.m_ground2 = a.joint2.GetBodyA();\n    this.m_bodyB = a.joint2.GetBodyB();\n    c == Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint ? (this.m_revolute2 = a.joint2, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), e = this.m_revolute2.GetJointAngle()) : (this.m_prismatic2 = a.joint2, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), e = this.m_prismatic2.GetJointTranslation());\n    this.m_ratio = a.ratio;\n    this.m_constant = d + this.m_ratio * e;\n    this.m_impulse = 0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2GearJoint, Box2D.Dynamics.Joints.b2Joint);\nBox2D.Dynamics.Joints.b2GearJoint.prototype.GetAnchorA = function ()\n{\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)\n};\nBox2D.Dynamics.Joints.b2GearJoint.prototype.GetAnchorB = function ()\n{\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)\n};\nBox2D.Dynamics.Joints.b2GearJoint.prototype.GetReactionForce = function (a)\n{\n    void 0 === a && (a = 0);\n    return Box2D.Common.Math.b2Vec2.Get(a * this.m_impulse * this.m_J.linearB.x, a * this.m_impulse * this.m_J.linearB.y)\n};\nBox2D.Dynamics.Joints.b2GearJoint.prototype.GetReactionTorque = function (a)\n{\n    void 0 === a && (a = 0);\n    var b = this.m_bodyB.m_xf.R, c = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x, d = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y, e = b.col1.x * c + b.col2.x * d, d = b.col1.y * c + b.col2.y * d;\n    return a * (this.m_impulse * this.m_J.angularB - e * this.m_impulse * this.m_J.linearB.y + d * this.m_impulse * this.m_J.linearB.x)\n};\nBox2D.Dynamics.Joints.b2GearJoint.prototype.GetRatio = function ()\n{\n    return this.m_ratio\n};\nBox2D.Dynamics.Joints.b2GearJoint.prototype.SetRatio = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_ratio = a\n};\nBox2D.Dynamics.Joints.b2GearJoint.prototype.InitVelocityConstraints = function (a)\n{\n    var b = this.m_ground1, c = this.m_ground2, d = this.m_bodyA, e = this.m_bodyB, f = 0, g = 0, h = 0, i = 0, j = h = 0, k = 0;\n    this.m_J.SetZero();\n    this.m_revolute1 ? (this.m_J.angularA = -1, k += d.m_invI) : (b = b.m_xf.R, g = this.m_prismatic1.m_localXAxis1, f = b.col1.x * g.x + b.col2.x * g.y, g = b.col1.y * g.x + b.col2.y * g.y, b = d.m_xf.R, h = this.m_localAnchor1.x - d.m_sweep.localCenter.x, i = this.m_localAnchor1.y - d.m_sweep.localCenter.y, j = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = j * g - i * f, this.m_J.linearA.Set(-f, -g), this.m_J.angularA = -h, k += d.m_invMass + d.m_invI * h * h);\n    this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, k += this.m_ratio * this.m_ratio * e.m_invI) : (b = c.m_xf.R, g = this.m_prismatic2.m_localXAxis1, f = b.col1.x * g.x + b.col2.x * g.y, g = b.col1.y * g.x + b.col2.y * g.y, b = e.m_xf.R, h = this.m_localAnchor2.x - e.m_sweep.localCenter.x, i = this.m_localAnchor2.y - e.m_sweep.localCenter.y, j = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = j * g - i * f, this.m_J.linearB.Set(-this.m_ratio * f, -this.m_ratio * g), this.m_J.angularB =\n        -this.m_ratio * h, k += this.m_ratio * this.m_ratio * (e.m_invMass + e.m_invI * h * h));\n    this.m_mass = 0 < k ? 1 / k : 0;\n    a.warmStarting ? (d.m_linearVelocity.x += d.m_invMass * this.m_impulse * this.m_J.linearA.x, d.m_linearVelocity.y += d.m_invMass * this.m_impulse * this.m_J.linearA.y, d.m_angularVelocity += d.m_invI * this.m_impulse * this.m_J.angularA, e.m_linearVelocity.x += e.m_invMass * this.m_impulse * this.m_J.linearB.x, e.m_linearVelocity.y += e.m_invMass * this.m_impulse * this.m_J.linearB.y, e.m_angularVelocity += e.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0\n};\nBox2D.Dynamics.Joints.b2GearJoint.prototype.SolveVelocityConstraints = function ()\n{\n    var a = this.m_bodyA, b = this.m_bodyB, c = -this.m_mass * this.m_J.Compute(a.m_linearVelocity, a.m_angularVelocity, b.m_linearVelocity, b.m_angularVelocity);\n    this.m_impulse += c;\n    a.m_linearVelocity.x += a.m_invMass * c * this.m_J.linearA.x;\n    a.m_linearVelocity.y += a.m_invMass * c * this.m_J.linearA.y;\n    a.m_angularVelocity += a.m_invI * c * this.m_J.angularA;\n    b.m_linearVelocity.x += b.m_invMass * c * this.m_J.linearB.x;\n    b.m_linearVelocity.y += b.m_invMass * c * this.m_J.linearB.y;\n    b.m_angularVelocity += b.m_invI * c * this.m_J.angularB\n};\nBox2D.Dynamics.Joints.b2GearJoint.prototype.SolvePositionConstraints = function ()\n{\n    var a = this.m_bodyA, b = this.m_bodyB, c = 0, d = 0, c = this.m_revolute1 ? this.m_revolute1.GetJointAngle() : this.m_prismatic1.GetJointTranslation(), d = this.m_revolute2 ? this.m_revolute2.GetJointAngle() : this.m_prismatic2.GetJointTranslation(), c = -this.m_mass * (this.m_constant - (c + this.m_ratio * d));\n    a.m_sweep.c.x += a.m_invMass * c * this.m_J.linearA.x;\n    a.m_sweep.c.y += a.m_invMass * c * this.m_J.linearA.y;\n    a.m_sweep.a += a.m_invI * c * this.m_J.angularA;\n    b.m_sweep.c.x += b.m_invMass * c * this.m_J.linearB.x;\n    b.m_sweep.c.y += b.m_invMass * c * this.m_J.linearB.y;\n    b.m_sweep.a += b.m_invI * c * this.m_J.angularB;\n    a.SynchronizeTransform();\n    b.SynchronizeTransform();\n    return 0 < Box2D.Common.b2Settings.b2_linearSlop\n};\nBox2D.Dynamics.Joints.b2GearJointDef = function ()\n{\n    Box2D.Dynamics.Joints.b2JointDef.call(this);\n    this.type = Box2D.Dynamics.Joints.b2Joint.e_gearJoint;\n    this.joint2 = this.joint1 = null;\n    this.ratio = 1\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);\nBox2D.Dynamics.Joints.b2GearJointDef.prototype.Initialize = function (a, b, c)\n{\n    this.joint1 = a;\n    this.bodyA = a.GetBodyA();\n    this.joint2 = b;\n    this.bodyB = b.GetBodyA();\n    this.ratio = c\n};\nBox2D.Dynamics.Joints.b2GearJointDef.prototype.Create = function ()\n{\n    return new Box2D.Dynamics.Joints.b2GearJoint(this)\n};\nBox2D.Dynamics.Joints.b2PulleyJoint = function (a)\n{\n    Box2D.Dynamics.Joints.b2Joint.call(this, a);\n    this.m_groundAnchor1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_groundAnchor2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_u1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_u2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_ground = this.m_bodyA.m_world.m_groundBody;\n    this.m_groundAnchor1.x = a.groundAnchorA.x - this.m_ground.m_xf.position.x;\n    this.m_groundAnchor1.y = a.groundAnchorA.y - this.m_ground.m_xf.position.y;\n    this.m_groundAnchor2.x = a.groundAnchorB.x - this.m_ground.m_xf.position.x;\n    this.m_groundAnchor2.y = a.groundAnchorB.y - this.m_ground.m_xf.position.y;\n    this.m_localAnchor1.SetV(a.localAnchorA);\n    this.m_localAnchor2.SetV(a.localAnchorB);\n    this.m_ratio = a.ratio;\n    this.m_constant = a.lengthA + this.m_ratio * a.lengthB;\n    this.m_maxLength1 = Math.min(a.maxLengthA, this.m_constant - this.m_ratio * Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength);\n    this.m_maxLength2 = Math.min(a.maxLengthB, (this.m_constant - Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);\n    this.m_limitImpulse2 = this.m_limitImpulse1 = this.m_impulse = 0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.GetAnchorA = function ()\n{\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.GetAnchorB = function ()\n{\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.GetReactionForce = function (a)\n{\n    void 0 === a && (a = 0);\n    return Box2D.Common.Math.b2Vec2.Get(a * this.m_impulse * this.m_u2.x, a * this.m_impulse * this.m_u2.y)\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.GetReactionTorque = function ()\n{\n    return 0\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.GetGroundAnchorA = function ()\n{\n    var a = this.m_ground.m_xf.position.Copy();\n    a.Add(this.m_groundAnchor1);\n    return a\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.GetGroundAnchorB = function ()\n{\n    var a = this.m_ground.m_xf.position.Copy();\n    a.Add(this.m_groundAnchor2);\n    return a\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.GetLength1 = function ()\n{\n    var a = this.m_bodyA.GetWorldPoint(this.m_localAnchor1), b = a.x - (this.m_ground.m_xf.position.x + this.m_groundAnchor1.x), a = a.y - (this.m_ground.m_xf.position.y + this.m_groundAnchor1.y);\n    return Math.sqrt(b * b + a * a)\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.GetLength2 = function ()\n{\n    var a = this.m_bodyB.GetWorldPoint(this.m_localAnchor2), b = a.x - (this.m_ground.m_xf.position.x + this.m_groundAnchor2.x), a = a.y - (this.m_ground.m_xf.position.y + this.m_groundAnchor2.y);\n    return Math.sqrt(b * b + a * a)\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.GetRatio = function ()\n{\n    return this.m_ratio\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.InitVelocityConstraints = function (a)\n{\n    var b = this.m_bodyA, c = this.m_bodyB, d;\n    d = b.m_xf.R;\n    var e = this.m_localAnchor1.x - b.m_sweep.localCenter.x, f = this.m_localAnchor1.y - b.m_sweep.localCenter.y, g = d.col1.x * e + d.col2.x * f, f = d.col1.y * e + d.col2.y * f, e = g;\n    d = c.m_xf.R;\n    var h = this.m_localAnchor2.x - c.m_sweep.localCenter.x, i = this.m_localAnchor2.y - c.m_sweep.localCenter.y, g = d.col1.x * h + d.col2.x * i, i = d.col1.y * h + d.col2.y * i, h = g;\n    d = c.m_sweep.c.x + h;\n    var g = c.m_sweep.c.y + i, j = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, k = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;\n    this.m_u1.Set(b.m_sweep.c.x + e - (this.m_ground.m_xf.position.x + this.m_groundAnchor1.x), b.m_sweep.c.y + f - (this.m_ground.m_xf.position.y + this.m_groundAnchor1.y));\n    this.m_u2.Set(d - j, g - k);\n    d = this.m_u1.Length();\n    g = this.m_u2.Length();\n    d > Box2D.Common.b2Settings.b2_linearSlop ? this.m_u1.Multiply(1 / d) : this.m_u1.SetZero();\n    g > Box2D.Common.b2Settings.b2_linearSlop ? this.m_u2.Multiply(1 / g) : this.m_u2.SetZero();\n    0 < this.m_constant - d - this.m_ratio * g ? (this.m_state = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit, this.m_impulse = 0) : this.m_state = Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit;\n    d < this.m_maxLength1 ? (this.m_limitState1 = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit;\n    g < this.m_maxLength2 ? (this.m_limitState2 = Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit;\n    d = e * this.m_u1.y - f * this.m_u1.x;\n    g = h * this.m_u2.y - i * this.m_u2.x;\n    this.m_limitMass1 = b.m_invMass + b.m_invI * d * d;\n    this.m_limitMass2 = c.m_invMass + c.m_invI * g * g;\n    this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;\n    this.m_limitMass1 = 1 / this.m_limitMass1;\n    this.m_limitMass2 = 1 / this.m_limitMass2;\n    this.m_pulleyMass = 1 / this.m_pulleyMass;\n    a.warmStarting ? (this.m_impulse *= a.dtRatio, this.m_limitImpulse1 *= a.dtRatio, this.m_limitImpulse2 *= a.dtRatio, a = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x, d = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y, g = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x, j = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y, b.m_linearVelocity.x += b.m_invMass * a, b.m_linearVelocity.y += b.m_invMass * d, b.m_angularVelocity += b.m_invI *\n        (e * d - f * a), c.m_linearVelocity.x += c.m_invMass * g, c.m_linearVelocity.y += c.m_invMass * j, c.m_angularVelocity += c.m_invI * (h * j - i * g)) : this.m_limitImpulse2 = this.m_limitImpulse1 = this.m_impulse = 0\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.SolveVelocityConstraints = function ()\n{\n    var a = this.m_bodyA, b = this.m_bodyB, c;\n    c = a.m_xf.R;\n    var d = this.m_localAnchor1.x - a.m_sweep.localCenter.x, e = this.m_localAnchor1.y - a.m_sweep.localCenter.y, f = c.col1.x * d + c.col2.x * e, e = c.col1.y * d + c.col2.y * e, d = f;\n    c = b.m_xf.R;\n    var g = this.m_localAnchor2.x - b.m_sweep.localCenter.x, h = this.m_localAnchor2.y - b.m_sweep.localCenter.y, f = c.col1.x * g + c.col2.x * h, h = c.col1.y * g + c.col2.y * h, g = f, i = f = c = 0, j = 0;\n    c = j = c = j = i = f = c = 0;\n    this.m_state == Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit && (c = a.m_linearVelocity.x + -a.m_angularVelocity * e, f = a.m_linearVelocity.y + a.m_angularVelocity * d, i = b.m_linearVelocity.x + -b.m_angularVelocity * h, j = b.m_linearVelocity.y + b.m_angularVelocity * g, c = -(this.m_u1.x * c + this.m_u1.y * f) - this.m_ratio * (this.m_u2.x * i + this.m_u2.y * j), j = this.m_pulleyMass * -c, c = this.m_impulse, this.m_impulse = Math.max(0, this.m_impulse + j), j = this.m_impulse - c, c = -j *\n        this.m_u1.x, f = -j * this.m_u1.y, i = -this.m_ratio * j * this.m_u2.x, j = -this.m_ratio * j * this.m_u2.y, a.m_linearVelocity.x += a.m_invMass * c, a.m_linearVelocity.y += a.m_invMass * f, a.m_angularVelocity += a.m_invI * (d * f - e * c), b.m_linearVelocity.x += b.m_invMass * i, b.m_linearVelocity.y += b.m_invMass * j, b.m_angularVelocity += b.m_invI * (g * j - h * i));\n    this.m_limitState1 == Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit && (c = a.m_linearVelocity.x + -a.m_angularVelocity * e, f = a.m_linearVelocity.y + a.m_angularVelocity * d, c = -(this.m_u1.x * c + this.m_u1.y * f), j = -this.m_limitMass1 * c, c = this.m_limitImpulse1, this.m_limitImpulse1 = Math.max(0, this.m_limitImpulse1 + j), j = this.m_limitImpulse1 - c, c = -j * this.m_u1.x, f = -j * this.m_u1.y, a.m_linearVelocity.x += a.m_invMass * c, a.m_linearVelocity.y += a.m_invMass * f, a.m_angularVelocity +=\n        a.m_invI * (d * f - e * c));\n    this.m_limitState2 == Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit && (i = b.m_linearVelocity.x + -b.m_angularVelocity * h, j = b.m_linearVelocity.y + b.m_angularVelocity * g, c = -(this.m_u2.x * i + this.m_u2.y * j), j = -this.m_limitMass2 * c, c = this.m_limitImpulse2, this.m_limitImpulse2 = Math.max(0, this.m_limitImpulse2 + j), j = this.m_limitImpulse2 - c, i = -j * this.m_u2.x, j = -j * this.m_u2.y, b.m_linearVelocity.x += b.m_invMass * i, b.m_linearVelocity.y += b.m_invMass * j, b.m_angularVelocity +=\n        b.m_invI * (g * j - h * i))\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.prototype.SolvePositionConstraints = function ()\n{\n    var a = this.m_bodyA, b = this.m_bodyB, c, d = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x, e = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y, f = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, g = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y, h = 0, i = 0, j = 0, k = 0, l = c = 0, n = 0, m = 0, o = l = m = c = l = c = 0;\n    this.m_state == Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit && (c = a.m_xf.R, h = this.m_localAnchor1.x - a.m_sweep.localCenter.x, i = this.m_localAnchor1.y - a.m_sweep.localCenter.y, l = c.col1.x * h + c.col2.x * i, i = c.col1.y * h + c.col2.y * i, h = l, c = b.m_xf.R, j = this.m_localAnchor2.x - b.m_sweep.localCenter.x, k = this.m_localAnchor2.y - b.m_sweep.localCenter.y, l = c.col1.x * j + c.col2.x * k, k = c.col1.y * j + c.col2.y * k, j = l, c = a.m_sweep.c.x + h, l = a.m_sweep.c.y + i, n =\n        b.m_sweep.c.x + j, m = b.m_sweep.c.y + k, this.m_u1.Set(c - d, l - e), this.m_u2.Set(n - f, m - g), c = this.m_u1.Length(), l = this.m_u2.Length(), c > Box2D.Common.b2Settings.b2_linearSlop ? this.m_u1.Multiply(1 / c) : this.m_u1.SetZero(), l > Box2D.Common.b2Settings.b2_linearSlop ? this.m_u2.Multiply(1 / l) : this.m_u2.SetZero(), c = this.m_constant - c - this.m_ratio * l, o = Math.max(o, -c), c = Box2D.Common.Math.b2Math.Clamp(c + Box2D.Common.b2Settings.b2_linearSlop, -Box2D.Common.b2Settings.b2_maxLinearCorrection,\n        0), m = -this.m_pulleyMass * c, c = -m * this.m_u1.x, l = -m * this.m_u1.y, n = -this.m_ratio * m * this.m_u2.x, m = -this.m_ratio * m * this.m_u2.y, a.m_sweep.c.x += a.m_invMass * c, a.m_sweep.c.y += a.m_invMass * l, a.m_sweep.a += a.m_invI * (h * l - i * c), b.m_sweep.c.x += b.m_invMass * n, b.m_sweep.c.y += b.m_invMass * m, b.m_sweep.a += b.m_invI * (j * m - k * n), a.SynchronizeTransform(), b.SynchronizeTransform());\n    this.m_limitState1 == Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit && (c = a.m_xf.R, h = this.m_localAnchor1.x - a.m_sweep.localCenter.x, i = this.m_localAnchor1.y - a.m_sweep.localCenter.y, l = c.col1.x * h + c.col2.x * i, i = c.col1.y * h + c.col2.y * i, h = l, c = a.m_sweep.c.x + h, l = a.m_sweep.c.y + i, this.m_u1.Set(c - d, l - e), c = this.m_u1.Length(), c > Box2D.Common.b2Settings.b2_linearSlop ? (this.m_u1.x *= 1 / c, this.m_u1.y *= 1 / c) : this.m_u1.SetZero(), c = this.m_maxLength1 -\n        c, o = Math.max(o, -c), c = Box2D.Common.Math.b2Math.Clamp(c + Box2D.Common.b2Settings.b2_linearSlop, -Box2D.Common.b2Settings.b2_maxLinearCorrection, 0), m = -this.m_limitMass1 * c, c = -m * this.m_u1.x, l = -m * this.m_u1.y, a.m_sweep.c.x += a.m_invMass * c, a.m_sweep.c.y += a.m_invMass * l, a.m_sweep.a += a.m_invI * (h * l - i * c), a.SynchronizeTransform());\n    this.m_limitState2 == Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit && (c = b.m_xf.R, j = this.m_localAnchor2.x - b.m_sweep.localCenter.x, k = this.m_localAnchor2.y - b.m_sweep.localCenter.y, l = c.col1.x * j + c.col2.x * k, k = c.col1.y * j + c.col2.y * k, j = l, n = b.m_sweep.c.x + j, m = b.m_sweep.c.y + k, this.m_u2.Set(n - f, m - g), l = this.m_u2.Length(), l > Box2D.Common.b2Settings.b2_linearSlop ? (this.m_u2.x *= 1 / l, this.m_u2.y *= 1 / l) : this.m_u2.SetZero(), c = this.m_maxLength2 -\n        l, o = Math.max(o, -c), c = Box2D.Common.Math.b2Math.Clamp(c + Box2D.Common.b2Settings.b2_linearSlop, -Box2D.Common.b2Settings.b2_maxLinearCorrection, 0), m = -this.m_limitMass2 * c, n = -m * this.m_u2.x, m = -m * this.m_u2.y, b.m_sweep.c.x += b.m_invMass * n, b.m_sweep.c.y += b.m_invMass * m, b.m_sweep.a += b.m_invI * (j * m - k * n), b.SynchronizeTransform());\n    return o < Box2D.Common.b2Settings.b2_linearSlop\n};\nBox2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 1;\nBox2D.Dynamics.b2ContactImpulse = function ()\n{\n\n    this.normalImpulses = [];\n    this.tangentImpulses = []\n};\nBox2D.Dynamics.b2ContactImpulse.prototype.Reset = function ()\n{\n    this.normalImpulses = [];\n    this.tangentImpulses = []\n};\nBox2D.Dynamics.Contacts.b2ContactListNode = function (a)\n{\n    this.contact = a;\n    this.previous = this.next = null\n};\nBox2D.Dynamics.Contacts.b2ContactListNode.freeNodes = [];\nBox2D.Dynamics.Contacts.b2ContactListNode.GetNode = function (a)\n{\n    if (0 < Box2D.Dynamics.Contacts.b2ContactListNode.freeNodes.length)\n    {\n        var b = Box2D.Dynamics.Contacts.b2ContactListNode.freeNodes.pop();\n        b.next = null;\n        b.previous = null;\n        b.contact = a;\n        return b\n    }\n    return new Box2D.Dynamics.Contacts.b2ContactListNode(a)\n};\nBox2D.Dynamics.Contacts.b2ContactListNode.FreeNode = function (a)\n{\n    Box2D.Dynamics.Contacts.b2ContactListNode.freeNodes.push(a)\n};\nBox2D.Dynamics.Contacts.b2ContactListNode.prototype.SetNextNode = function (a)\n{\n    this.next = a\n};\nBox2D.Dynamics.Contacts.b2ContactListNode.prototype.SetPreviousNode = function (a)\n{\n    this.previous = a\n};\nBox2D.Dynamics.Contacts.b2ContactListNode.prototype.GetContact = function ()\n{\n    return this.contact\n};\nBox2D.Dynamics.Contacts.b2ContactListNode.prototype.GetNextNode = function ()\n{\n    return this.next\n};\nBox2D.Dynamics.Contacts.b2ContactListNode.prototype.GetPreviousNode = function ()\n{\n    return this.previous\n};\nBox2D.Dynamics.Contacts.b2ContactList = function ()\n{\n    this.contactFirstNodes = [];\n    for (var a = 0; a <= Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts; a++)\n    {\n        this.contactFirstNodes[a] = null\n    }\n    this.contactLastNodes = [];\n    for (a = 0; a <= Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts; a++)\n    {\n        this.contactLastNodes[a] = null\n    }\n    this.contactNodeLookup = {};\n    this.contactCount = 0\n};\nBox2D.Dynamics.Contacts.b2ContactList.prototype.GetFirstNode = function (a)\n{\n    return this.contactFirstNodes[a]\n};\nBox2D.Dynamics.Contacts.b2ContactList.prototype.AddContact = function (a)\n{\n    var b = a.ID;\n    if (null == this.contactNodeLookup[b])\n    {\n        this.contactNodeLookup[b] = [];\n        for (var c = 0; c <= Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts; c++)\n        {\n            this.contactNodeLookup[b][c] = null\n        }\n        this.CreateNode(a, b, Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts);\n        this.contactCount++\n    }\n};\nBox2D.Dynamics.Contacts.b2ContactList.prototype.UpdateContact = function (a, b, c)\n{\n    b ? this.CreateNode(a, a.ID, Box2D.Dynamics.Contacts.b2ContactList.TYPES.nonSensorEnabledTouchingContacts) : this.RemoveNode(a.ID, Box2D.Dynamics.Contacts.b2ContactList.TYPES.nonSensorEnabledTouchingContacts);\n    c ? this.CreateNode(a, a.ID, Box2D.Dynamics.Contacts.b2ContactList.TYPES.nonSensorEnabledContinuousContacts) : this.RemoveNode(a.ID, Box2D.Dynamics.Contacts.b2ContactList.TYPES.nonSensorEnabledContinuousContacts)\n};\nBox2D.Dynamics.Contacts.b2ContactList.prototype.RemoveContact = function (a)\n{\n    a = a.ID;\n    if (null != this.contactNodeLookup[a])\n    {\n        for (var b = 0; b <= Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts; b++)\n        {\n            this.RemoveNode(a, b)\n        }\n        delete this.contactNodeLookup[a];\n        this.contactCount--\n    }\n};\nBox2D.Dynamics.Contacts.b2ContactList.prototype.RemoveNode = function (a, b)\n{\n    var c = this.contactNodeLookup[a];\n    if (null != c)\n    {\n        var d = c[b];\n        if (null != d)\n        {\n            c[b] = null;\n            var c = d.GetPreviousNode(), e = d.GetNextNode();\n            null == c ? this.contactFirstNodes[b] = e : c.SetNextNode(e);\n            null == e ? this.contactLastNodes[b] = c : e.SetPreviousNode(c);\n            Box2D.Dynamics.Contacts.b2ContactListNode.FreeNode(d)\n        }\n    }\n};\nBox2D.Dynamics.Contacts.b2ContactList.prototype.CreateNode = function (a, b, c)\n{\n    b = this.contactNodeLookup[b];\n    null == b[c] && (b[c] = Box2D.Dynamics.Contacts.b2ContactListNode.GetNode(a), a = this.contactLastNodes[c], null != a ? (a.SetNextNode(b[c]), b[c].SetPreviousNode(a)) : this.contactFirstNodes[c] = b[c], this.contactLastNodes[c] = b[c])\n};\nBox2D.Dynamics.Contacts.b2ContactList.prototype.GetContactCount = function ()\n{\n    return this.contactCount\n};\nBox2D.Dynamics.Contacts.b2ContactList.TYPES = {nonSensorEnabledTouchingContacts:0, nonSensorEnabledContinuousContacts:1, allContacts:2};\nBox2D.Collision.b2Segment = function ()\n{\n\n    this.p1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.p2 = Box2D.Common.Math.b2Vec2.Get(0, 0)\n};\nBox2D.Collision.b2Segment.prototype.TestSegment = function (a, b, c, d)\n{\n    var e = c.p1, f = c.p2.x - e.x, g = c.p2.y - e.y, c = this.p2.y - this.p1.y, h = -(this.p2.x - this.p1.x), i = 100 * Number.MIN_VALUE, j = -(f * c + g * h);\n    if (j > i)\n    {\n        var k = e.x - this.p1.x, l = e.y - this.p1.y, e = k * c + l * h;\n        if (0 <= e && e <= d * j && (d = -f * l + g * k, -i * j <= d && d <= j * (1 + i)))\n        {\n            return e /= j, d = Math.sqrt(c * c + h * h), a[0] = e, b.Set(c / d, h / d), !0\n        }\n    }\n    return!1\n};\nBox2D.Collision.b2Segment.prototype.Extend = function (a)\n{\n    this.ExtendForward(a);\n    this.ExtendBackward(a)\n};\nBox2D.Collision.b2Segment.prototype.ExtendForward = function (a)\n{\n    var b = this.p2.x - this.p1.x, c = this.p2.y - this.p1.y, a = Math.min(0 < b ? (a.upperBound.x - this.p1.x) / b : 0 > b ? (a.lowerBound.x - this.p1.x) / b : Number.POSITIVE_INFINITY, 0 < c ? (a.upperBound.y - this.p1.y) / c : 0 > c ? (a.lowerBound.y - this.p1.y) / c : Number.POSITIVE_INFINITY);\n    this.p2.x = this.p1.x + b * a;\n    this.p2.y = this.p1.y + c * a\n};\nBox2D.Collision.b2Segment.prototype.ExtendBackward = function (a)\n{\n    var b = -this.p2.x + this.p1.x, c = -this.p2.y + this.p1.y, a = Math.min(0 < b ? (a.upperBound.x - this.p2.x) / b : 0 > b ? (a.lowerBound.x - this.p2.x) / b : Number.POSITIVE_INFINITY, 0 < c ? (a.upperBound.y - this.p2.y) / c : 0 > c ? (a.lowerBound.y - this.p2.y) / c : Number.POSITIVE_INFINITY);\n    this.p1.x = this.p2.x + b * a;\n    this.p1.y = this.p2.y + c * a\n};\nBox2D.Dynamics.Joints.b2MouseJoint = function (a)\n{\n    Box2D.Dynamics.Joints.b2Joint.call(this, a);\n    this.K = new Box2D.Common.Math.b2Mat22;\n    this.K1 = new Box2D.Common.Math.b2Mat22;\n    this.K2 = new Box2D.Common.Math.b2Mat22;\n    this.m_localAnchor = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_target = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_impulse = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_mass = new Box2D.Common.Math.b2Mat22;\n    this.m_C = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_target.SetV(a.target);\n    var b = this.m_target.x - this.m_bodyB.m_xf.position.x, c = this.m_target.y - this.m_bodyB.m_xf.position.y, d = this.m_bodyB.m_xf.R;\n    this.m_localAnchor.x = b * d.col1.x + c * d.col1.y;\n    this.m_localAnchor.y = b * d.col2.x + c * d.col2.y;\n    this.m_maxForce = a.maxForce;\n    this.m_impulse.SetZero();\n    this.m_frequencyHz = a.frequencyHz;\n    this.m_dampingRatio = a.dampingRatio;\n    this.m_gamma = this.m_beta = 0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.GetAnchorA = function ()\n{\n    return Box2D.Common.Math.b2Vec2.Get(this.m_target.x, this.m_target.y)\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.GetAnchorB = function ()\n{\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchor)\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.GetReactionForce = function (a)\n{\n    void 0 === a && (a = 0);\n    return Box2D.Common.Math.b2Vec2.Get(a * this.m_impulse.x, a * this.m_impulse.y)\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.GetReactionTorque = function ()\n{\n    return 0\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.GetTarget = function ()\n{\n    return this.m_target\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.SetTarget = function (a)\n{\n    !1 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0);\n    this.m_target = a\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.GetMaxForce = function ()\n{\n    return this.m_maxForce\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.SetMaxForce = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_maxForce = a\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.GetFrequency = function ()\n{\n    return this.m_frequencyHz\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.SetFrequency = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_frequencyHz = a\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.GetDampingRatio = function ()\n{\n    return this.m_dampingRatio\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.SetDampingRatio = function (a)\n{\n    void 0 === a && (a = 0);\n    this.m_dampingRatio = a\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.InitVelocityConstraints = function (a)\n{\n    var b = this.m_bodyB, c = b.GetMass(), d = 2 * Math.PI * this.m_frequencyHz, e = c * d * d;\n    this.m_gamma = a.dt * (2 * c * this.m_dampingRatio * d + a.dt * e);\n    this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;\n    this.m_beta = a.dt * e * this.m_gamma;\n    var e = b.m_xf.R, c = this.m_localAnchor.x - b.m_sweep.localCenter.x, d = this.m_localAnchor.y - b.m_sweep.localCenter.y, f = e.col1.x * c + e.col2.x * d, d = e.col1.y * c + e.col2.y * d, c = f, e = b.m_invMass, f = b.m_invI;\n    this.K1.col1.x = e;\n    this.K1.col2.x = 0;\n    this.K1.col1.y = 0;\n    this.K1.col2.y = e;\n    this.K2.col1.x = f * d * d;\n    this.K2.col2.x = -f * c * d;\n    this.K2.col1.y = -f * c * d;\n    this.K2.col2.y = f * c * c;\n    this.K.SetM(this.K1);\n    this.K.AddM(this.K2);\n    this.K.col1.x += this.m_gamma;\n    this.K.col2.y += this.m_gamma;\n    this.K.GetInverse(this.m_mass);\n    this.m_C.x = b.m_sweep.c.x + c - this.m_target.x;\n    this.m_C.y = b.m_sweep.c.y + d - this.m_target.y;\n    b.m_angularVelocity *= 0.98;\n    this.m_impulse.x *= a.dtRatio;\n    this.m_impulse.y *= a.dtRatio;\n    b.m_linearVelocity.x += e * this.m_impulse.x;\n    b.m_linearVelocity.y += e * this.m_impulse.y;\n    b.m_angularVelocity += f * (c * this.m_impulse.y - d * this.m_impulse.x)\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.SolveVelocityConstraints = function (a)\n{\n    var b = this.m_bodyB, c, d = 0, e = 0;\n    c = b.m_xf.R;\n    var f = this.m_localAnchor.x - b.m_sweep.localCenter.x, g = this.m_localAnchor.y - b.m_sweep.localCenter.y, d = c.col1.x * f + c.col2.x * g, g = c.col1.y * f + c.col2.y * g, f = d, d = b.m_linearVelocity.x + -b.m_angularVelocity * g, h = b.m_linearVelocity.y + b.m_angularVelocity * f;\n    c = this.m_mass;\n    d = d + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;\n    e = h + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;\n    h = -(c.col1.x * d + c.col2.x * e);\n    e = -(c.col1.y * d + c.col2.y * e);\n    c = this.m_impulse.x;\n    d = this.m_impulse.y;\n    this.m_impulse.x += h;\n    this.m_impulse.y += e;\n    a = a.dt * this.m_maxForce;\n    this.m_impulse.LengthSquared() > a * a && this.m_impulse.Multiply(a / this.m_impulse.Length());\n    h = this.m_impulse.x - c;\n    e = this.m_impulse.y - d;\n    b.m_linearVelocity.x += b.m_invMass * h;\n    b.m_linearVelocity.y += b.m_invMass * e;\n    b.m_angularVelocity += b.m_invI * (f * e - g * h)\n};\nBox2D.Dynamics.Joints.b2MouseJoint.prototype.SolvePositionConstraints = function ()\n{\n    return!0\n};\nBox2D.Dynamics.b2BodyListNode = function (a)\n{\n\n    this.body = a;\n    this.previous = this.next = null\n};\nBox2D.Dynamics.b2BodyListNode.prototype.SetNextNode = function (a)\n{\n    this.next = a\n};\nBox2D.Dynamics.b2BodyListNode.prototype.SetPreviousNode = function (a)\n{\n    this.previous = a\n};\nBox2D.Dynamics.b2BodyListNode.prototype.GetBody = function ()\n{\n    return this.body\n};\nBox2D.Dynamics.b2BodyListNode.prototype.GetNextNode = function ()\n{\n    return this.next\n};\nBox2D.Dynamics.b2BodyListNode.prototype.GetPreviousNode = function ()\n{\n    return this.previous\n};\nBox2D.Common.b2Color = function (a, b, c)\n{\n\n    this._r = 255 * Box2D.Common.Math.b2Math.Clamp(a, 0, 1);\n    this._g = 255 * Box2D.Common.Math.b2Math.Clamp(b, 0, 1);\n    this._b = 255 * Box2D.Common.Math.b2Math.Clamp(c, 0, 1)\n};\nBox2D.Common.b2Color.prototype.Set = function (a, b, c)\n{\n    this._r = 255 * Box2D.Common.Math.b2Math.Clamp(a, 0, 1);\n    this._g = 255 * Box2D.Common.Math.b2Math.Clamp(b, 0, 1);\n    this._b = 255 * Box2D.Common.Math.b2Math.Clamp(c, 0, 1)\n};\nBox2D.Common.b2Color.prototype.GetColor = function ()\n{\n    return this._r << 16 | this._g << 8 | this._b\n};\nBox2D.Dynamics.b2BodyList = function ()\n{\n\n    this.bodyFirstNodes = [];\n    for (var a = 0; a <= Box2D.Dynamics.b2BodyList.TYPES.allBodies; a++)\n    {\n        this.bodyFirstNodes[a] = null\n    }\n    this.bodyLastNodes = [];\n    for (a = 0; a <= Box2D.Dynamics.b2BodyList.TYPES.allBodies; a++)\n    {\n        this.bodyLastNodes[a] = null\n    }\n    this.bodyNodeLookup = {};\n    this.bodyCount = 0\n};\nBox2D.Dynamics.b2BodyList.prototype.GetFirstNode = function (a)\n{\n    return this.bodyFirstNodes[a]\n};\nBox2D.Dynamics.b2BodyList.prototype.AddBody = function (a)\n{\n    var b = a.ID;\n    null == this.bodyNodeLookup[b] && (this.CreateNode(a, b, Box2D.Dynamics.b2BodyList.TYPES.allBodies), this.UpdateBody(a), a.m_lists.push(this), this.bodyCount++)\n};\nBox2D.Dynamics.b2BodyList.prototype.UpdateBody = function (a)\n{\n    var b = a.GetType(), c = a.ID, d = a.IsAwake(), e = a.IsActive();\n    b == Box2D.Dynamics.b2BodyDef.b2_dynamicBody ? this.CreateNode(a, c, Box2D.Dynamics.b2BodyList.TYPES.dynamicBodies) : this.RemoveNode(c, Box2D.Dynamics.b2BodyList.TYPES.dynamicBodies);\n    b != Box2D.Dynamics.b2BodyDef.b2_staticBody ? this.CreateNode(a, c, Box2D.Dynamics.b2BodyList.TYPES.nonStaticBodies) : this.RemoveNode(c, Box2D.Dynamics.b2BodyList.TYPES.nonStaticBodies);\n    b != Box2D.Dynamics.b2BodyDef.b2_staticBody && e && d ? this.CreateNode(a, c, Box2D.Dynamics.b2BodyList.TYPES.nonStaticActiveAwakeBodies) : this.RemoveNode(c, Box2D.Dynamics.b2BodyList.TYPES.nonStaticActiveAwakeBodies);\n    d ? this.CreateNode(a, c, Box2D.Dynamics.b2BodyList.TYPES.awakeBodies) : this.RemoveNode(c, Box2D.Dynamics.b2BodyList.TYPES.awakeBodies);\n    e ? this.CreateNode(a, c, Box2D.Dynamics.b2BodyList.TYPES.activeBodies) : this.RemoveNode(c, Box2D.Dynamics.b2BodyList.TYPES.activeBodies)\n};\nBox2D.Dynamics.b2BodyList.prototype.RemoveBody = function (a)\n{\n    var b = a.ID;\n    if (null != this.bodyNodeLookup[b])\n    {\n        goog.array.remove(a.m_lists, this);\n        for (a = 0; a <= Box2D.Dynamics.b2BodyList.TYPES.allBodies; a++)\n        {\n            this.RemoveNode(b, a)\n        }\n        delete this.bodyNodeLookup[b];\n        this.bodyCount--\n    }\n};\nBox2D.Dynamics.b2BodyList.prototype.RemoveNode = function (a, b)\n{\n    var c = this.bodyNodeLookup[a];\n    if (null != c)\n    {\n        var d = c[b];\n        null != d && (c[b] = null, c = d.GetPreviousNode(), d = d.GetNextNode(), null == c ? this.bodyFirstNodes[b] = d : c.SetNextNode(d), null == d ? this.bodyLastNodes[b] = c : d.SetPreviousNode(c))\n    }\n};\nBox2D.Dynamics.b2BodyList.prototype.CreateNode = function (a, b, c)\n{\n    var d = this.bodyNodeLookup[b];\n    if (null == d)\n    {\n        for (var d = [], e = 0; e <= Box2D.Dynamics.b2BodyList.TYPES.allBodies; e++)\n        {\n            d[e] = null\n        }\n        this.bodyNodeLookup[b] = d\n    }\n    null == d[c] && (d[c] = new Box2D.Dynamics.b2BodyListNode(a), a = this.bodyLastNodes[c], null != a ? a.SetNextNode(d[c]) : this.bodyFirstNodes[c] = d[c], d[c].SetPreviousNode(a), this.bodyLastNodes[c] = d[c])\n};\nBox2D.Dynamics.b2BodyList.prototype.GetBodyCount = function ()\n{\n    return this.bodyCount\n};\nBox2D.Dynamics.b2BodyList.TYPES = {dynamicBodies:0, nonStaticBodies:1, activeBodies:2, nonStaticActiveAwakeBodies:3, awakeBodies:4, allBodies:5};\nBox2D.Dynamics.Controllers = {};\nBox2D.Dynamics.Controllers.b2Controller = function ()\n{\n    this.ID = \"Controller\" + Box2D.Dynamics.Controllers.b2Controller.NEXT_ID++;\n    this.m_world = null;\n    this.bodyList = new Box2D.Dynamics.b2BodyList\n};\nBox2D.Dynamics.Controllers.b2Controller.prototype.Step = function ()\n{\n};\nBox2D.Dynamics.Controllers.b2Controller.prototype.Draw = function ()\n{\n};\nBox2D.Dynamics.Controllers.b2Controller.prototype.AddBody = function (a)\n{\n    this.bodyList.AddBody(a);\n    a.AddController(this)\n};\nBox2D.Dynamics.Controllers.b2Controller.prototype.RemoveBody = function (a)\n{\n    this.bodyList.RemoveBody(a);\n    a.RemoveController(this)\n};\nBox2D.Dynamics.Controllers.b2Controller.prototype.Clear = function ()\n{\n    for (var a = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.allBodies); a; a = a.GetNextNode())\n    {\n        this.RemoveBody(a.body)\n    }\n};\nBox2D.Dynamics.Controllers.b2Controller.prototype.GetBodyList = function ()\n{\n    return this.bodyList\n};\nBox2D.Dynamics.Controllers.b2Controller.NEXT_ID = 0;\nBox2D.Dynamics.Controllers.b2ConstantAccelController = function ()\n{\n    Box2D.Dynamics.Controllers.b2Controller.call(this);\n    this.A = Box2D.Common.Math.b2Vec2.Get(0, 0)\n};\ngoog.inherits(Box2D.Dynamics.Controllers.b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);\nBox2D.Dynamics.Controllers.b2ConstantAccelController.prototype.Step = function (a)\n{\n    for (var a = Box2D.Common.Math.b2Vec2.Get(this.A.x * a.dt, this.A.y * a.dt), b = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.awakeBodies); b; b = b.GetNextNode())\n    {\n        var c = b.body, d = c.GetLinearVelocity(), d = Box2D.Common.Math.b2Vec2.Get(d.x + a.x, d.y + a.y);\n        c.SetLinearVelocity(d);\n        Box2D.Common.Math.b2Vec2.Free(d)\n    }\n    Box2D.Common.Math.b2Vec2.Free(a)\n};\nBox2D.Dynamics.Contacts.b2PolygonContact = function (a, b)\n{\n    Box2D.Dynamics.Contacts.b2Contact.call(this, a, b)\n};\ngoog.inherits(Box2D.Dynamics.Contacts.b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);\nBox2D.Dynamics.Contacts.b2PolygonContact.prototype.Reset = function (a, b)\n{\n    Box2D.Dynamics.Contacts.b2Contact.prototype.Reset.call(this, a, b)\n};\nBox2D.Dynamics.Contacts.b2PolygonContact.prototype.Evaluate = function ()\n{\n    var a = this.m_fixtureA.GetShape(), b = this.m_fixtureB.GetShape();\n    Box2D.Collision.b2Collision.CollidePolygons(this.m_manifold, a, this.m_fixtureA.GetBody().m_xf, b, this.m_fixtureB.GetBody().m_xf)\n};\nBox2D.Collision.IBroadPhase = \"Box2D.Collision.IBroadPhase\";\nBox2D.Dynamics.b2Island = function (a, b)\n{\n\n    this.m_listener = a;\n    this.m_contactSolver = b;\n    this.m_bodies = [];\n    this.m_dynamicBodies = [];\n    this.m_nonStaticBodies = [];\n    this.m_contacts = [];\n    this.m_joints = [];\n    this.impulse = new Box2D.Dynamics.b2ContactImpulse\n};\nBox2D.Dynamics.b2Island.prototype.Reset = function (a, b)\n{\n    this.m_listener = a;\n    this.m_contactSolver = b\n};\nBox2D.Dynamics.b2Island.prototype.Clear = function ()\n{\n    this.m_bodies = [];\n    this.m_dynamicBodies = [];\n    this.m_nonStaticBodies = [];\n    this.m_contacts = [];\n    this.m_joints = []\n};\nBox2D.Dynamics.b2Island.prototype.Solve = function (a, b, c)\n{\n    this._InitializeVelocities(a, b);\n    this.m_contactSolver.Initialize(a, this.m_contacts, this.m_contacts.length);\n    this._SolveVelocityConstraints(a);\n    this._SolveBodies(a);\n    this._SolvePositionConstraints(a);\n    this.Report(this.m_contactSolver.m_constraints);\n    c && this._SleepIfTired(a)\n};\nBox2D.Dynamics.b2Island.prototype._InitializeVelocities = function (a, gravity)\n{\n    // playcraft/pc -- modified to allow for each body to have it's own overriding gravity\n    for (var c = 0; c < this.m_dynamicBodies.length; c++)\n    {\n        var d = this.m_dynamicBodies[c];\n        var gx = gravity.x;\n        var gy = gravity.y;\n        if (d._pc_gravityX != undefined)\n            gx = d._pc_gravityX;\n        if (d._pc_gravityY != undefined)\n            gy = d._pc_gravityY;\n\n        d.m_linearVelocity.x += a.dt * (gx + d.m_invMass * d.m_force.x);\n        d.m_linearVelocity.y += a.dt * (gy + d.m_invMass * d.m_force.y);\n        d.m_angularVelocity += a.dt * d.m_invI * d.m_torque;\n        d.m_linearVelocity.Multiply(Box2D.Common.Math.b2Math.Clamp(1 - a.dt * d.m_linearDamping, 0, 1));\n        d.m_angularVelocity *= Box2D.Common.Math.b2Math.Clamp(1 - a.dt * d.m_angularDamping, 0, 1)\n    }\n};\nBox2D.Dynamics.b2Island.prototype._SolveVelocityConstraints = function (a)\n{\n    this.m_contactSolver.InitVelocityConstraints(a);\n    for (var b = 0; b < this.m_joints.length; b++)\n    {\n        this.m_joints[b].InitVelocityConstraints(a)\n    }\n    for (b = 0; b < a.velocityIterations; b++)\n    {\n        for (var c = 0; c < this.m_joints.length; c++)\n        {\n            this.m_joints[c].SolveVelocityConstraints(a)\n        }\n        this.m_contactSolver.SolveVelocityConstraints()\n    }\n    for (a = 0; a < this.m_joints.length; a++)\n    {\n        this.m_joints[a].FinalizeVelocityConstraints()\n    }\n    this.m_contactSolver.FinalizeVelocityConstraints()\n};\nBox2D.Dynamics.b2Island.prototype._SolveBodies = function (a)\n{\n    for (var b = 0; b < this.m_nonStaticBodies.length; ++b)\n    {\n        var c = this.m_nonStaticBodies[b], d = a.dt * c.m_linearVelocity.x, e = a.dt * c.m_linearVelocity.y;\n        d * d + e * e > Box2D.Common.b2Settings.b2_maxTranslationSquared && (c.m_linearVelocity.Normalize(), c.m_linearVelocity.x *= Box2D.Common.b2Settings.b2_maxTranslation * a.inv_dt, c.m_linearVelocity.y *= Box2D.Common.b2Settings.b2_maxTranslation * a.inv_dt);\n        d = a.dt * c.m_angularVelocity;\n        d * d > Box2D.Common.b2Settings.b2_maxRotationSquared && (c.m_angularVelocity = 0 > c.m_angularVelocity ? -Box2D.Common.b2Settings.b2_maxRotation * a.inv_dt : Box2D.Common.b2Settings.b2_maxRotation * a.inv_dt);\n        c.m_sweep.c0.SetV(c.m_sweep.c);\n        c.m_sweep.a0 = c.m_sweep.a;\n        c.m_sweep.c.x += a.dt * c.m_linearVelocity.x;\n        c.m_sweep.c.y += a.dt * c.m_linearVelocity.y;\n        c.m_sweep.a += a.dt * c.m_angularVelocity;\n        c.SynchronizeTransform()\n    }\n};\nBox2D.Dynamics.b2Island.prototype._SolvePositionConstraints = function (a)\n{\n    for (var b = 0; b < a.positionIterations; b++)\n    {\n        for (var c = this.m_contactSolver.SolvePositionConstraints(Box2D.Common.b2Settings.b2_contactBaumgarte), d = !0, e = 0; e < this.m_joints.length; e++)\n        {\n            var f = this.m_joints[e].SolvePositionConstraints(Box2D.Common.b2Settings.b2_contactBaumgarte), d = d && f\n        }\n        if (c && d)\n        {\n            break\n        }\n    }\n};\nBox2D.Dynamics.b2Island.prototype._SleepIfTired = function (a)\n{\n    for (var b = Number.MAX_VALUE, c = 0; c < this.m_nonStaticBodies.length; c++)\n    {\n        var d = this.m_nonStaticBodies[c];\n        !d.m_allowSleep || Math.abs(d.m_angularVelocity) > Box2D.Common.b2Settings.b2_angularSleepTolerance || Box2D.Common.Math.b2Math.Dot(d.m_linearVelocity, d.m_linearVelocity) > Box2D.Common.b2Settings.b2_linearSleepToleranceSquared ? b = d.m_sleepTime = 0 : (d.m_sleepTime += a.dt, b = Math.min(b, d.m_sleepTime))\n    }\n    if (b >= Box2D.Common.b2Settings.b2_timeToSleep)\n    {\n        for (a = 0; a < this.m_bodies.length; a++)\n        {\n            this.m_bodies[a].SetAwake(!1)\n        }\n    }\n};\nBox2D.Dynamics.b2Island.prototype.SolveTOI = function (a)\n{\n    var b = 0, c = 0;\n    this.m_contactSolver.Initialize(a, this.m_contacts, this.m_contacts.length);\n    for (var d = this.m_contactSolver, b = 0; b < this.m_joints.length; ++b)\n    {\n        this.m_joints[b].InitVelocityConstraints(a)\n    }\n    for (b = 0; b < a.velocityIterations; ++b)\n    {\n        d.SolveVelocityConstraints();\n        for (c = 0; c < this.m_joints.length; ++c)\n        {\n            this.m_joints[c].SolveVelocityConstraints(a)\n        }\n    }\n    for (b = 0; b < this.m_nonStaticBodies.length; ++b)\n    {\n        var c = this.m_nonStaticBodies[b], e = a.dt * c.m_linearVelocity.x, f = a.dt * c.m_linearVelocity.y;\n        e * e + f * f > Box2D.Common.b2Settings.b2_maxTranslationSquared && (c.m_linearVelocity.Normalize(), c.m_linearVelocity.x *= Box2D.Common.b2Settings.b2_maxTranslation * a.inv_dt, c.m_linearVelocity.y *= Box2D.Common.b2Settings.b2_maxTranslation * a.inv_dt);\n        e = a.dt * c.m_angularVelocity;\n        e * e > Box2D.Common.b2Settings.b2_maxRotationSquared && (c.m_angularVelocity = 0 > c.m_angularVelocity ? -Box2D.Common.b2Settings.b2_maxRotation * a.inv_dt : Box2D.Common.b2Settings.b2_maxRotation * a.inv_dt);\n        c.m_sweep.c0.SetV(c.m_sweep.c);\n        c.m_sweep.a0 = c.m_sweep.a;\n        c.m_sweep.c.x += a.dt * c.m_linearVelocity.x;\n        c.m_sweep.c.y += a.dt * c.m_linearVelocity.y;\n        c.m_sweep.a += a.dt * c.m_angularVelocity;\n        c.SynchronizeTransform()\n    }\n    for (b = 0; b < a.positionIterations; ++b)\n    {\n        e = d.SolvePositionConstraints(0.75);\n        f = !0;\n        for (c = 0; c < this.m_joints.length; ++c)\n        {\n            var g = this.m_joints[c].SolvePositionConstraints(Box2D.Common.b2Settings.b2_contactBaumgarte), f = f && g\n        }\n        if (e && f)\n        {\n            break\n        }\n    }\n    this.Report(d.m_constraints)\n};\nBox2D.Dynamics.b2Island.prototype.Report = function (a)\n{\n    if (null != this.m_listener)\n    {\n        for (var b = 0; b < this.m_contacts.length; ++b)\n        {\n            var c = this.m_contacts[b], d = a[b];\n            this.impulse.Reset();\n            for (var e = 0; e < d.pointCount; ++e)\n            {\n                this.impulse.normalImpulses[e] = d.points[e].normalImpulse, this.impulse.tangentImpulses[e] = d.points[e].tangentImpulse\n            }\n            this.m_listener.PostSolve(c, this.impulse)\n        }\n    }\n};\nBox2D.Dynamics.b2Island.prototype.AddBody = function (a)\n{\n    this.m_bodies.push(a);\n    a.GetType() != Box2D.Dynamics.b2BodyDef.b2_staticBody && (this.m_nonStaticBodies.push(a), a.GetType() == Box2D.Dynamics.b2BodyDef.b2_dynamicBody && this.m_dynamicBodies.push(a))\n};\nBox2D.Dynamics.b2Island.prototype.AddContact = function (a)\n{\n    this.m_contacts.push(a)\n};\nBox2D.Dynamics.b2Island.prototype.AddJoint = function (a)\n{\n    this.m_joints.push(a)\n};\nBox2D.Dynamics.Contacts.b2ContactRegister = function ()\n{\n    this.pool = null;\n    this.poolCount = 0\n};\nBox2D.Collision.b2DynamicTreePair = function (a, b)\n{\n\n    this.fixtureA = a;\n    this.fixtureB = b\n};\nBox2D.Collision.b2DynamicTreePair._freeCache = [];\nBox2D.Collision.b2DynamicTreePair.Get = function (a, b)\n{\n\n    if (0 < Box2D.Collision.b2DynamicTreePair._freeCache.length)\n    {\n        var c = Box2D.Collision.b2DynamicTreePair._freeCache.pop();\n        c.fixtureA = a;\n        c.fixtureB = b;\n        return c\n    }\n    return new Box2D.Collision.b2DynamicTreePair(a, b)\n};\nBox2D.Collision.b2DynamicTreePair.Free = function (a)\n{\n    null != a && ( Box2D.Collision.b2DynamicTreePair._freeCache.push(a))\n};\nBox2D.Dynamics.b2DebugDraw = function ()\n{\n\n    this.m_xformScale = this.m_fillAlpha = this.m_alpha = this.m_lineThickness = this.m_drawScale = 1;\n    this.m_drawFlags = 0;\n    this.m_originX = 0;\n    this.m_originY = 0;\n\n    this.m_ctx = null\n};\n\nBox2D.Dynamics.b2DebugDraw.prototype.SetOrigin = function(x, y)\n{\n    this.m_originX = x;\n    this.m_originY = y;\n};\n\nBox2D.Dynamics.b2DebugDraw.prototype.Clear = function ()\n{\n//  this.m_ctx.clearRect(0, 0, this.m_ctx.canvas.width, this.m_ctx.canvas.height)\n};\nBox2D.Dynamics.b2DebugDraw.prototype._color = function (a, b)\n{\n    return\"rgba(\" + ((a & 16711680) >> 16) + \",\" + ((a & 65280) >> 8) + \",\" + (a & 255) + \",\" + b + \")\"\n};\nBox2D.Dynamics.b2DebugDraw.prototype.SetFlags = function (a)\n{\n    this.m_drawFlags = a\n};\nBox2D.Dynamics.b2DebugDraw.prototype.GetFlags = function ()\n{\n    return this.m_drawFlags\n};\nBox2D.Dynamics.b2DebugDraw.prototype.AppendFlags = function (a)\n{\n    this.m_drawFlags |= a\n};\nBox2D.Dynamics.b2DebugDraw.prototype.ClearFlags = function (a)\n{\n    this.m_drawFlags &= ~a\n};\nBox2D.Dynamics.b2DebugDraw.prototype.SetSprite = function (a)\n{\n    this.m_ctx = a\n};\nBox2D.Dynamics.b2DebugDraw.prototype.GetSprite = function ()\n{\n    return this.m_ctx\n};\nBox2D.Dynamics.b2DebugDraw.prototype.SetDrawScale = function (a)\n{\n    this.m_drawScale = a\n};\nBox2D.Dynamics.b2DebugDraw.prototype.GetDrawScale = function ()\n{\n    return this.m_drawScale\n};\nBox2D.Dynamics.b2DebugDraw.prototype.SetLineThickness = function (a)\n{\n    this.m_lineThickness = a;\n    this.m_ctx.strokeWidth = a\n};\nBox2D.Dynamics.b2DebugDraw.prototype.GetLineThickness = function ()\n{\n    return this.m_lineThickness\n};\nBox2D.Dynamics.b2DebugDraw.prototype.SetAlpha = function (a)\n{\n    this.m_alpha = a\n};\nBox2D.Dynamics.b2DebugDraw.prototype.GetAlpha = function ()\n{\n    return this.m_alpha\n};\nBox2D.Dynamics.b2DebugDraw.prototype.SetFillAlpha = function (a)\n{\n    this.m_fillAlpha = a\n};\nBox2D.Dynamics.b2DebugDraw.prototype.GetFillAlpha = function ()\n{\n    return this.m_fillAlpha\n};\nBox2D.Dynamics.b2DebugDraw.prototype.SetXFormScale = function (a)\n{\n    this.m_xformScale = a\n};\nBox2D.Dynamics.b2DebugDraw.prototype.GetXFormScale = function ()\n{\n    return this.m_xformScale\n};\n(function (a)\n{\n    a.prototype.DrawPolygon = function (a, c, d)\n    {\n        if (c)\n        {\n            var e = this.m_ctx, f = this.m_drawScale;\n            e.beginPath();\n            e.strokeStyle = this._color(d.GetColor(), this.m_alpha);\n            e.moveTo((a[0].x * f)-this.m_originX, (a[0].y * f)- this.m_originY);\n            for (d = 1; d < c; d++)\n            {\n                e.lineTo((a[d].x*f) - this.m_originX, (a[d].y*f) - this.m_originY)\n            }\n            e.lineTo((a[0].x*f) - this.m_originX, (a[0].y*f) - this.m_originY);\n            e.closePath();\n            e.stroke()\n        }\n    };\n    a.prototype.DrawSolidPolygon = function (a, c, d)\n    {\n        if (c)\n        {\n            var e = this.m_ctx, f = this.m_drawScale;\n            e.beginPath();\n            e.strokeStyle = this._color(d.GetColor(), this.m_alpha);\n            e.fillStyle = this._color(d.GetColor(), this.m_fillAlpha);\n            e.moveTo((a[0].x * f)-this.m_originX, (a[0].y * f) - this.m_originY);\n            for (d = 1; d < c; d++)\n            {\n                e.lineTo((a[d].x * f) - this.m_originX, (a[d].y * f) - this.m_originY);\n            }\n            e.lineTo((a[0].x* f) - this.m_originX, (a[0].y* f) - this.m_originY);\n            e.closePath();\n            e.fill();\n            e.stroke()\n        }\n    };\n    a.prototype.DrawCircle = function (a, c, d)\n    {\n        if (c)\n        {\n            var e = this.m_ctx, f = this.m_drawScale;\n            e.beginPath();\n            e.strokeStyle = this._color(d.GetColor(), this.m_alpha);\n            e.arc((a.x * f) - this.m_originX, (a.y * f)-this.m_originY, c * f, 0, 2 * Math.PI, !0);\n            e.closePath();\n            e.stroke()\n        }\n    };\n    a.prototype.DrawSolidCircle = function (a, c, d, e)\n    {\n        if (c)\n        {\n            var f = this.m_ctx, g = this.m_drawScale, h = (a.x * g) - this.m_originX, i = (a.y * g) - this.m_originY;\n            f.moveTo(0, 0);\n            f.beginPath();\n            f.strokeStyle = this._color(e.GetColor(), this.m_alpha);\n            f.fillStyle = this._color(e.GetColor(), this.m_fillAlpha);\n            f.arc(h, i, c * g, 0, 2 * Math.PI, !0);\n            f.moveTo(h, i);\n            f.lineTo(((a.x + d.x * c) * g)-this.m_originX, ((a.y + d.y * c) * g)-this.m_originY);\n            f.closePath();\n            f.fill();\n            f.stroke()\n        }\n    };\n    a.prototype.DrawSegment = function (a, c, d)\n    {\n        var e = this.m_ctx, f = this.m_drawScale;\n        e.strokeStyle = this._color(d.GetColor(), this.m_alpha);\n        e.beginPath();\n        e.moveTo((a.x * f) - this.m_originX, (a.y * f) - this.m_originY);\n        e.lineTo((c.x * f) - this.m_originX, (c.y * f) - this.m_originY);\n        e.closePath();\n        e.stroke()\n    };\n    a.prototype.DrawTransform = function (a)\n    {\n        var c = this.m_ctx, d = this.m_drawScale;\n        c.beginPath();\n        c.strokeStyle = this._color(16711680, this.m_alpha);\n        c.moveTo((a.position.x * d) - this.m_originX, (a.position.y * d) - this.m_originY);\n        c.lineTo(((a.position.x + this.m_xformScale * a.R.col1.x) * d) - this.m_originX,\n            ((a.position.y + this.m_xformScale * a.R.col1.y) * d) - this.m_originY);\n        c.strokeStyle = this._color(65280, this.m_alpha);\n        c.moveTo((a.position.x * d) - this.m_originX, (a.position.y * d) - this.m_originY);\n        c.lineTo(((a.position.x + this.m_xformScale * a.R.col2.x) * d) - this.m_originX,\n            ((a.position.y + this.m_xformScale * a.R.col2.y) * d) - this.m_originY);\n        c.closePath();\n        c.stroke()\n    }\n})(Box2D.Dynamics.b2DebugDraw);\nBox2D.Dynamics.b2DebugDraw.e_shapeBit = 1;\nBox2D.Dynamics.b2DebugDraw.e_jointBit = 2;\nBox2D.Dynamics.b2DebugDraw.e_aabbBit = 4;\nBox2D.Dynamics.b2DebugDraw.e_pairBit = 8;\nBox2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 16;\nBox2D.Dynamics.b2DebugDraw.e_controllerBit = 32;\nBox2D.Collision.b2RayCastOutput = function ()\n{\n\n    this.normal = Box2D.Common.Math.b2Vec2.Get(0, 0)\n};\nBox2D.Dynamics.iContactFilter = function ()\n{\n};\nBox2D.Dynamics.iContactFilter.prototype.ShouldCollide = function ()\n{\n};\nBox2D.Dynamics.b2ContactFilter = function ()\n{\n\n};\nBox2D.Dynamics.b2ContactFilter.prototype.ShouldCollide = function (a, b)\n{\n    var c = a.GetFilterData(), d = b.GetFilterData();\n    return c.groupIndex == d.groupIndex && 0 != c.groupIndex ? 0 < c.groupIndex : 0 != (c.maskBits & d.categoryBits) && 0 != (c.categoryBits & d.maskBits)\n};\nBox2D.Dynamics.b2ContactFilter.b2_defaultFilter = new Box2D.Dynamics.b2ContactFilter;\nBox2D.Dynamics.Joints.b2MouseJointDef = function ()\n{\n    Box2D.Dynamics.Joints.b2JointDef.call(this);\n    this.target = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.type = Box2D.Dynamics.Joints.b2Joint.e_mouseJoint;\n    this.maxForce = 0;\n    this.frequencyHz = 5;\n    this.dampingRatio = 0.7\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);\nBox2D.Dynamics.Joints.b2MouseJointDef.prototype.Create = function ()\n{\n    return new Box2D.Dynamics.Joints.b2MouseJoint(this)\n};\nBox2D.Dynamics.Contacts.b2ContactFactory = function ()\n{\n    this.m_registers = {};\n    this.m_freeContacts = {};\n    this.AddType(Box2D.Dynamics.Contacts.b2CircleContact, Box2D.Collision.Shapes.b2CircleShape.NAME, Box2D.Collision.Shapes.b2CircleShape.NAME);\n    this.AddType(Box2D.Dynamics.Contacts.b2PolyAndCircleContact, Box2D.Collision.Shapes.b2PolygonShape.NAME, Box2D.Collision.Shapes.b2CircleShape.NAME);\n    this.AddType(Box2D.Dynamics.Contacts.b2PolygonContact, Box2D.Collision.Shapes.b2PolygonShape.NAME, Box2D.Collision.Shapes.b2PolygonShape.NAME);\n    this.AddType(Box2D.Dynamics.Contacts.b2EdgeAndCircleContact, Box2D.Collision.Shapes.b2EdgeShape.NAME, Box2D.Collision.Shapes.b2CircleShape.NAME);\n    this.AddType(Box2D.Dynamics.Contacts.b2PolyAndEdgeContact, Box2D.Collision.Shapes.b2PolygonShape.NAME, Box2D.Collision.Shapes.b2EdgeShape.NAME)\n};\nBox2D.Dynamics.Contacts.b2ContactFactory.prototype.AddType = function (a, b, c)\n{\n    this.m_freeContacts[b] = this.m_freeContacts[b] || {};\n    this.m_freeContacts[b][c] = this.m_freeContacts[b][c] || [];\n    this.m_registers[b] = this.m_registers[b] || {};\n    this.m_registers[b][c] = new Box2D.Dynamics.Contacts.b2ContactRegister;\n    this.m_registers[b][c].ctor = a;\n    this.m_registers[b][c].primary = !0;\n    b != c && (this.m_registers[c] = this.m_registers[c] || {}, this.m_registers[c][b] = new Box2D.Dynamics.Contacts.b2ContactRegister, this.m_registers[c][b].ctor = a, this.m_registers[c][b].primary = !1)\n};\nBox2D.Dynamics.Contacts.b2ContactFactory.prototype.Create = function (a, b)\n{\n\n    var c = a.GetShape().GetTypeName(), d = b.GetShape().GetTypeName(), e = this.m_registers[c][d], f = e.ctor;\n    return null != f ? e.primary ? 0 < this.m_freeContacts[c][d].length ? (c = this.m_freeContacts[c][d].pop(), c.Reset(a, b), c) : new f(a, b) : 0 < this.m_freeContacts[d][c].length ? (c = this.m_freeContacts[d][c].pop(), c.Reset(b, a), c) : new f(b, a) : null\n};\nBox2D.Dynamics.Contacts.b2ContactFactory.prototype.Destroy = function (a)\n{\n\n    var b = a.GetFixtureA().GetShape().GetTypeName(), c = a.GetFixtureB().GetShape().GetTypeName();\n    this.m_freeContacts[b][c].push(a)\n};\nBox2D.Dynamics.b2ContactListener = function ()\n{\n\n};\nBox2D.Dynamics.b2ContactListener.prototype.BeginContact = function ()\n{\n};\nBox2D.Dynamics.b2ContactListener.prototype.EndContact = function ()\n{\n};\nBox2D.Dynamics.b2ContactListener.prototype.PreSolve = function ()\n{\n};\nBox2D.Dynamics.b2ContactListener.prototype.PostSolve = function ()\n{\n};\nBox2D.Dynamics.b2ContactListener.b2_defaultListener = new Box2D.Dynamics.b2ContactListener;\nBox2D.Collision.b2ContactPoint = function ()\n{\n\n    this.position = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.velocity = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.normal = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.id = new Box2D.Collision.b2ContactID\n};\nBox2D.Collision.b2DynamicTreeBroadPhase = function ()\n{\n\n    this.m_tree = new Box2D.Collision.b2DynamicTree;\n    this.m_moveBuffer = [];\n    this.queryProxy = this.updatePairsCallback = this.lastQueryFixtureB = this.lastQueryFixtureA = null\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.CreateProxy = function (a, b)\n{\n    var c = this.m_tree.CreateProxy(a, b);\n    this.BufferMove(c);\n    return c\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (a)\n{\n    this.UnBufferMove(a);\n    this.m_tree.DestroyProxy(a)\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.MoveProxy = function (a, b, c)\n{\n    this.m_tree.MoveProxy(a, b, c) && this.BufferMove(a)\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.TestOverlap = function (a, b)\n{\n    var c = this.m_tree.GetFatAABB(a), d = this.m_tree.GetFatAABB(b);\n    return c.TestOverlap(d)\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (a)\n{\n    return this.m_tree.GetFatAABB(a)\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.GetProxyCount = function ()\n{\n    return this.m_tree.length\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (a)\n{\n    this.lastQueryFixtureB = this.lastQueryFixtureA = null;\n    for (this.updatePairsCallback = a; 0 < this.m_moveBuffer.length;)\n    {\n        this.queryProxy = this.m_moveBuffer.pop(), this.m_tree.Query(this.QueryCallback, this.m_tree.GetFatAABB(this.queryProxy), this)\n    }\n    this.queryProxy = this.updatePairsCallback = this.lastQueryFixtureB = this.lastQueryFixtureA = null\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.QueryCallback = function (a)\n{\n    a != this.queryProxy.fixture && (!(this.queryProxy.fixture == this.lastQueryFixtureA && a == this.lastQueryFixtureB) && !(this.queryProxy.fixture == this.lastQueryFixtureB && a == this.lastQueryFixtureA)) && (this.updatePairsCallback(this.queryProxy.fixture, a), this.lastQueryFixtureA = this.queryProxy.fixture, this.lastQueryFixtureB = a);\n    return!0\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.Query = function (a, b)\n{\n    this.m_tree.Query(a, b)\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.RayCast = function (a, b)\n{\n    this.m_tree.RayCast(a, b)\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.Rebalance = function (a)\n{\n    this.m_tree.Rebalance(a)\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.BufferMove = function (a)\n{\n    this.m_moveBuffer.push(a)\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (a)\n{\n    goog.array.remove(this.m_moveBuffer, a)\n};\nBox2D.Collision.b2DynamicTreeBroadPhase.__implements = {};\nBox2D.Collision.b2DynamicTreeBroadPhase.__implements[Box2D.Collision.IBroadPhase] = !0;\nBox2D.Dynamics.b2ContactManager = function (a)\n{\n\n    this.m_world = a;\n    this.m_contactFilter = Box2D.Dynamics.b2ContactFilter.b2_defaultFilter;\n    this.m_contactListener = Box2D.Dynamics.b2ContactListener.b2_defaultListener;\n    this.m_contactFactory = new Box2D.Dynamics.Contacts.b2ContactFactory;\n    this.m_broadPhase = new Box2D.Collision.b2DynamicTreeBroadPhase\n};\nBox2D.Dynamics.b2ContactManager.prototype.AddPair = function (a, b)\n{\n    var c = a.GetBody(), d = b.GetBody();\n    if (c != d && d.ShouldCollide(c) && this.m_contactFilter.ShouldCollide(a, b))\n    {\n        for (c = d.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); c; c = c.GetNextNode())\n        {\n            if (d = c.contact.GetFixtureA(), d == a)\n            {\n                if (d = c.contact.GetFixtureB(), d == b)\n                {\n                    return\n                }\n            } else\n            {\n                if (d == b && (d = c.contact.GetFixtureB(), d == a))\n                {\n                    return\n                }\n            }\n        }\n        this.m_contactFactory.Create(a, b)\n    }\n};\nBox2D.Dynamics.b2ContactManager.prototype.FindNewContacts = function ()\n{\n    var a = this;\n    this.m_broadPhase.UpdatePairs(function (b, c)\n    {\n        a.AddPair(b, c)\n    })\n};\nBox2D.Dynamics.b2ContactManager.prototype.Destroy = function (a)\n{\n    var b = a.GetFixtureA(), c = a.GetFixtureB(), b = b.GetBody(), c = c.GetBody();\n    a.IsTouching() && this.m_contactListener.EndContact(a);\n    0 < a.m_manifold.m_pointCount && (b.SetAwake(!0), c.SetAwake(!0));\n    a.RemoveFromLists();\n    this.m_contactFactory.Destroy(a)\n};\nBox2D.Dynamics.b2ContactManager.prototype.Collide = function ()\n{\n    for (var a = this.m_world.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); a; a = a.GetNextNode())\n    {\n        var b = a.contact, c = b.GetFixtureA(), d = b.GetFixtureB(), e = c.GetBody(), f = d.GetBody();\n        if (e.IsAwake() || f.IsAwake())\n        {\n            if (b.IsFiltering())\n            {\n                if (!f.ShouldCollide(e))\n                {\n                    this.Destroy(b);\n                    continue\n                }\n                if (!this.m_contactFilter.ShouldCollide(c, d))\n                {\n                    this.Destroy(b);\n                    continue\n                }\n                b.ClearFiltering()\n            }\n            this.m_broadPhase.TestOverlap(c.m_proxy, d.m_proxy) ? b.Update(this.m_contactListener) : this.Destroy(b)\n        }\n    }\n};\nBox2D.Dynamics.b2ContactManager.s_evalCP = new Box2D.Collision.b2ContactPoint;\nBox2D.Dynamics.Joints.b2DistanceJoint = function (a)\n{\n    Box2D.Dynamics.Joints.b2Joint.call(this, a);\n    this.m_localAnchor1 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor2 = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_u = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_localAnchor1.SetV(a.localAnchorA);\n    this.m_localAnchor2.SetV(a.localAnchorB);\n    this.m_length = a.length;\n    this.m_frequencyHz = a.frequencyHz;\n    this.m_dampingRatio = a.dampingRatio;\n    this.m_bias = this.m_gamma = this.m_impulse = 0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.GetAnchorA = function ()\n{\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.GetAnchorB = function ()\n{\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.GetReactionForce = function (a)\n{\n    return Box2D.Common.Math.b2Vec2.Get(a * this.m_impulse * this.m_u.x, a * this.m_impulse * this.m_u.y)\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.GetReactionTorque = function ()\n{\n    return 0\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.GetLength = function ()\n{\n    return this.m_length\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.SetLength = function (a)\n{\n    this.m_length = a\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.GetFrequency = function ()\n{\n    return this.m_frequencyHz\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.SetFrequency = function (a)\n{\n    this.m_frequencyHz = a\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.GetDampingRatio = function ()\n{\n    return this.m_dampingRatio\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.SetDampingRatio = function (a)\n{\n    this.m_dampingRatio = a\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.InitVelocityConstraints = function (a)\n{\n    var b, c = 0, d = this.m_bodyA, e = this.m_bodyB;\n    b = d.m_xf.R;\n    var f = this.m_localAnchor1.x - d.m_sweep.localCenter.x, g = this.m_localAnchor1.y - d.m_sweep.localCenter.y, c = b.col1.x * f + b.col2.x * g, g = b.col1.y * f + b.col2.y * g, f = c;\n    b = e.m_xf.R;\n    var h = this.m_localAnchor2.x - e.m_sweep.localCenter.x, i = this.m_localAnchor2.y - e.m_sweep.localCenter.y, c = b.col1.x * h + b.col2.x * i, i = b.col1.y * h + b.col2.y * i, h = c;\n    this.m_u.x = e.m_sweep.c.x + h - d.m_sweep.c.x - f;\n    this.m_u.y = e.m_sweep.c.y + i - d.m_sweep.c.y - g;\n    c = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);\n    c > Box2D.Common.b2Settings.b2_linearSlop ? this.m_u.Multiply(1 / c) : this.m_u.SetZero();\n    b = f * this.m_u.y - g * this.m_u.x;\n    var j = h * this.m_u.y - i * this.m_u.x;\n    b = d.m_invMass + d.m_invI * b * b + e.m_invMass + e.m_invI * j * j;\n    this.m_mass = 0 != b ? 1 / b : 0;\n    if (0 < this.m_frequencyHz)\n    {\n        var c = c - this.m_length, j = 2 * Math.PI * this.m_frequencyHz, k = this.m_mass * j * j;\n        this.m_gamma = a.dt * (2 * this.m_mass * this.m_dampingRatio * j + a.dt * k);\n        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;\n        this.m_bias = c * a.dt * k * this.m_gamma;\n        this.m_mass = b + this.m_gamma;\n        this.m_mass = 0 != this.m_mass ? 1 / this.m_mass : 0\n    }\n    a.warmStarting ? (this.m_impulse *= a.dtRatio, a = this.m_impulse * this.m_u.x, b = this.m_impulse * this.m_u.y, d.m_linearVelocity.x -= d.m_invMass * a, d.m_linearVelocity.y -= d.m_invMass * b, d.m_angularVelocity -= d.m_invI * (f * b - g * a), e.m_linearVelocity.x += e.m_invMass * a, e.m_linearVelocity.y += e.m_invMass * b, e.m_angularVelocity += e.m_invI * (h * b - i * a)) : this.m_impulse = 0\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.SolveVelocityConstraints = function ()\n{\n    var a = this.m_localAnchor1.x - this.m_bodyA.m_sweep.localCenter.x, b = this.m_localAnchor1.y - this.m_bodyA.m_sweep.localCenter.y, c = this.m_bodyA.m_xf.R.col1.x * a + this.m_bodyA.m_xf.R.col2.x * b, b = this.m_bodyA.m_xf.R.col1.y * a + this.m_bodyA.m_xf.R.col2.y * b, a = c, d = this.m_localAnchor2.x - this.m_bodyB.m_sweep.localCenter.x, e = this.m_localAnchor2.y - this.m_bodyB.m_sweep.localCenter.y, c = this.m_bodyB.m_xf.R.col1.x * d + this.m_bodyB.m_xf.R.col2.x * e, e = this.m_bodyB.m_xf.R.col1.y *\n        d + this.m_bodyB.m_xf.R.col2.y * e, d = c, f = -this.m_mass * (this.m_u.x * (this.m_bodyB.m_linearVelocity.x - this.m_bodyB.m_angularVelocity * e - (this.m_bodyA.m_linearVelocity.x - this.m_bodyA.m_angularVelocity * b)) + this.m_u.y * (this.m_bodyB.m_linearVelocity.y + this.m_bodyB.m_angularVelocity * d - (this.m_bodyA.m_linearVelocity.y + this.m_bodyA.m_angularVelocity * a)) + this.m_bias + this.m_gamma * this.m_impulse);\n    this.m_impulse += f;\n    c = f * this.m_u.x;\n    f *= this.m_u.y;\n    this.m_bodyA.m_linearVelocity.x -= this.m_bodyA.m_invMass * c;\n    this.m_bodyA.m_linearVelocity.y -= this.m_bodyA.m_invMass * f;\n    this.m_bodyA.m_angularVelocity -= this.m_bodyA.m_invI * (a * f - b * c);\n    this.m_bodyB.m_linearVelocity.x += this.m_bodyB.m_invMass * c;\n    this.m_bodyB.m_linearVelocity.y += this.m_bodyB.m_invMass * f;\n    this.m_bodyB.m_angularVelocity += this.m_bodyB.m_invI * (d * f - e * c)\n};\nBox2D.Dynamics.Joints.b2DistanceJoint.prototype.SolvePositionConstraints = function ()\n{\n    if (0 < this.m_frequencyHz)\n    {\n        return!0\n    }\n    var a = this.m_localAnchor1.x - this.m_bodyA.m_sweep.localCenter.x, b = this.m_localAnchor1.y - this.m_bodyA.m_sweep.localCenter.y, c = this.m_bodyA.m_xf.R.col1.x * a + this.m_bodyA.m_xf.R.col2.x * b, b = this.m_bodyA.m_xf.R.col1.y * a + this.m_bodyA.m_xf.R.col2.y * b, a = c, d = this.m_localAnchor2.x - this.m_bodyB.m_sweep.localCenter.x, e = this.m_localAnchor2.y - this.m_bodyB.m_sweep.localCenter.y, c = this.m_bodyB.m_xf.R.col1.x * d + this.m_bodyB.m_xf.R.col2.x * e, e = this.m_bodyB.m_xf.R.col1.y *\n        d + this.m_bodyB.m_xf.R.col2.y * e, d = c, f = this.m_bodyB.m_sweep.c.x + d - this.m_bodyA.m_sweep.c.x - a, g = this.m_bodyB.m_sweep.c.y + e - this.m_bodyA.m_sweep.c.y - b, c = Math.sqrt(f * f + g * g), f = f / c, g = g / c, c = Box2D.Common.Math.b2Math.Clamp(c - this.m_length, -Box2D.Common.b2Settings.b2_maxLinearCorrection, Box2D.Common.b2Settings.b2_maxLinearCorrection), h = -this.m_mass * c;\n    this.m_u.Set(f, g);\n    f = h * this.m_u.x;\n    g = h * this.m_u.y;\n    this.m_bodyA.m_sweep.c.x -= this.m_bodyA.m_invMass * f;\n    this.m_bodyA.m_sweep.c.y -= this.m_bodyA.m_invMass * g;\n    this.m_bodyA.m_sweep.a -= this.m_bodyA.m_invI * (a * g - b * f);\n    this.m_bodyB.m_sweep.c.x += this.m_bodyB.m_invMass * f;\n    this.m_bodyB.m_sweep.c.y += this.m_bodyB.m_invMass * g;\n    this.m_bodyB.m_sweep.a += this.m_bodyB.m_invI * (d * g - e * f);\n    this.m_bodyA.SynchronizeTransform();\n    this.m_bodyB.SynchronizeTransform();\n    return Math.abs(c) < Box2D.Common.b2Settings.b2_linearSlop\n};\nBox2D.Dynamics.Joints.b2DistanceJointDef = function ()\n{\n    Box2D.Dynamics.Joints.b2JointDef.call(this);\n    this.localAnchorA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localAnchorB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.type = Box2D.Dynamics.Joints.b2Joint.e_distanceJoint;\n    this.length = 1;\n    this.dampingRatio = this.frequencyHz = 0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);\nBox2D.Dynamics.Joints.b2DistanceJointDef.prototype.Initialize = function (a, b, c, d)\n{\n    this.bodyA = a;\n    this.bodyB = b;\n    this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c));\n    this.localAnchorB.SetV(this.bodyB.GetLocalPoint(d));\n    a = d.x - c.x;\n    c = d.y - c.y;\n    this.length = Math.sqrt(a * a + c * c);\n    this.dampingRatio = this.frequencyHz = 0\n};\nBox2D.Dynamics.Joints.b2DistanceJointDef.prototype.Create = function ()\n{\n    return new Box2D.Dynamics.Joints.b2DistanceJoint(this)\n};\nBox2D.Dynamics.Controllers.b2BuoyancyController = function ()\n{\n    Box2D.Dynamics.Controllers.b2Controller.call(this);\n    this.normal = Box2D.Common.Math.b2Vec2.Get(0, -1);\n    this.density = this.offset = 0;\n    this.velocity = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.linearDrag = 2;\n    this.angularDrag = 1;\n    this.useDensity = !1;\n    this.useWorldGravity = !0;\n    this.gravity = null\n};\ngoog.inherits(Box2D.Dynamics.Controllers.b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);\nBox2D.Dynamics.Controllers.b2BuoyancyController.prototype.Step = function ()\n{\n    this.useWorldGravity && (this.gravity = this.m_world.GetGravity());\n    for (var a = Box2D.Common.Math.b2Vec2.Get(0, 0), b = Box2D.Common.Math.b2Vec2.Get(0, 0), c = Box2D.Common.Math.b2Vec2.Get(0, 0), d = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.awakeBodies); d; d = d.GetNextNode())\n    {\n        b.Set(0, 0);\n        a.Set(0, 0);\n        for (var e = d.body, f = 0, g = 0, h = e.GetFixtureList().GetFirstNode(); h; h = h.GetNextNode())\n        {\n            c.Set(0, 0);\n            var i = h.fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, e.GetTransform(), c), f = f + i;\n            a.x += i * c.x;\n            a.y += i * c.y;\n            var j = 0, j = 1, g = g + i * j;\n            b.x += i * c.x * j;\n            b.y += i * c.y * j\n        }\n        f < Number.MIN_VALUE || (a.x /= f, a.y /= f, b.x /= g, b.y /= g, g = this.gravity.GetNegative(), g.Multiply(this.density * f), e.ApplyForce(g, b), Box2D.Common.Math.b2Vec2.Free(g), g = e.GetLinearVelocityFromWorldPoint(a), g.Subtract(this.velocity), g.Multiply(-this.linearDrag * f), e.ApplyForce(g, a), Box2D.Common.Math.b2Vec2.Free(g), e.ApplyTorque(-e.GetInertia() / e.GetMass() * f * e.GetAngularVelocity() * this.angularDrag))\n    }\n    Box2D.Common.Math.b2Vec2.Free(c);\n    Box2D.Common.Math.b2Vec2.Free(b);\n    Box2D.Common.Math.b2Vec2.Free(a)\n};\nBox2D.Dynamics.Controllers.b2BuoyancyController.prototype.Draw = function (a)\n{\n    var b = Box2D.Common.Math.b2Vec2.Get(this.normal.x * this.offset + 1E3 * this.normal.y, this.normal.y * this.offset - 1E3 * this.normal.x), c = Box2D.Common.Math.b2Vec2.Get(this.normal.x * this.offset - 1E3 * this.normal.y, this.normal.y * this.offset + 1E3 * this.normal.x);\n    a.DrawSegment(b, c, Box2D.Dynamics.Controllers.b2BuoyancyController.color);\n    Box2D.Common.Math.b2Vec2.Free(b);\n    Box2D.Common.Math.b2Vec2.Free(c)\n};\nBox2D.Dynamics.Controllers.b2BuoyancyController.color = new Box2D.Common.b2Color(0, 0, 1);\nBox2D.Dynamics.Controllers.b2GravityController = function ()\n{\n    Box2D.Dynamics.Controllers.b2Controller.call(this);\n    this.G = 1;\n    this.invSqr = !0\n};\ngoog.inherits(Box2D.Dynamics.Controllers.b2GravityController, Box2D.Dynamics.Controllers.b2Controller);\nBox2D.Dynamics.Controllers.b2GravityController.prototype.Step = function ()\n{\n    var a = null, b = null, c = 0, d = null, e = null, f = 0, g = 0, h = 0, f = null;\n    if (this.invSqr)\n    {\n        for (var i = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.allBodies); i; i = i.GetNextNode())\n        {\n            for (var a = i.body, b = a.GetWorldCenter(), c = a.GetMass(), j = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.allBodies); j; j = j.GetNextNode())\n            {\n                if (d = j.body, a.IsAwake() || d.IsAwake())\n                {\n                    e = d.GetWorldCenter(), f = e.x - b.x, g = e.y - b.y, h = f * f + g * g, h < Number.MIN_VALUE || (f = Box2D.Common.Math.b2Vec2.Get(f, g), f.Multiply(this.G / h / Math.sqrt(h) * c * d.GetMass()), a.IsAwake() && a.ApplyForce(f, b), f.Multiply(-1), d.IsAwake() && d.ApplyForce(f, e), Box2D.Common.Math.b2Vec2.Free(f))\n                }\n            }\n        }\n    } else\n    {\n        for (i = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.allBodies); i; i = i.GetNextNode())\n        {\n            a = bodyNode.body;\n            b = a.GetWorldCenter();\n            c = a.GetMass();\n            for (j = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.allBodies); j; j = j.GetNextNode())\n            {\n                if (d = bodyNode.body, a.IsAwake() || d.IsAwake())\n                {\n                    e = d.GetWorldCenter(), f = e.x - b.x, g = e.y - b.y, h = f * f + g * g, h < Number.MIN_VALUE || (f = Box2D.Common.Math.b2Vec2.Get(f, g), f.Multiply(this.G / h * c * d.GetMass()), a.IsAwake() && a.ApplyForce(f, b), f.Multiply(-1), d.IsAwake() && d.ApplyForce(f, e), Box2D.Common.Math.b2Vec2.Free(f))\n                }\n            }\n        }\n    }\n};\nBox2D.Collision.b2WorldManifold = function ()\n{\n\n    this.m_normal = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_points = [];\n    for (var a = this.m_pointCount = 0; a < Box2D.Common.b2Settings.b2_maxManifoldPoints; a++)\n    {\n        this.m_points[a] = Box2D.Common.Math.b2Vec2.Get(0, 0)\n    }\n};\nBox2D.Collision.b2WorldManifold.prototype.Initialize = function (a, b, c, d, e)\n{\n    if (0 != a.m_pointCount)\n    {\n        var f = 0, g, h, i = 0, j = 0, k = 0, l = 0, n = 0;\n        g = 0;\n        switch (a.m_type)\n        {\n            case Box2D.Collision.b2Manifold.e_circles:\n                h = b.R;\n                g = a.m_localPoint;\n                f = b.position.x + h.col1.x * g.x + h.col2.x * g.y;\n                b = b.position.y + h.col1.y * g.x + h.col2.y * g.y;\n                h = d.R;\n                g = a.m_points[0].m_localPoint;\n                a = d.position.x + h.col1.x * g.x + h.col2.x * g.y;\n                d = d.position.y + h.col1.y * g.x + h.col2.y * g.y;\n                g = a - f;\n                h = d - b;\n                i = g * g + h * h;\n                i > Box2D.Common.b2Settings.MIN_VALUE_SQUARED ? (i = Math.sqrt(i), this.m_normal.x = g / i, this.m_normal.y = h / i) : (this.m_normal.x = 1, this.m_normal.y = 0);\n                g = b + c * this.m_normal.y;\n                d -= e * this.m_normal.y;\n                this.m_points[0].x = 0.5 * (f + c * this.m_normal.x + (a - e * this.m_normal.x));\n                this.m_points[0].y = 0.5 * (g + d);\n                break;\n            case Box2D.Collision.b2Manifold.e_faceA:\n                h = b.R;\n                g = a.m_localPlaneNormal;\n                i = h.col1.x * g.x + h.col2.x * g.y;\n                j = h.col1.y * g.x + h.col2.y * g.y;\n                h = b.R;\n                g = a.m_localPoint;\n                k = b.position.x + h.col1.x * g.x + h.col2.x * g.y;\n                l = b.position.y + h.col1.y * g.x + h.col2.y * g.y;\n                this.m_normal.x = i;\n                this.m_normal.y = j;\n                for (f = 0; f < a.m_pointCount; f++)\n                {\n                    h = d.R, g = a.m_points[f].m_localPoint, n = d.position.x + h.col1.x * g.x + h.col2.x * g.y, g = d.position.y + h.col1.y * g.x + h.col2.y * g.y, this.m_points[f].x = n + 0.5 * (c - (n - k) * i - (g - l) * j - e) * i, this.m_points[f].y = g + 0.5 * (c - (n - k) * i - (g - l) * j - e) * j\n                }\n                break;\n            case Box2D.Collision.b2Manifold.e_faceB:\n                h = d.R;\n                g = a.m_localPlaneNormal;\n                i = h.col1.x * g.x + h.col2.x * g.y;\n                j = h.col1.y * g.x + h.col2.y * g.y;\n                h = d.R;\n                g = a.m_localPoint;\n                k = d.position.x + h.col1.x * g.x + h.col2.x * g.y;\n                l = d.position.y + h.col1.y * g.x + h.col2.y * g.y;\n                this.m_normal.x = -i;\n                this.m_normal.y = -j;\n                for (f = 0; f < a.m_pointCount; f++)\n                {\n                    h = b.R, g = a.m_points[f].m_localPoint, n = b.position.x + h.col1.x * g.x + h.col2.x * g.y, g = b.position.y + h.col1.y * g.x + h.col2.y * g.y, this.m_points[f].x = n + 0.5 * (e - (n - k) * i - (g - l) * j - c) * i, this.m_points[f].y = g + 0.5 * (e - (n - k) * i - (g - l) * j - c) * j\n                }\n        }\n    }\n};\nBox2D.Dynamics.Contacts.b2ContactSolver = function ()\n{\n    this.m_constraints = []\n};\nBox2D.Dynamics.Contacts.b2ContactSolver.prototype.Initialize = function (a, b, c)\n{\n    for (this.m_constraintCount = c; this.m_constraints.length < this.m_constraintCount;)\n    {\n        this.m_constraints[this.m_constraints.length] = new Box2D.Dynamics.Contacts.b2ContactConstraint\n    }\n    for (a = 0; a < c; a++)\n    {\n        var d = b[a], e = d.m_fixtureA, f = d.m_fixtureB, g = e.m_shape.m_radius, h = f.m_shape.m_radius, i = e.GetBody(), j = f.GetBody(), k = d.GetManifold(), l = Box2D.Common.b2Settings.b2MixFriction(e.GetFriction(), f.GetFriction()), n = Box2D.Common.b2Settings.b2MixRestitution(e.GetRestitution(), f.GetRestitution()), m = i.m_linearVelocity.x, o = i.m_linearVelocity.y, p = j.m_linearVelocity.x, q = j.m_linearVelocity.y, r = i.m_angularVelocity, x = j.m_angularVelocity;\n        Box2D.Common.b2Settings.b2Assert(0 < k.m_pointCount);\n        Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.Initialize(k, i.m_xf, g, j.m_xf, h);\n        f = Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_normal.x;\n        d = Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_normal.y;\n        e = this.m_constraints[a];\n        e.bodyA = i;\n        e.bodyB = j;\n        e.manifold = k;\n        e.normal.x = f;\n        e.normal.y = d;\n        e.pointCount = k.m_pointCount;\n        e.friction = l;\n        e.restitution = n;\n        e.localPlaneNormal.x = k.m_localPlaneNormal.x;\n        e.localPlaneNormal.y = k.m_localPlaneNormal.y;\n        e.localPoint.x = k.m_localPoint.x;\n        e.localPoint.y = k.m_localPoint.y;\n        e.radius = g + h;\n        e.type = k.m_type;\n        for (g = 0; g < e.pointCount; ++g)\n        {\n            l = k.m_points[g];\n            h = e.points[g];\n            h.normalImpulse = l.m_normalImpulse;\n            h.tangentImpulse = l.m_tangentImpulse;\n            h.localPoint.SetV(l.m_localPoint);\n            var l = h.rA.x = Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_points[g].x - i.m_sweep.c.x, n = h.rA.y = Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_points[g].y - i.m_sweep.c.y, v = h.rB.x = Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_points[g].x - j.m_sweep.c.x, w = h.rB.y = Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold.m_points[g].y - j.m_sweep.c.y, t = l * d - n * f, s = v * d - w * f, t = t * t, s = s * s;\n            h.normalMass = 1 / (i.m_invMass + j.m_invMass + i.m_invI * t + j.m_invI * s);\n            var u = i.m_mass * i.m_invMass + j.m_mass * j.m_invMass, u = u + (i.m_mass * i.m_invI * t + j.m_mass * j.m_invI * s);\n            h.equalizedMass = 1 / u;\n            s = d;\n            u = -f;\n            t = l * u - n * s;\n            s = v * u - w * s;\n            t *= t;\n            s *= s;\n            h.tangentMass = 1 / (i.m_invMass + j.m_invMass + i.m_invI * t + j.m_invI * s);\n            h.velocityBias = 0;\n            l = e.normal.x * (p + -x * w - m - -r * n) + e.normal.y * (q + x * v - o - r * l);\n            l < -Box2D.Common.b2Settings.b2_velocityThreshold && (h.velocityBias += -e.restitution * l)\n        }\n        2 == e.pointCount && (q = e.points[0], p = e.points[1], k = i.m_invMass, i = i.m_invI, m = j.m_invMass, j = j.m_invI, o = q.rA.x * d - q.rA.y * f, q = q.rB.x * d - q.rB.y * f, r = p.rA.x * d - p.rA.y * f, p = p.rB.x * d - p.rB.y * f, f = k + m + i * o * o + j * q * q, d = k + m + i * r * r + j * p * p, j = k + m + i * o * r + j * q * p, f * f < 100 * (f * d - j * j) ? (e.K.col1.Set(f, j), e.K.col2.Set(j, d), e.K.GetInverse(e.normalMass)) : e.pointCount = 1)\n    }\n};\nBox2D.Dynamics.Contacts.b2ContactSolver.prototype.InitVelocityConstraints = function (a)\n{\n    for (var b = 0; b < this.m_constraintCount; ++b)\n    {\n        var c = this.m_constraints[b], d = c.bodyA, e = c.bodyB, f = d.m_invMass, g = d.m_invI, h = e.m_invMass, i = e.m_invI, j = c.normal.x, k = c.normal.y, l = k, n = -j, m = 0, o = 0;\n        if (a.warmStarting)\n        {\n            o = c.pointCount;\n            for (m = 0; m < o; ++m)\n            {\n                var p = c.points[m];\n                p.normalImpulse *= a.dtRatio;\n                p.tangentImpulse *= a.dtRatio;\n                var q = p.normalImpulse * j + p.tangentImpulse * l, r = p.normalImpulse * k + p.tangentImpulse * n;\n                d.m_angularVelocity -= g * (p.rA.x * r - p.rA.y * q);\n                d.m_linearVelocity.x -= f * q;\n                d.m_linearVelocity.y -= f * r;\n                e.m_angularVelocity += i * (p.rB.x * r - p.rB.y * q);\n                e.m_linearVelocity.x += h * q;\n                e.m_linearVelocity.y += h * r\n            }\n        } else\n        {\n            o = c.pointCount;\n            for (m = 0; m < o; ++m)\n            {\n                d = c.points[m], d.normalImpulse = 0, d.tangentImpulse = 0\n            }\n        }\n    }\n};\nBox2D.Dynamics.Contacts.b2ContactSolver.prototype.SolveVelocityConstraints = function ()\n{\n    for (var a = 0; a < this.m_constraintCount; a++)\n    {\n        this.SolveVelocityConstraints_Constraint(this.m_constraints[a])\n    }\n};\nBox2D.Dynamics.Contacts.b2ContactSolver.prototype.SolveVelocityConstraints_Constraint = function (a)\n{\n    for (var b = a.normal.x, c = a.normal.y, d = 0; d < a.pointCount; d++)\n    {\n        Box2D.Dynamics.Contacts.b2ContactSolver.prototype.SolveVelocityConstraints_ConstraintPoint(a, a.points[d])\n    }\n    if (1 == a.pointCount)\n    {\n        var d = a.points[0], e = d.normalImpulse - d.normalMass * ((a.bodyB.m_linearVelocity.x - a.bodyB.m_angularVelocity * d.rB.y - a.bodyA.m_linearVelocity.x + a.bodyA.m_angularVelocity * d.rA.y) * b + (a.bodyB.m_linearVelocity.y + a.bodyB.m_angularVelocity * d.rB.x - a.bodyA.m_linearVelocity.y - a.bodyA.m_angularVelocity * d.rA.x) * c - d.velocityBias), e = 0 < e ? e : 0, f = e - d.normalImpulse, g = f * b, c = f * c;\n        a.bodyA.m_linearVelocity.x -= a.bodyA.m_invMass * g;\n        a.bodyA.m_linearVelocity.y -= a.bodyA.m_invMass * c;\n        a.bodyA.m_angularVelocity -= a.bodyA.m_invI * (d.rA.x * c - d.rA.y * g);\n        a.bodyB.m_linearVelocity.x += a.bodyB.m_invMass * g;\n        a.bodyB.m_linearVelocity.y += a.bodyB.m_invMass * c;\n        a.bodyB.m_angularVelocity += a.bodyB.m_invI * (d.rB.x * c - d.rB.y * g);\n        d.normalImpulse = e\n    } else\n    {\n        for (var d = a.points[0], e = a.points[1], f = d.normalImpulse, g = e.normalImpulse, h = (a.bodyB.m_linearVelocity.x - a.bodyB.m_angularVelocity * d.rB.y - a.bodyA.m_linearVelocity.x + a.bodyA.m_angularVelocity * d.rA.y) * b + (a.bodyB.m_linearVelocity.y + a.bodyB.m_angularVelocity * d.rB.x - a.bodyA.m_linearVelocity.y - a.bodyA.m_angularVelocity * d.rA.x) * c - d.velocityBias, c = (a.bodyB.m_linearVelocity.x - a.bodyB.m_angularVelocity * e.rB.y - a.bodyA.m_linearVelocity.x + a.bodyA.m_angularVelocity *\n            e.rA.y) * b + (a.bodyB.m_linearVelocity.y + a.bodyB.m_angularVelocity * e.rB.x - a.bodyA.m_linearVelocity.y - a.bodyA.m_angularVelocity * e.rA.x) * c - e.velocityBias, h = h - (a.K.col1.x * f + a.K.col2.x * g), c = c - (a.K.col1.y * f + a.K.col2.y * g); ;)\n        {\n            b = -(a.normalMass.col1.x * h + a.normalMass.col2.x * c);\n            if (0 <= b)\n            {\n                var i = -(a.normalMass.col1.y * h + a.normalMass.col2.y * c);\n                if (0 <= i)\n                {\n                    this.SolveVelocityConstraints_ConstraintPointUpdate(a, d, e, b - f, i - g);\n                    d.normalImpulse = b;\n                    e.normalImpulse = i;\n                    break\n                }\n            }\n            b = -d.normalMass * h;\n            if (0 <= b && 0 <= a.K.col1.y * b + c)\n            {\n                this.SolveVelocityConstraints_ConstraintPointUpdate(a, d, e, b - f, -g);\n                d.normalImpulse = b;\n                e.normalImpulse = 0;\n                break\n            }\n            b = -e.normalMass * c;\n            if (0 <= b && 0 <= a.K.col2.x * b + h)\n            {\n                this.SolveVelocityConstraints_ConstraintPointUpdate(a, d, e, -f, b - g);\n                d.normalImpulse = 0;\n                e.normalImpulse = b;\n                break\n            }\n            if (0 <= h && 0 <= c)\n            {\n                this.SolveVelocityConstraints_ConstraintPointUpdate(a, d, e, -f, -g);\n                d.normalImpulse = 0;\n                e.normalImpulse = 0;\n                break\n            }\n            break\n        }\n    }\n};\nBox2D.Dynamics.Contacts.b2ContactSolver.prototype.SolveVelocityConstraints_ConstraintPoint = function (a, b)\n{\n    var c = a.normal.y, d = -a.normal.x, e = a.friction * b.normalImpulse, e = Box2D.Common.Math.b2Math.Clamp(b.tangentImpulse - b.tangentMass * ((a.bodyB.m_linearVelocity.x - a.bodyB.m_angularVelocity * b.rB.y - a.bodyA.m_linearVelocity.x + a.bodyA.m_angularVelocity * b.rA.y) * c + (a.bodyB.m_linearVelocity.y + a.bodyB.m_angularVelocity * b.rB.x - a.bodyA.m_linearVelocity.y - a.bodyA.m_angularVelocity * b.rA.x) * d), -e, e), f = e - b.tangentImpulse, c = f * c, d = f * d;\n    a.bodyA.m_linearVelocity.x -= a.bodyA.m_invMass * c;\n    a.bodyA.m_linearVelocity.y -= a.bodyA.m_invMass * d;\n    a.bodyA.m_angularVelocity -= a.bodyA.m_invI * (b.rA.x * d - b.rA.y * c);\n    a.bodyB.m_linearVelocity.x += a.bodyB.m_invMass * c;\n    a.bodyB.m_linearVelocity.y += a.bodyB.m_invMass * d;\n    a.bodyB.m_angularVelocity += a.bodyB.m_invI * (b.rB.x * d - b.rB.y * c);\n    b.tangentImpulse = e\n};\nBox2D.Dynamics.Contacts.b2ContactSolver.prototype.SolveVelocityConstraints_ConstraintPointUpdate = function (a, b, c, d, e)\n{\n    var f = d * a.normal.x, d = d * a.normal.y, g = e * a.normal.x, e = e * a.normal.y;\n    a.bodyA.m_linearVelocity.x -= a.bodyA.m_invMass * (f + g);\n    a.bodyA.m_linearVelocity.y -= a.bodyA.m_invMass * (d + e);\n    a.bodyA.m_angularVelocity -= a.bodyA.m_invI * (b.rA.x * d - b.rA.y * f + c.rA.x * e - c.rA.y * g);\n    a.bodyB.m_linearVelocity.x += a.bodyB.m_invMass * (f + g);\n    a.bodyB.m_linearVelocity.y += a.bodyB.m_invMass * (d + e);\n    a.bodyB.m_angularVelocity += a.bodyB.m_invI * (b.rB.x * d - b.rB.y * f + c.rB.x * e - c.rB.y * g);\n    b.normalImpulse = 0;\n    c.normalImpulse = 0\n};\nBox2D.Dynamics.Contacts.b2ContactSolver.prototype.FinalizeVelocityConstraints = function ()\n{\n    for (var a = 0; a < this.m_constraintCount; ++a)\n    {\n        for (var b = this.m_constraints[a], c = b.manifold, d = 0; d < b.pointCount; ++d)\n        {\n            var e = c.m_points[d], f = b.points[d];\n            e.m_normalImpulse = f.normalImpulse;\n            e.m_tangentImpulse = f.tangentImpulse\n        }\n    }\n};\nBox2D.Dynamics.Contacts.b2ContactSolver.prototype.SolvePositionConstraints = function (a)\n{\n    void 0 === a && (a = 0);\n    for (var b = 0, c = 0; c < this.m_constraintCount; c++)\n    {\n        var d = this.m_constraints[c], e = d.bodyA, f = d.bodyB, g = e.m_mass * e.m_invMass, h = e.m_mass * e.m_invI, i = f.m_mass * f.m_invMass, j = f.m_mass * f.m_invI;\n        Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.Initialize(d);\n        for (var k = Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.m_normal, l = 0; l < d.pointCount; l++)\n        {\n            var n = d.points[l], m = Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.m_points[l], o = Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.m_separations[l], p = m.x - e.m_sweep.c.x, q = m.y - e.m_sweep.c.y, r = m.x - f.m_sweep.c.x, m = m.y - f.m_sweep.c.y, b = b < o ? b : o, o = Box2D.Common.Math.b2Math.Clamp(a * (o + Box2D.Common.b2Settings.b2_linearSlop), -Box2D.Common.b2Settings.b2_maxLinearCorrection, 0), o = -n.equalizedMass * o, n = o * k.x, o = o * k.y;\n            e.m_sweep.c.x -= g * n;\n            e.m_sweep.c.y -= g * o;\n            e.m_sweep.a -= h * (p * o - q * n);\n            e.SynchronizeTransform();\n            f.m_sweep.c.x += i * n;\n            f.m_sweep.c.y += i * o;\n            f.m_sweep.a += j * (r * o - m * n);\n            f.SynchronizeTransform()\n        }\n    }\n    return b > -1.5 * Box2D.Common.b2Settings.b2_linearSlop\n};\nBox2D.Dynamics.Contacts.b2ContactSolver.prototype.SolvePositionConstraints_NEW = function (a)\n{\n    void 0 === a && (a = 0);\n    for (var b = 0, c = 0; c < this.m_constraintCount; c++)\n    {\n        var d = this.m_constraints[c], e = d.bodyA, f = d.bodyB, g = e.m_mass * e.m_invMass, h = e.m_mass * e.m_invI, i = f.m_mass * f.m_invMass, j = f.m_mass * f.m_invI;\n        Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.Initialize(d);\n        for (var k = Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.m_normal, l = 0; l < d.pointCount; l++)\n        {\n            var n = d.points[l], m = Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.m_points[l], o = Box2D.Dynamics.Contacts.b2ContactSolver.s_psm.m_separations[l], p = m.x - e.m_sweep.c.x, q = m.y - e.m_sweep.c.y, r = m.x - f.m_sweep.c.x, m = m.y - f.m_sweep.c.y;\n            o < b && (b = o);\n            0 != a && Box2D.Common.Math.b2Math.Clamp(a * (o + Box2D.Common.b2Settings.b2_linearSlop), -Box2D.Common.b2Settings.b2_maxLinearCorrection, 0);\n            o = 0 * -n.equalizedMass;\n            n = o * k.x;\n            o *= k.y;\n            e.m_sweep.c.x -= g * n;\n            e.m_sweep.c.y -= g * o;\n            e.m_sweep.a -= h * (p * o - q * n);\n            e.SynchronizeTransform();\n            f.m_sweep.c.x += i * n;\n            f.m_sweep.c.y += i * o;\n            f.m_sweep.a += j * (r * o - m * n);\n            f.SynchronizeTransform()\n        }\n    }\n    return b > -1.5 * Box2D.Common.b2Settings.b2_linearSlop\n};\nBox2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new Box2D.Collision.b2WorldManifold;\nBox2D.Dynamics.Contacts.b2ContactSolver.s_psm = new Box2D.Dynamics.Contacts.b2PositionSolverManifold;\nBox2D.Dynamics.Controllers.b2ControllerListNode = function (a)\n{\n    this.controller = a;\n    this.previous = this.next = null\n};\nBox2D.Dynamics.Controllers.b2ControllerListNode.prototype.SetNextNode = function (a)\n{\n    this.next = a\n};\nBox2D.Dynamics.Controllers.b2ControllerListNode.prototype.SetPreviousNode = function (a)\n{\n    this.previous = a\n};\nBox2D.Dynamics.Controllers.b2ControllerListNode.prototype.GetNextNode = function ()\n{\n    return this.next\n};\nBox2D.Dynamics.Controllers.b2ControllerListNode.prototype.GetPreviousNode = function ()\n{\n    return this.previous\n};\nBox2D.Dynamics.Controllers.b2ControllerList = function ()\n{\n    this.controllerLastNode = this.controllerFirstNode = null;\n    this.controllerNodeLookup = {};\n    this.controllerCount = 0\n};\nBox2D.Dynamics.Controllers.b2ControllerList.prototype.GetFirstNode = function ()\n{\n    return this.controllerFirstNode\n};\nBox2D.Dynamics.Controllers.b2ControllerList.prototype.AddController = function (a)\n{\n    var b = a.ID;\n    if (null == this.controllerNodeLookup[b])\n    {\n        var a = new Box2D.Dynamics.Controllers.b2ControllerListNode(a), c = this.controllerLastNode;\n        null != c ? c.SetNextNode(a) : this.controllerFirstNode = a;\n        a.SetPreviousNode(c);\n        this.controllerLastNode = a;\n        this.controllerNodeLookup[b] = a;\n        this.controllerCount++\n    }\n};\nBox2D.Dynamics.Controllers.b2ControllerList.prototype.RemoveController = function (a)\n{\n    var a = a.ID, b = this.controllerNodeLookup[a];\n    if (null != b)\n    {\n        var c = b.GetPreviousNode(), b = b.GetNextNode();\n        null == c ? this.controllerFirstNode = b : c.SetNextNode(b);\n        null == b ? this.controllerLastNode = c : b.SetPreviousNode(c);\n        delete this.controllerNodeLookup[a];\n        this.controllerCount--\n    }\n};\nBox2D.Dynamics.Controllers.b2ControllerList.prototype.GetControllerCount = function ()\n{\n    return this.controllerCount\n};\nBox2D.Dynamics.b2FixtureDef = function ()\n{\n\n    this.filter = new Box2D.Dynamics.b2FilterData;\n    this.filter.categoryBits = 1;\n    this.filter.maskBits = 65535;\n    this.filter.groupIndex = 0;\n    this.shape = null;\n    this.friction = 0.2;\n    this.density = this.restitution = 0;\n    this.isSensor = !1\n};\nBox2D.Dynamics.b2Body = function (a, b)\n{\n\n    this.ID = \"Body\" + Box2D.Dynamics.b2Body.NEXT_ID++;\n    this.m_xf = new Box2D.Common.Math.b2Transform;\n    this.m_xf.position.SetV(a.position);\n    this.m_xf.R.Set(a.angle);\n    this.m_sweep = new Box2D.Common.Math.b2Sweep;\n    this.m_sweep.localCenter.SetZero();\n    this.m_sweep.t0 = 1;\n    this.m_sweep.a0 = this.m_sweep.a = a.angle;\n    this.m_sweep.c.x = this.m_xf.R.col1.x * this.m_sweep.localCenter.x + this.m_xf.R.col2.x * this.m_sweep.localCenter.y;\n    this.m_sweep.c.y = this.m_xf.R.col1.y * this.m_sweep.localCenter.x + this.m_xf.R.col2.y * this.m_sweep.localCenter.y;\n    this.m_sweep.c.x += this.m_xf.position.x;\n    this.m_sweep.c.y += this.m_xf.position.y;\n    this.m_sweep.c0.SetV(this.m_sweep.c);\n    this.m_linearVelocity = a.linearVelocity.Copy();\n    this.m_force = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.m_bullet = a.bullet;\n    this.m_fixedRotation = a.fixedRotation;\n    this.m_allowSleep = a.allowSleep;\n    this.m_awake = a.awake;\n    this.m_active = a.active;\n    this.m_world = b;\n    this.m_userData = null;\n    this.m_jointList = null;\n    this.contactList = new Box2D.Dynamics.Contacts.b2ContactList;\n    this.controllerList = new Box2D.Dynamics.Controllers.b2ControllerList;\n    this.m_controllerCount = 0;\n    this.m_angularVelocity = a.angularVelocity;\n    this.m_linearDamping = a.linearDamping;\n    this.m_angularDamping = a.angularDamping;\n    this.m_sleepTime = this.m_torque = 0;\n    this.m_type = a.type;\n    this.m_mass = this.m_type == Box2D.Dynamics.b2BodyDef.b2_dynamicBody ? 1 : 0;\n    this.m_invMass = this.m_type == Box2D.Dynamics.b2BodyDef.b2_dynamicBody ? 1 : 0;\n    this.m_invI = this.m_I = 0;\n    this.m_inertiaScale = a.inertiaScale;\n    this.fixtureList = new Box2D.Dynamics.b2FixtureList;\n    this.m_lists = []\n};\nBox2D.Dynamics.b2Body.prototype.CreateFixture = function (a)\n{\n    Box2D.Common.b2Settings.b2Assert(!this.m_world.IsLocked());\n    a = new Box2D.Dynamics.b2Fixture(this, this.m_xf, a);\n    this.m_active && a.CreateProxy(this.m_world.m_contactManager.m_broadPhase, this.m_xf);\n    this.fixtureList.AddFixture(a);\n    a.m_body = this;\n    0 < a.m_density && this.ResetMassData();\n    this.m_world.m_newFixture = !0;\n    return a\n};\nBox2D.Dynamics.b2Body.prototype.CreateFixture2 = function (a, b)\n{\n    var c = new Box2D.Dynamics.b2FixtureDef;\n    c.shape = a;\n    c.density = b;\n    return this.CreateFixture(c)\n};\nBox2D.Dynamics.b2Body.prototype.Destroy = function ()\n{\n    Box2D.Common.Math.b2Vec2.Free(this.m_linearVelocity);\n    Box2D.Common.Math.b2Vec2.Free(this.m_force)\n};\nBox2D.Dynamics.b2Body.prototype.DestroyFixture = function (a)\n{\n    Box2D.Common.b2Settings.b2Assert(!this.m_world.IsLocked());\n    this.fixtureList.RemoveFixture(a);\n    for (var b = this.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); b; b = b.GetNextNode())\n    {\n        (a == b.contact.GetFixtureA() || a == b.contact.GetFixtureB()) && this.m_world.m_contactManager.Destroy(b.contact)\n    }\n    this.m_active && a.DestroyProxy(this.m_world.m_contactManager.m_broadPhase);\n    a.Destroy();\n    this.ResetMassData()\n};\nBox2D.Dynamics.b2Body.prototype.SetPositionAndAngle = function (a, b)\n{\n    Box2D.Common.b2Settings.b2Assert(!this.m_world.IsLocked());\n    this.m_xf.R.Set(b);\n    this.m_xf.position.SetV(a);\n    var c = this.m_xf.R, d = this.m_sweep.localCenter;\n    this.m_sweep.c.x = c.col1.x * d.x + c.col2.x * d.y;\n    this.m_sweep.c.y = c.col1.y * d.x + c.col2.y * d.y;\n    this.m_sweep.c.x += this.m_xf.position.x;\n    this.m_sweep.c.y += this.m_xf.position.y;\n    this.m_sweep.c0.SetV(this.m_sweep.c);\n    this.m_sweep.a0 = this.m_sweep.a = b;\n    c = this.m_world.m_contactManager.m_broadPhase;\n    for (d = this.fixtureList.GetFirstNode(); d; d = d.GetNextNode())\n    {\n        d.fixture.Synchronize(c, this.m_xf, this.m_xf)\n    }\n    this.m_world.m_contactManager.FindNewContacts()\n};\nBox2D.Dynamics.b2Body.prototype.SetTransform = function (a)\n{\n    this.SetPositionAndAngle(a.position, a.GetAngle())\n};\nBox2D.Dynamics.b2Body.prototype.GetTransform = function ()\n{\n    return this.m_xf\n};\nBox2D.Dynamics.b2Body.prototype.GetPosition = function ()\n{\n    return this.m_xf.position\n};\nBox2D.Dynamics.b2Body.prototype.SetPosition = function (a)\n{\n    this.SetPositionAndAngle(a, this.GetAngle())\n};\nBox2D.Dynamics.b2Body.prototype.GetAngle = function ()\n{\n    return this.m_sweep.a\n};\nBox2D.Dynamics.b2Body.prototype.SetAngle = function (a)\n{\n    this.SetPositionAndAngle(this.GetPosition(), a)\n};\nBox2D.Dynamics.b2Body.prototype.GetWorldCenter = function ()\n{\n    return this.m_sweep.c\n};\nBox2D.Dynamics.b2Body.prototype.GetUserData = function ()\n{\n    return this.m_userData;\n};\nBox2D.Dynamics.b2Body.prototype.SetUserData = function (data)\n{\n    this.m_userData = data;\n};\nBox2D.Dynamics.b2Body.prototype.GetLocalCenter = function ()\n{\n    return this.m_sweep.localCenter\n};\nBox2D.Dynamics.b2Body.prototype.SetLinearVelocity = function (a)\n{\n    this.m_type != Box2D.Dynamics.b2BodyDef.b2_staticBody && this.m_linearVelocity.SetV(a)\n};\nBox2D.Dynamics.b2Body.prototype.GetLinearVelocity = function ()\n{\n    return this.m_linearVelocity\n};\nBox2D.Dynamics.b2Body.prototype.SetAngularVelocity = function (a)\n{\n    this.m_type != Box2D.Dynamics.b2BodyDef.b2_staticBody && (this.m_angularVelocity = a)\n};\nBox2D.Dynamics.b2Body.prototype.GetAngularVelocity = function ()\n{\n    return this.m_angularVelocity\n};\nBox2D.Dynamics.b2Body.prototype.GetDefinition = function ()\n{\n    var a = new Box2D.Dynamics.b2BodyDef;\n    a.type = this.GetType();\n    a.allowSleep = this.m_allowSleep;\n    a.angle = this.GetAngle();\n    a.angularDamping = this.m_angularDamping;\n    a.angularVelocity = this.m_angularVelocity;\n    a.fixedRotation = this.m_fixedRotation;\n    a.bullet = this.m_bullet;\n    a.active = this.m_active;\n    a.awake = this.m_awake;\n    a.linearDamping = this.m_linearDamping;\n    a.linearVelocity.SetV(this.GetLinearVelocity());\n    a.position.SetV(this.GetPosition());\n    return a\n};\nBox2D.Dynamics.b2Body.prototype.ApplyForce = function (a, b)\n{\n    this.m_type == Box2D.Dynamics.b2BodyDef.b2_dynamicBody && (this.SetAwake(!0), this.m_force.x += a.x, this.m_force.y += a.y, this.m_torque += (b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x)\n};\nBox2D.Dynamics.b2Body.prototype.ApplyTorque = function (a)\n{\n    this.m_type == Box2D.Dynamics.b2BodyDef.b2_dynamicBody && (this.SetAwake(!0), this.m_torque += a)\n};\nBox2D.Dynamics.b2Body.prototype.ApplyImpulse = function (a, b)\n{\n    this.m_type == Box2D.Dynamics.b2BodyDef.b2_dynamicBody && (this.SetAwake(!0), this.m_linearVelocity.x += this.m_invMass * a.x, this.m_linearVelocity.y += this.m_invMass * a.y, this.m_angularVelocity += this.m_invI * ((b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x))\n};\nBox2D.Dynamics.b2Body.prototype.Split = function (a)\n{\n    for (var b = this.GetLinearVelocity().Copy(), c = this.GetAngularVelocity(), d = this.GetWorldCenter(), e = this.m_world.CreateBody(this.GetDefinition()), f = this.fixtureList.GetFirstNode(); f; f = f.GetNextNode())\n    {\n        var g = f.fixture;\n        a(g) && (this.fixtureList.RemoveFixture(g), e.fixtureList.AddFixture(g))\n    }\n    this.ResetMassData();\n    e.ResetMassData();\n    f = this.GetWorldCenter();\n    a = e.GetWorldCenter();\n    g = Box2D.Common.Math.b2Math.SubtractVV(f, d);\n    f = Box2D.Common.Math.b2Math.CrossFV(c, g);\n    Box2D.Common.Math.b2Vec2.Free(g);\n    g = Box2D.Common.Math.b2Math.AddVV(b, f);\n    Box2D.Common.Math.b2Vec2.Free(f);\n    this.SetLinearVelocity(g);\n    Box2D.Common.Math.b2Vec2.Free(g);\n    a = Box2D.Common.Math.b2Math.SubtractVV(a, d);\n    d = Box2D.Common.Math.b2Math.CrossFV(c, a);\n    Box2D.Common.Math.b2Vec2.Free(a);\n    a = Box2D.Common.Math.b2Math.AddVV(b, d);\n    Box2D.Common.Math.b2Vec2.Free(d);\n    e.SetLinearVelocity(a);\n    Box2D.Common.Math.b2Vec2.Free(a);\n    Box2D.Common.Math.b2Vec2.Free(b);\n    this.SetAngularVelocity(c);\n    e.SetAngularVelocity(c);\n    this.SynchronizeFixtures();\n    e.SynchronizeFixtures();\n    return e\n};\nBox2D.Dynamics.b2Body.prototype.Merge = function (a)\n{\n    for (var b = a.fixtureList.GetFirstNode(); b; b = b.GetNextNode())\n    {\n        this.fixtureList.AddFixture(b.fixture), a.fixtureList.RemoveFixture(b.fixture)\n    }\n    a.ResetMassData();\n    this.ResetMassData();\n    this.SynchronizeFixtures()\n};\nBox2D.Dynamics.b2Body.prototype.GetMass = function ()\n{\n    return this.m_mass\n};\nBox2D.Dynamics.b2Body.prototype.GetInertia = function ()\n{\n    return this.m_I\n};\nBox2D.Dynamics.b2Body.prototype.GetMassData = function (a)\n{\n    a || (a = Box2D.Collision.Shapes.b2MassData.Get());\n    a.mass = this.m_mass;\n    a.I = this.m_I;\n    a.center.SetV(this.m_sweep.localCenter);\n    return a\n};\nBox2D.Dynamics.b2Body.prototype.SetMassData = function (a)\n{\n    Box2D.Common.b2Settings.b2Assert(!this.m_world.IsLocked());\n    if (this.m_type == Box2D.Dynamics.b2BodyDef.b2_dynamicBody)\n    {\n        this.m_invI = this.m_I = this.m_invMass = 0;\n        this.m_mass = a.mass;\n        0 >= this.m_mass && (this.m_mass = 1);\n        this.m_invMass = 1 / this.m_mass;\n        0 < a.I && !this.m_fixedRotation && (this.m_I = a.I - this.m_mass * (a.center.x * a.center.x + a.center.y * a.center.y), this.m_invI = 1 / this.m_I);\n        var b = this.m_sweep.c.Copy();\n        this.m_sweep.localCenter.SetV(a.center);\n        this.m_sweep.c0.SetV(Box2D.Common.Math.b2Math.MulX(this.m_xf, this.m_sweep.localCenter));\n        this.m_sweep.c.SetV(this.m_sweep.c0);\n        this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - b.y);\n        this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - b.x);\n        Box2D.Common.Math.b2Vec2.Free(b)\n    }\n};\nBox2D.Dynamics.b2Body.prototype.ResetMassData = function ()\n{\n    this.m_invI = this.m_I = this.m_invMass = this.m_mass = 0;\n    this.m_sweep.localCenter.SetZero();\n    if (!(this.m_type == Box2D.Dynamics.b2BodyDef.b2_staticBody || this.m_type == Box2D.Dynamics.b2BodyDef.b2_kinematicBody))\n    {\n        for (var a = Box2D.Common.Math.b2Vec2.Get(0, 0), b = this.fixtureList.GetFirstNode(); b; b = b.GetNextNode())\n        {\n            var c = b.fixture;\n            0 != c.m_density && (c = c.GetMassData(), this.m_mass += c.mass, a.x += c.center.x * c.mass, a.y += c.center.y * c.mass, this.m_I += c.I)\n        }\n        0 < this.m_mass ? (this.m_invMass = 1 / this.m_mass, a.x *= this.m_invMass, a.y *= this.m_invMass) : this.m_invMass = this.m_mass = 1;\n        0 < this.m_I && !this.m_fixedRotation ? (this.m_I -= this.m_mass * (a.x * a.x + a.y * a.y), this.m_I *= this.m_inertiaScale, Box2D.Common.b2Settings.b2Assert(0 < this.m_I), this.m_invI = 1 / this.m_I) : this.m_invI = this.m_I = 0;\n        b = this.m_sweep.c.Copy();\n        this.m_sweep.localCenter.SetV(a);\n        this.m_sweep.c0.SetV(Box2D.Common.Math.b2Math.MulX(this.m_xf, this.m_sweep.localCenter));\n        this.m_sweep.c.SetV(this.m_sweep.c0);\n        this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - b.y);\n        this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - b.x);\n        Box2D.Common.Math.b2Vec2.Free(a);\n        Box2D.Common.Math.b2Vec2.Free(b)\n    }\n};\nBox2D.Dynamics.b2Body.prototype.GetWorldPoint = function (a)\n{\n    var b = this.m_xf.R, a = Box2D.Common.Math.b2Vec2.Get(b.col1.x * a.x + b.col2.x * a.y, b.col1.y * a.x + b.col2.y * a.y);\n    a.x += this.m_xf.position.x;\n    a.y += this.m_xf.position.y;\n    return a\n};\nBox2D.Dynamics.b2Body.prototype.GetWorldVector = function (a)\n{\n    return Box2D.Common.Math.b2Math.MulMV(this.m_xf.R, a)\n};\nBox2D.Dynamics.b2Body.prototype.GetLocalPoint = function (a)\n{\n    return Box2D.Common.Math.b2Math.MulXT(this.m_xf, a)\n};\nBox2D.Dynamics.b2Body.prototype.GetLocalVector = function (a)\n{\n    return Box2D.Common.Math.b2Math.MulTMV(this.m_xf.R, a)\n};\nBox2D.Dynamics.b2Body.prototype.GetLinearVelocityFromWorldPoint = function (a)\n{\n    return Box2D.Common.Math.b2Vec2.Get(this.m_linearVelocity.x - this.m_angularVelocity * (a.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (a.x - this.m_sweep.c.x))\n};\nBox2D.Dynamics.b2Body.prototype.GetLinearVelocityFromLocalPoint = function (a)\n{\n    var b = this.m_xf.R, a = Box2D.Common.Math.b2Vec2.Get(b.col1.x * a.x + b.col2.x * a.y, b.col1.y * a.x + b.col2.y * a.y);\n    a.x += this.m_xf.position.x;\n    a.y += this.m_xf.position.y;\n    b = Box2D.Common.Math.b2Vec2.Get(this.m_linearVelocity.x - this.m_angularVelocity * (a.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (a.x - this.m_sweep.c.x));\n    Box2D.Common.Math.b2Vec2.Free(a);\n    return b\n};\nBox2D.Dynamics.b2Body.prototype.GetLinearDamping = function ()\n{\n    return this.m_linearDamping\n};\nBox2D.Dynamics.b2Body.prototype.SetLinearDamping = function (a)\n{\n    this.m_linearDamping = a\n};\nBox2D.Dynamics.b2Body.prototype.GetAngularDamping = function ()\n{\n    return this.m_angularDamping\n};\nBox2D.Dynamics.b2Body.prototype.SetAngularDamping = function (a)\n{\n    this.m_angularDamping = a\n};\nBox2D.Dynamics.b2Body.prototype.SetType = function (a)\n{\n    if (this.m_type != a)\n    {\n        this.m_type = a;\n        this.ResetMassData();\n        this.m_type == Box2D.Dynamics.b2BodyDef.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0);\n        this.SetAwake(!0);\n        this.m_force.SetZero();\n        this.m_torque = 0;\n        for (a = this.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); a; a = a.GetNextNode())\n        {\n            a.contact.FlagForFiltering()\n        }\n        for (a = 0; a < this.m_lists.length; a++)\n        {\n            this.m_lists[a].UpdateBody(this)\n        }\n    }\n};\nBox2D.Dynamics.b2Body.prototype.GetType = function ()\n{\n    return this.m_type\n};\nBox2D.Dynamics.b2Body.prototype.SetBullet = function (a)\n{\n    this.m_bullet = a\n};\nBox2D.Dynamics.b2Body.prototype.IsBullet = function ()\n{\n    return this.m_bullet\n};\nBox2D.Dynamics.b2Body.prototype.SetSleepingAllowed = function (a)\n{\n    (this.m_allowSleep = a) || this.SetAwake(!0)\n};\nBox2D.Dynamics.b2Body.prototype.SetAwake = function (a)\n{\n    if (this.m_awake != a)\n    {\n        this.m_awake = a;\n        this.m_sleepTime = 0;\n        a || (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0);\n        for (a = 0; a < this.m_lists.length; a++)\n        {\n            this.m_lists[a].UpdateBody(this)\n        }\n    }\n};\nBox2D.Dynamics.b2Body.prototype.IsAwake = function ()\n{\n    return this.m_awake\n};\nBox2D.Dynamics.b2Body.prototype.SetFixedRotation = function (a)\n{\n    this.m_fixedRotation = a;\n    this.ResetMassData()\n};\nBox2D.Dynamics.b2Body.prototype.IsFixedRotation = function ()\n{\n    return this.m_fixedRotation\n};\nBox2D.Dynamics.b2Body.prototype.SetActive = function (a)\n{\n    if (a != this.m_active)\n    {\n        if (a)\n        {\n            this.m_active = !0;\n            for (var a = this.m_world.m_contactManager.m_broadPhase, b = this.fixtureList.GetFirstNode(); b; b = b.GetNextNode())\n            {\n                b.fixture.CreateProxy(a, this.m_xf)\n            }\n        } else\n        {\n            this.m_active = !1;\n            a = this.m_world.m_contactManager.m_broadPhase;\n            for (b = this.fixtureList.GetFirstNode(); b; b = b.GetNextNode())\n            {\n                b.fixture.DestroyProxy(a)\n            }\n            for (a = this.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); a; a = a.GetNextNode())\n            {\n                this.m_world.m_contactManager.Destroy(a.contact)\n            }\n        }\n        for (a = 0; a < this.m_lists.length; a++)\n        {\n            this.m_lists[a].UpdateBody(this)\n        }\n    }\n};\nBox2D.Dynamics.b2Body.prototype.IsActive = function ()\n{\n    return this.m_active\n};\nBox2D.Dynamics.b2Body.prototype.IsSleepingAllowed = function ()\n{\n    return this.m_allowSleep\n};\nBox2D.Dynamics.b2Body.prototype.GetFixtureList = function ()\n{\n    return this.fixtureList\n};\nBox2D.Dynamics.b2Body.prototype.GetJointList = function ()\n{\n    return this.m_jointList\n};\nBox2D.Dynamics.b2Body.prototype.GetControllerList = function ()\n{\n    return this.controllerList\n};\nBox2D.Dynamics.b2Body.prototype.AddController = function (a)\n{\n    this.controllerList.AddController(a)\n};\nBox2D.Dynamics.b2Body.prototype.RemoveController = function (a)\n{\n    this.controllerList.RemoveController(a)\n};\nBox2D.Dynamics.b2Body.prototype.GetContactList = function ()\n{\n    return this.contactList\n};\nBox2D.Dynamics.b2Body.prototype.GetWorld = function ()\n{\n    return this.m_world\n};\nBox2D.Dynamics.b2Body.prototype.SynchronizeFixtures = function ()\n{\n    var a = Box2D.Dynamics.b2Body.s_xf1;\n    a.R.Set(this.m_sweep.a0);\n    var b = a.R, c = this.m_sweep.localCenter;\n    a.position.x = this.m_sweep.c0.x - (b.col1.x * c.x + b.col2.x * c.y);\n    a.position.y = this.m_sweep.c0.y - (b.col1.y * c.x + b.col2.y * c.y);\n    b = this.m_world.m_contactManager.m_broadPhase;\n    for (c = this.fixtureList.GetFirstNode(); c; c = c.GetNextNode())\n    {\n        c.fixture.Synchronize(b, a, this.m_xf)\n    }\n};\nBox2D.Dynamics.b2Body.prototype.SynchronizeTransform = function ()\n{\n    this.m_xf.R.Set(this.m_sweep.a);\n    var a = this.m_xf.R, b = this.m_sweep.localCenter;\n    this.m_xf.position.x = this.m_sweep.c.x - (a.col1.x * b.x + a.col2.x * b.y);\n    this.m_xf.position.y = this.m_sweep.c.y - (a.col1.y * b.x + a.col2.y * b.y)\n};\nBox2D.Dynamics.b2Body.prototype.ShouldCollide = function (a)\n{\n    if (this.m_type != Box2D.Dynamics.b2BodyDef.b2_dynamicBody && a.m_type != Box2D.Dynamics.b2BodyDef.b2_dynamicBody)\n    {\n        return!1\n    }\n    for (var b = this.m_jointList; b; b = b.next)\n    {\n        if (b.other == a && !1 == b.joint.m_collideConnected)\n        {\n            return!1\n        }\n    }\n    return!0\n};\nBox2D.Dynamics.b2Body.prototype.Advance = function (a)\n{\n    this.m_sweep.Advance(a);\n    this.m_sweep.c.SetV(this.m_sweep.c0);\n    this.m_sweep.a = this.m_sweep.a0;\n    this.SynchronizeTransform()\n};\nBox2D.Dynamics.b2Body.NEXT_ID = 0;\nBox2D.Dynamics.b2Body.s_xf1 = new Box2D.Common.Math.b2Transform;\nBox2D.Dynamics.b2World = function (a, b)\n{\n    this.m_contactManager = new Box2D.Dynamics.b2ContactManager(this);\n    this.m_contactSolver = new Box2D.Dynamics.Contacts.b2ContactSolver;\n    this.m_newFixture = this.m_isLocked = !1;\n    this.m_debugDraw = this.m_destructionListener = null;\n    this.bodyList = new Box2D.Dynamics.b2BodyList;\n    this.contactList = new Box2D.Dynamics.Contacts.b2ContactList;\n    this.m_jointList = null;\n    this.controllerList = new Box2D.Dynamics.Controllers.b2ControllerList;\n    this.m_jointCount = 0;\n    this.m_continuousPhysics = this.m_warmStarting = !0;\n    this.m_allowSleep = b;\n    this.m_gravity = a;\n    this.m_inv_dt0 = 0;\n    this.m_groundBody = this.CreateBody(new Box2D.Dynamics.b2BodyDef);\n    this.mainTimeStep = new Box2D.Dynamics.b2TimeStep(0, 0, 0, 0, this.m_warmStarting);\n    this.islandTimeStep = new Box2D.Dynamics.b2TimeStep(0, 0, 0, 0, this.m_warmStarting);\n    this.island = new Box2D.Dynamics.b2Island(this.m_contactManager.m_contactListener, this.m_contactSolver)\n};\nBox2D.Dynamics.b2World.MAX_TOI = 1 - 100 * Number.MIN_VALUE;\nBox2D.Dynamics.b2World.prototype.SetDestructionListener = function (a)\n{\n    this.m_destructionListener = a\n};\nBox2D.Dynamics.b2World.prototype.SetContactFilter = function (a)\n{\n    this.m_contactManager.m_contactFilter = a\n};\nBox2D.Dynamics.b2World.prototype.SetContactListener = function (a)\n{\n    this.m_contactManager.m_contactListener = a\n};\nBox2D.Dynamics.b2World.prototype.SetDebugDraw = function (a)\n{\n    this.m_debugDraw = a\n};\nBox2D.Dynamics.b2World.prototype.SetBroadPhase = function (a)\n{\n    var b = this.m_contactManager.m_broadPhase;\n    this.m_contactManager.m_broadPhase = a;\n    for (var c = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.allBodies); c; c = c.GetNextNode())\n    {\n        for (var d = c.body.GetFixtureList().GetFirstNode(); d; d = d.GetNextNode())\n        {\n            var e = d.fixture;\n            e.m_proxy = a.CreateProxy(b.GetFatAABB(e.m_proxy), e)\n        }\n    }\n};\nBox2D.Dynamics.b2World.prototype.GetProxyCount = function ()\n{\n    return this.m_contactManager.m_broadPhase.GetProxyCount()\n};\nBox2D.Dynamics.b2World.prototype.CreateBody = function (a)\n{\n    Box2D.Common.b2Settings.b2Assert(!this.IsLocked());\n    a = new Box2D.Dynamics.b2Body(a, this);\n    this.bodyList.AddBody(a);\n    return a\n};\nBox2D.Dynamics.b2World.prototype.DestroyBody = function (a)\n{\n    Box2D.Common.b2Settings.b2Assert(!this.IsLocked());\n    for (var b = a.m_jointList; b;)\n    {\n        var c = b, b = b.next;\n        this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(c.joint);\n        this.DestroyJoint(c.joint)\n    }\n    for (b = a.GetControllerList().GetFirstNode(); b; b = b.GetNextNode())\n    {\n        b.controller.RemoveBody(a)\n    }\n    for (b = a.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); b; b = b.GetNextNode())\n    {\n        this.m_contactManager.Destroy(b.contact)\n    }\n    for (b = a.GetFixtureList().GetFirstNode(); b; b = b.GetNextNode())\n    {\n        this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(b.fixture), a.DestroyFixture(b.fixture)\n    }\n    a.Destroy();\n    this.bodyList.RemoveBody(a)\n};\nBox2D.Dynamics.b2World.prototype.CreateJoint = function (a)\n{\n    var b = Box2D.Dynamics.Joints.b2Joint.Create(a);\n    b.m_prev = null;\n    if (b.m_next = this.m_jointList)\n    {\n        this.m_jointList.m_prev = b\n    }\n    this.m_jointList = b;\n    this.m_jointCount++;\n    b.m_edgeA.joint = b;\n    b.m_edgeA.other = b.m_bodyB;\n    b.m_edgeA.prev = null;\n    if (b.m_edgeA.next = b.m_bodyA.m_jointList)\n    {\n        b.m_bodyA.m_jointList.prev = b.m_edgeA\n    }\n    b.m_bodyA.m_jointList = b.m_edgeA;\n    b.m_edgeB.joint = b;\n    b.m_edgeB.other = b.m_bodyA;\n    b.m_edgeB.prev = null;\n    if (b.m_edgeB.next = b.m_bodyB.m_jointList)\n    {\n        b.m_bodyB.m_jointList.prev = b.m_edgeB\n    }\n    b.m_bodyB.m_jointList = b.m_edgeB;\n    var c = a.bodyA, d = a.bodyB;\n    if (!a.collideConnected)\n    {\n        for (a = d.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); a; a = a.GetNextNode())\n        {\n            a.contact.GetOther(d) == c && a.contact.FlagForFiltering()\n        }\n    }\n    return b\n};\nBox2D.Dynamics.b2World.prototype.DestroyJoint = function (a)\n{\n    var b = a.m_collideConnected;\n    a.m_prev && (a.m_prev.m_next = a.m_next);\n    a.m_next && (a.m_next.m_prev = a.m_prev);\n    a == this.m_jointList && (this.m_jointList = a.m_next);\n    var c = a.m_bodyA, d = a.m_bodyB;\n    c.SetAwake(!0);\n    d.SetAwake(!0);\n    a.m_edgeA.prev && (a.m_edgeA.prev.next = a.m_edgeA.next);\n    a.m_edgeA.next && (a.m_edgeA.next.prev = a.m_edgeA.prev);\n    a.m_edgeA == c.m_jointList && (c.m_jointList = a.m_edgeA.next);\n    a.m_edgeA.prev = null;\n    a.m_edgeA.next = null;\n    a.m_edgeB.prev && (a.m_edgeB.prev.next = a.m_edgeB.next);\n    a.m_edgeB.next && (a.m_edgeB.next.prev = a.m_edgeB.prev);\n    a.m_edgeB == d.m_jointList && (d.m_jointList = a.m_edgeB.next);\n    a.m_edgeB.prev = null;\n    a.m_edgeB.next = null;\n    this.m_jointCount--;\n    if (!b)\n    {\n        for (a = d.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); a; a = a.GetNextNode())\n        {\n            a.contact.GetOther(d) == c && a.contact.FlagForFiltering()\n        }\n    }\n};\nBox2D.Dynamics.b2World.prototype.GetControllerList = function ()\n{\n    return this.controllerList\n};\nBox2D.Dynamics.b2World.prototype.AddController = function (a)\n{\n    if (null !== a.m_world && a.m_world != this)\n    {\n        throw Error(\"Controller can only be a member of one world\");\n    }\n    this.controllerList.AddController(a);\n    a.m_world = this;\n    return a\n};\nBox2D.Dynamics.b2World.prototype.RemoveController = function (a)\n{\n    this.controllerList.RemoveController(a);\n    a.m_world = null;\n    a.Clear()\n};\nBox2D.Dynamics.b2World.prototype.CreateController = function (a)\n{\n    return this.AddController(a)\n};\nBox2D.Dynamics.b2World.prototype.DestroyController = function (a)\n{\n    this.RemoveController(a)\n};\nBox2D.Dynamics.b2World.prototype.SetWarmStarting = function (a)\n{\n    this.m_warmStarting = a\n};\nBox2D.Dynamics.b2World.prototype.SetContinuousPhysics = function (a)\n{\n    this.m_continuousPhysics = a\n};\nBox2D.Dynamics.b2World.prototype.GetBodyCount = function ()\n{\n    return this.bodyList.GetBodyCount()\n};\nBox2D.Dynamics.b2World.prototype.GetJointCount = function ()\n{\n    return this.m_jointCount\n};\nBox2D.Dynamics.b2World.prototype.GetContactCount = function ()\n{\n    return this.contactList.GetContactCount()\n};\nBox2D.Dynamics.b2World.prototype.SetGravity = function (a)\n{\n    this.m_gravity = a\n};\nBox2D.Dynamics.b2World.prototype.GetGravity = function ()\n{\n    return this.m_gravity\n};\nBox2D.Dynamics.b2World.prototype.GetGroundBody = function ()\n{\n    return this.m_groundBody\n};\nBox2D.Dynamics.b2World.prototype.Step = function (a, b, c)\n{\n    this.m_newFixture && (this.m_contactManager.FindNewContacts(), this.m_newFixture = !1);\n    this.m_isLocked = !0;\n    this.mainTimeStep.Reset(a, this.m_inv_dt0 * a, b, c, this.m_warmStarting);\n    this.m_contactManager.Collide();\n    0 < this.mainTimeStep.dt && (this.Solve(this.mainTimeStep), this.m_continuousPhysics && this.SolveTOI(this.mainTimeStep), this.m_inv_dt0 = this.mainTimeStep.inv_dt);\n    this.m_isLocked = !1\n};\nBox2D.Dynamics.b2World.prototype.ClearForces = function ()\n{\n    for (var a = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.dynamicBodies); a; a = a.GetNextNode())\n    {\n        a.body.m_force.SetZero(), a.body.m_torque = 0\n    }\n};\nBox2D.Dynamics.b2World.prototype.DrawDebugData = function ()\n{\n    if (null !== this.m_debugDraw)\n    {\n        this.m_debugDraw.Clear();\n        var a = this.m_debugDraw.GetFlags();\n        if (a & Box2D.Dynamics.b2DebugDraw.e_shapeBit)\n        {\n            for (var b = Box2D.Dynamics.b2World.s_color_inactive, c = Box2D.Dynamics.b2World.s_color_static, d = Box2D.Dynamics.b2World.s_color_kinematic, e = Box2D.Dynamics.b2World.s_color_dynamic_sleeping, f = Box2D.Dynamics.b2World.s_color_dynamic_awake, g = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.allBodies); g; g = g.GetNextNode())\n            {\n                for (var h = g.body, i = h.GetFixtureList().GetFirstNode(); i; i = i.GetNextNode())\n                {\n                    var j = i.fixture, j = j.GetShape();\n                    h.IsActive() ? h.GetType() == Box2D.Dynamics.b2BodyDef.b2_staticBody ? this.DrawShape(j, h.m_xf, c) : h.GetType() == Box2D.Dynamics.b2BodyDef.b2_kinematicBody ? this.DrawShape(j, h.m_xf, d) : h.IsAwake() ? this.DrawShape(j, h.m_xf, f) : this.DrawShape(j, h.m_xf, e) : this.DrawShape(j, h.m_xf, b)\n                }\n            }\n        }\n        if (a & Box2D.Dynamics.b2DebugDraw.e_jointBit)\n        {\n            for (g = this.m_jointList; g; g = g.m_next)\n            {\n                this.DrawJoint(g)\n            }\n        }\n        if (a & Box2D.Dynamics.b2DebugDraw.e_controllerBit)\n        {\n            for (g = this.controllerList.GetFirstNode(); g; g = g.GetNextNode())\n            {\n                g.controller.Draw(this.m_debugDraw)\n            }\n        }\n        if (a & Box2D.Dynamics.b2DebugDraw.e_pairBit)\n        {\n            g = Box2D.Dynamics.b2World.s_pairColor;\n            for (i = this.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); i; i = i.GetNextNode())\n            {\n                b = i.contact.GetFixtureA(), h = i.contact.GetFixtureB(), b = b.GetAABB().GetCenter(), h = h.GetAABB().GetCenter(), this.m_debugDraw.DrawSegment(b, h, g), Box2D.Common.Math.b2Vec2.Free(b), Box2D.Common.Math.b2Vec2.Free(h)\n            }\n        }\n        if (a & Box2D.Dynamics.b2DebugDraw.e_aabbBit)\n        {\n            b = Box2D.Dynamics.b2World.s_aabbColor;\n            for (g = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.activeBodies); g; g = g.GetNextNode())\n            {\n                h = g.body;\n                for (i = h.GetFixtureList().GetFirstNode(); i; i = i.GetNextNode())\n                {\n                    j = i.fixture, h = this.m_contactManager.m_broadPhase.GetFatAABB(j.m_proxy), h = [Box2D.Common.Math.b2Vec2.Get(h.lowerBound.x, h.lowerBound.y), Box2D.Common.Math.b2Vec2.Get(h.upperBound.x, h.lowerBound.y), Box2D.Common.Math.b2Vec2.Get(h.upperBound.x, h.upperBound.y), Box2D.Common.Math.b2Vec2.Get(h.lowerBound.x, h.upperBound.y)], this.m_debugDraw.DrawPolygon(h, 4, b), Box2D.Common.Math.b2Vec2.Free(h[0]), Box2D.Common.Math.b2Vec2.Free(h[1]), Box2D.Common.Math.b2Vec2.Free(h[2]), Box2D.Common.Math.b2Vec2.Free(h[3])\n                }\n            }\n        }\n        if (a & Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit)\n        {\n            for (g = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.allBodies); g; g = g.GetNextNode())\n            {\n                h = g.body, Box2D.Dynamics.b2World.s_xf.R = h.m_xf.R, Box2D.Dynamics.b2World.s_xf.position = h.GetWorldCenter(), this.m_debugDraw.DrawTransform(Box2D.Dynamics.b2World.s_xf)\n            }\n        }\n    }\n};\nBox2D.Dynamics.b2World.prototype.QueryAABB = function (a, b)\n{\n    this.m_contactManager.m_broadPhase.Query(a, b)\n};\nBox2D.Dynamics.b2World.prototype.QueryPoint = function (a, b)\n{\n    var c = Box2D.Collision.b2AABB.Get();\n    c.lowerBound.Set(b.x - Box2D.Common.b2Settings.b2_linearSlop, b.y - Box2D.Common.b2Settings.b2_linearSlop);\n    c.upperBound.Set(b.x + Box2D.Common.b2Settings.b2_linearSlop, b.y + Box2D.Common.b2Settings.b2_linearSlop);\n    this.m_contactManager.m_broadPhase.Query(function (c)\n    {\n        return c.TestPoint(b) ? a(c) : !0\n    }, c);\n    Box2D.Collision.b2AABB.Free(c)\n};\nBox2D.Dynamics.b2World.prototype.RayCast = function (a, b, c)\n{\n    var d = this.m_contactManager.m_broadPhase, e = new Box2D.Collision.b2RayCastOutput, f = new Box2D.Collision.b2RayCastInput(b, c, 1);\n    d.RayCast(function (d, f)\n    {\n        if (f.RayCast(e, d))\n        {\n            var i = 1 - e.fraction, i = Box2D.Common.Math.b2Vec2.Get(i * b.x + e.fraction * c.x, i * b.y + e.fraction * c.y), j = a(f, i, e.normal, e.fraction);\n            Box2D.Common.Math.b2Vec2.Free(i);\n            return j\n        }\n        return d.maxFraction\n    }, f)\n};\nBox2D.Dynamics.b2World.prototype.RayCastOne = function (a, b)\n{\n    var c = null;\n    this.RayCast(function (a, b, f, g)\n    {\n        c = a;\n        return g\n    }, a, b);\n    return c\n};\nBox2D.Dynamics.b2World.prototype.RayCastAll = function (a, b)\n{\n    var c = [];\n    this.RayCast(function (a)\n    {\n        c.push(a);\n        return 1\n    }, a, b);\n    return c\n};\nBox2D.Dynamics.b2World.prototype.GetBodyList = function ()\n{\n    return this.bodyList\n};\nBox2D.Dynamics.b2World.prototype.GetJointList = function ()\n{\n    return this.m_jointList\n};\nBox2D.Dynamics.b2World.prototype.GetContactList = function ()\n{\n    return this.contactList\n};\nBox2D.Dynamics.b2World.prototype.IsLocked = function ()\n{\n    return this.m_isLocked\n};\nBox2D.Dynamics.b2World.prototype.Solve = function (a)\n{\n    for (var b = this.controllerList.GetFirstNode(); b; b = b.GetNextNode())\n    {\n        b.controller.Step(a)\n    }\n    b = this.island;\n    b.Reset(this.m_contactManager.m_contactListener, this.m_contactSolver);\n    for (var c = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.allBodies); c; c = c.GetNextNode())\n    {\n        c.body.m_islandFlag = !1\n    }\n    for (var d = this.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); d; d = d.GetNextNode())\n    {\n        d.contact.m_islandFlag = !1\n    }\n    for (c = this.m_jointList; c; c = c.m_next)\n    {\n        c.m_islandFlag = !1\n    }\n    for (c = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.nonStaticActiveAwakeBodies); c; c = c.GetNextNode())\n    {\n        if (d = c.body, !d.m_islandFlag)\n        {\n            b.Clear();\n            var e = [];\n            e.push(d);\n            for (d.m_islandFlag = !0; 0 < e.length;)\n            {\n                var f = e.pop();\n                b.AddBody(f);\n                f.IsAwake() || f.SetAwake(!0);\n                if (f.GetType() != Box2D.Dynamics.b2BodyDef.b2_staticBody)\n                {\n                    for (d = f.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.nonSensorEnabledTouchingContacts); d; d = d.GetNextNode())\n                    {\n                        var g = d.contact;\n                        g.m_islandFlag || (b.AddContact(g), g.m_islandFlag = !0, g = g.GetOther(f), g.m_islandFlag || (e.push(g), g.m_islandFlag = !0))\n                    }\n                    for (d = f.m_jointList; d; d = d.next)\n                    {\n                        !d.joint.m_islandFlag && d.other.IsActive() && (b.AddJoint(d.joint), d.joint.m_islandFlag = !0, d.other.m_islandFlag || (e.push(d.other), d.other.m_islandFlag = !0))\n                    }\n                }\n            }\n\n            b.Solve(a, this.m_gravity, this.m_allowSleep)\n        }\n    }\n    for (c = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.nonStaticActiveAwakeBodies); c; c = c.GetNextNode())\n    {\n        c.body.SynchronizeFixtures()\n    }\n    this.m_contactManager.FindNewContacts()\n};\nBox2D.Dynamics.b2World.prototype.SolveTOI = function (a)\n{\n    var b = this.island;\n    b.Reset(this.m_contactManager.m_contactListener, this.m_contactSolver);\n    for (var c = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.allBodies); c; c = c.GetNextNode())\n    {\n        var d = c.body;\n        d.m_islandFlag = !1;\n        d.m_sweep.t0 = 0\n    }\n    for (var e = this.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); e; e = e.GetNextNode())\n    {\n        e.contact.m_islandFlag = !1, e.contact.m_toi = null\n    }\n    for (c = this.m_jointList; c; c = c.m_next)\n    {\n        c.m_islandFlag = !1\n    }\n    for (; ;)\n    {\n        var c = this._SolveTOI2(a), f = c.minContact, c = c.minTOI;\n        if (null === f || Box2D.Dynamics.b2World.MAX_TOI < c)\n        {\n            break\n        }\n        e = f.m_fixtureA.GetBody();\n        d = f.m_fixtureB.GetBody();\n        Box2D.Dynamics.b2World.s_backupA.Set(e.m_sweep);\n        Box2D.Dynamics.b2World.s_backupB.Set(d.m_sweep);\n        e.Advance(c);\n        d.Advance(c);\n        f.Update(this.m_contactManager.m_contactListener);\n        f.m_toi = null;\n        if (f.IsSensor() || !f.IsEnabled())\n        {\n            e.m_sweep.Set(Box2D.Dynamics.b2World.s_backupA), d.m_sweep.Set(Box2D.Dynamics.b2World.s_backupB), e.SynchronizeTransform(), d.SynchronizeTransform()\n        } else\n        {\n            if (f.IsTouching())\n            {\n                e.GetType() != Box2D.Dynamics.b2BodyDef.b2_dynamicBody && (e = d);\n                b.Clear();\n                f = new goog.structs.Queue;\n                f.enqueue(e);\n                for (e.m_islandFlag = !0; 0 < f.size;)\n                {\n                    if (d = f.dequeue(), b.AddBody(d), d.IsAwake() || d.SetAwake(!0), d.GetType() == Box2D.Dynamics.b2BodyDef.b2_dynamicBody)\n                    {\n                        for (e = d.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.nonSensorEnabledTouchingContacts); e && b.m_contactCount != Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland; e = e.GetNextNode())\n                        {\n                            var g = e.contact;\n                            g.m_islandFlag || (b.AddContact(g), g.m_islandFlag = !0, g = g.GetOther(d), g.m_islandFlag || (g.GetType() != Box2D.Dynamics.b2BodyDef.b2_staticBody && (g.Advance(c), g.SetAwake(!0), f.enqueue(g)), g.m_islandFlag = !0))\n                        }\n                        for (d = d.m_jointList; d; d = d.next)\n                        {\n                            b.m_jointCount != Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland && (!d.joint.m_islandFlag && d.other.IsActive()) && (b.AddJoint(d.joint), d.joint.m_islandFlag = !0, d.other.m_islandFlag || (d.other.GetType() != Box2D.Dynamics.b2BodyDef.b2_staticBody && (d.other.Advance(c), d.other.SetAwake(!0), f.enqueue(d.other)), d.other.m_islandFlag = !0))\n                        }\n                    }\n                }\n                this.islandTimeStep.Reset((1 - c) * a.dt, 0, a.velocityIterations, a.positionIterations, !1);\n                b.SolveTOI(this.islandTimeStep);\n                for (c = 0; c < b.m_bodies.length; c++)\n                {\n                    if (b.m_bodies[c].m_islandFlag = !1, b.m_bodies[c].IsAwake() && b.m_bodies[c].GetType() == Box2D.Dynamics.b2BodyDef.b2_dynamicBody)\n                    {\n                        b.m_bodies[c].SynchronizeFixtures();\n                        for (e = b.m_bodies[c].contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.allContacts); e; e = e.GetNextNode())\n                        {\n                            e.contact.m_toi = null\n                        }\n                    }\n                }\n                for (c = 0; c < b.m_contactCount; c++)\n                {\n                    b.m_contacts[c].m_islandFlag = !1, b.m_contacts[c].m_toi = null\n                }\n                for (c = 0; c < b.m_jointCount; c++)\n                {\n                    b.m_joints[c].m_islandFlag = !1\n                }\n                this.m_contactManager.FindNewContacts()\n            }\n        }\n    }\n};\nBox2D.Dynamics.b2World.prototype._SolveTOI2 = function (a)\n{\n    for (var b = null, c = 1, d = this.contactList.GetFirstNode(Box2D.Dynamics.Contacts.b2ContactList.TYPES.nonSensorEnabledContinuousContacts); d; d = d.GetNextNode())\n    {\n        var e = d.contact;\n        if (!this._SolveTOI2SkipContact(a, e))\n        {\n            var f = 1;\n            if (null != e.m_toi)\n            {\n                f = e.m_toi\n            } else\n            {\n                if (e.IsTouching())\n                {\n                    f = 1\n                } else\n                {\n                    var f = e.m_fixtureA.GetBody(), g = e.m_fixtureB.GetBody(), h = f.m_sweep.t0;\n                    f.m_sweep.t0 < g.m_sweep.t0 ? (h = g.m_sweep.t0, f.m_sweep.Advance(h)) : g.m_sweep.t0 < f.m_sweep.t0 && (h = f.m_sweep.t0, g.m_sweep.Advance(h));\n                    f = e.ComputeTOI(f.m_sweep, g.m_sweep);\n                    Box2D.Common.b2Settings.b2Assert(0 <= f && 1 >= f);\n                    0 < f && 1 > f && (f = (1 - f) * h + f)\n                }\n                e.m_toi = f\n            }\n            Number.MIN_VALUE < f && f < c && (b = e, c = f)\n        }\n    }\n    return{minContact:b, minTOI:c}\n};\nBox2D.Dynamics.b2World.prototype._SolveTOI2SkipContact = function (a, b)\n{\n    var c = b.m_fixtureA.GetBody(), d = b.m_fixtureB.GetBody();\n    return(c.GetType() != Box2D.Dynamics.b2BodyDef.b2_dynamicBody || !c.IsAwake()) && (d.GetType() != Box2D.Dynamics.b2BodyDef.b2_dynamicBody || !d.IsAwake()) ? !0 : !1\n};\nBox2D.Dynamics.b2World.prototype.DrawJoint = function (a)\n{\n    if (a instanceof Box2D.Dynamics.Joints.b2DistanceJoint || a instanceof Box2D.Dynamics.Joints.b2MouseJoint)\n    {\n        var b = a.GetAnchorA(), c = a.GetAnchorB();\n        this.m_debugDraw.DrawSegment(b, c, Box2D.Dynamics.b2World.s_jointColor);\n        Box2D.Common.Math.b2Vec2.Free(b);\n        Box2D.Common.Math.b2Vec2.Free(c)\n    } else\n    {\n        if (a instanceof Box2D.Dynamics.Joints.b2PulleyJoint)\n        {\n            var b = a.GetAnchorA(), c = a.GetAnchorB(), d = a.GetGroundAnchorA(), a = a.GetGroundAnchorB();\n            this.m_debugDraw.DrawSegment(d, b, Box2D.Dynamics.b2World.s_jointColor);\n            this.m_debugDraw.DrawSegment(a, c, Box2D.Dynamics.b2World.s_jointColor);\n            this.m_debugDraw.DrawSegment(d, a, Box2D.Dynamics.b2World.s_jointColor);\n            Box2D.Common.Math.b2Vec2.Free(b);\n            Box2D.Common.Math.b2Vec2.Free(c);\n            Box2D.Common.Math.b2Vec2.Free(d);\n            Box2D.Common.Math.b2Vec2.Free(a)\n        } else\n        {\n            b = a.GetAnchorA(), c = a.GetAnchorB(), a.GetBodyA() != this.m_groundBody && this.m_debugDraw.DrawSegment(a.GetBodyA().m_xf.position, b, Box2D.Dynamics.b2World.s_jointColor), this.m_debugDraw.DrawSegment(b, c, Box2D.Dynamics.b2World.s_jointColor), a.GetBodyB() != this.m_groundBody && this.m_debugDraw.DrawSegment(a.GetBodyB().m_xf.position, c, Box2D.Dynamics.b2World.s_jointColor), Box2D.Common.Math.b2Vec2.Free(b), Box2D.Common.Math.b2Vec2.Free(c)\n        }\n    }\n};\nBox2D.Dynamics.b2World.prototype.DrawShape = function (a, b, c)\n{\n    if (a instanceof Box2D.Collision.Shapes.b2CircleShape)\n    {\n        var d = Box2D.Common.Math.b2Math.MulX(b, a.m_p);\n        this.m_debugDraw.DrawSolidCircle(d, a.m_radius, b.R.col1, c);\n        Box2D.Common.Math.b2Vec2.Free(d)\n    } else\n    {\n        if (a instanceof Box2D.Collision.Shapes.b2PolygonShape)\n        {\n            for (var d = 0, e = a.GetVertexCount(), a = a.GetVertices(), f = [], d = 0; d < e; d++)\n            {\n                f[d] = Box2D.Common.Math.b2Math.MulX(b, a[d])\n            }\n            this.m_debugDraw.DrawSolidPolygon(f, e, c);\n            for (d = 0; d < e; d++)\n            {\n                Box2D.Common.Math.b2Vec2.Free(f[d])\n            }\n        } else\n        {\n            a instanceof Box2D.Collision.Shapes.b2EdgeShape && (d = Box2D.Common.Math.b2Math.MulX(b, a.GetVertex1()), b = Box2D.Common.Math.b2Math.MulX(b, a.GetVertex2()), this.m_debugDraw.DrawSegment(d, b, c), Box2D.Common.Math.b2Vec2.Free(d), Box2D.Common.Math.b2Vec2.Free(b))\n        }\n    }\n};\nBox2D.Dynamics.b2World.s_xf = new Box2D.Common.Math.b2Transform;\nBox2D.Dynamics.b2World.s_backupA = new Box2D.Common.Math.b2Sweep;\nBox2D.Dynamics.b2World.s_backupB = new Box2D.Common.Math.b2Sweep;\nBox2D.Dynamics.b2World.s_jointColor = new Box2D.Common.b2Color(0.5, 0.8, 0.8);\nBox2D.Dynamics.b2World.s_color_inactive = new Box2D.Common.b2Color(0.5, 0.5, 0.3);\nBox2D.Dynamics.b2World.s_color_static = new Box2D.Common.b2Color(0.3, 0.3, 0.3);\nBox2D.Dynamics.b2World.s_color_kinematic = new Box2D.Common.b2Color(0.5, 0.5, 0.9);\nBox2D.Dynamics.b2World.s_color_dynamic_sleeping = new Box2D.Common.b2Color(0.6, 0.6, 0.6);\nBox2D.Dynamics.b2World.s_color_dynamic_awake = new Box2D.Common.b2Color(0.6, 0.9, 0.6);\nBox2D.Dynamics.b2World.s_pairColor = new Box2D.Common.b2Color(0.3, 0.9, 0.9);\nBox2D.Dynamics.b2World.s_aabbColor = new Box2D.Common.b2Color(0, 0, 0.8);\nBox2D.generateCallback = function (a, b)\n{\n    return function ()\n    {\n        b.apply(a, arguments)\n    }\n};\nBox2D.Dynamics.Controllers.b2TensorDampingController = function ()\n{\n    Box2D.Dynamics.Controllers.b2Controller.call(this);\n    this.T = new Box2D.Common.Math.b2Mat22;\n    this.maxTimestep = 0\n};\ngoog.inherits(Box2D.Dynamics.Controllers.b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);\nBox2D.Dynamics.Controllers.b2TensorDampingController.prototype.SetAxisAligned = function (a, b)\n{\n    this.T.col1.x = -a;\n    this.T.col1.y = 0;\n    this.T.col2.x = 0;\n    this.T.col2.y = -b;\n    this.maxTimestep = 0 < a || 0 < b ? 1 / Math.max(a, b) : 0\n};\nBox2D.Dynamics.Controllers.b2TensorDampingController.prototype.Step = function (a)\n{\n    a = a.dt;\n    if (!(a <= Number.MIN_VALUE))\n    {\n        a > this.maxTimestep && 0 < this.maxTimestep && (a = this.maxTimestep);\n        for (var b = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.awakeBodies); b; b = b.GetNextNode())\n        {\n            var c = b.body, d = c.GetLocalVector(c.GetLinearVelocity()), e = Box2D.Common.Math.b2Math.MulMV(this.T, d);\n            Box2D.Common.Math.b2Vec2.Free(d);\n            d = c.GetWorldVector(e);\n            Box2D.Common.Math.b2Vec2.Free(e);\n            e = Box2D.Common.Math.b2Vec2.Get(c.GetLinearVelocity().x + d.x * a, c.GetLinearVelocity().y + d.y * a);\n            Box2D.Common.Math.b2Vec2.Free(d);\n            c.SetLinearVelocity(e);\n            Box2D.Common.Math.b2Vec2.Free(e)\n        }\n    }\n};\nBox2D.Collision.Shapes.b2EdgeChainDef = function ()\n{\n\n    this.vertexCount = 0;\n    this.isALoop = !0;\n    this.vertices = []\n};\nBox2D.Dynamics.Controllers.b2ConstantForceController = function ()\n{\n    Box2D.Dynamics.Controllers.b2Controller.call(this);\n    this.F = Box2D.Common.Math.b2Vec2.Get(0, 0)\n};\ngoog.inherits(Box2D.Dynamics.Controllers.b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);\nBox2D.Dynamics.Controllers.b2ConstantForceController.prototype.Step = function ()\n{\n    for (var a = this.bodyList.GetFirstNode(Box2D.Dynamics.b2BodyList.TYPES.awakeBodies); a; a = a.GetNextNode())\n    {\n        var b = a.body;\n        b.ApplyForce(this.F, b.GetWorldCenter())\n    }\n};\nBox2D.Dynamics.Joints.b2PulleyJointDef = function ()\n{\n    Box2D.Dynamics.Joints.b2JointDef.call(this);\n    this.groundAnchorA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.groundAnchorB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localAnchorA = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.localAnchorB = Box2D.Common.Math.b2Vec2.Get(0, 0);\n    this.type = Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint;\n    this.groundAnchorA.Set(-1, 1);\n    this.groundAnchorB.Set(1, 1);\n    this.localAnchorA.Set(-1, 0);\n    this.localAnchorB.Set(1, 0);\n    this.maxLengthB = this.lengthB = this.maxLengthA = this.lengthA = 0;\n    this.ratio = 1;\n    this.collideConnected = !0\n};\ngoog.inherits(Box2D.Dynamics.Joints.b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);\nBox2D.Dynamics.Joints.b2PulleyJointDef.prototype.Initialize = function (a, b, c, d, e, f, g)\n{\n    void 0 === g && (g = 0);\n    this.bodyA = a;\n    this.bodyB = b;\n    this.groundAnchorA.SetV(c);\n    this.groundAnchorB.SetV(d);\n    this.localAnchorA = this.bodyA.GetLocalPoint(e);\n    this.localAnchorB = this.bodyB.GetLocalPoint(f);\n    a = e.x - c.x;\n    c = e.y - c.y;\n    this.lengthA = Math.sqrt(a * a + c * c);\n    c = f.x - d.x;\n    d = f.y - d.y;\n    this.lengthB = Math.sqrt(c * c + d * d);\n    this.ratio = g;\n    g = this.lengthA + this.ratio * this.lengthB;\n    this.maxLengthA = g - this.ratio * Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength;\n    this.maxLengthB = (g - Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength) / this.ratio\n};\nBox2D.Dynamics.Joints.b2PulleyJointDef.prototype.Create = function ()\n{\n    return new Box2D.Dynamics.Joints.b2PulleyJoint(this)\n};\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.Input\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * This class provides a way of binding and reacting to input in a convenient and device independent way. The\n * engine will automatically construct a single, global input class which is accessible via the global pc.device.input.\n * <p>\n * There are two kinds of inputs that can be handled, actions and states. An action is a single event that occurs\n * as a reaction to an input such as clicking the mouse or pressing a key. Typical actions are having a player jump, or\n * open a door. States are when an input is in an on/off state, such as turning a ship or firing a weapon.\n * <p>\n * <h5>Actions</h5>\n * Reacting to action involves 'binding' an action, such as 'open door' or 'jump' to an object in the game which will\n * trigger a call to the object's onAction method.\n * <pre><code>\n * MyGame = pc.Game('MyGame',\n * {},\n * {\n *    onLoaded:function (loaded, errored)\n *    {\n *       // bind the jump action to the space key\n *       this.input.bindAction(this, 'jump', 'SPACE');\n *       // as well as a mouse click\n *       this.input.bindAction(this, 'jump', 'MOUSE_LEFT_CLICK');\n *    },\n *\n *    // this onAction method will be called when an action relating to\n *    // this object is triggered\n *    onAction:function(actionName)\n *    {\n *       if (actionName === 'jump')\n *       {\n *          // player.jump!\n *       }\n *    }\n *\n * });\n * </code></pre>\n * <p>\n * Events will continue to propagate through all active bindings. If you wish to stop handling of an action from\n * within an onAction method you can optionally return false\n * <p>\n * <h5>States</h5>\n * States are used to indicate when a key or input control is currently active or not. Typically a state is used\n * when you want to react for the entire time an input is engaged, such as holding down a key to accelerate a car.\n * <p>\n * To use an input state, bind it to an object the same way you do an action. You will then need to separately check\n * if the state is on at the appropriate time for your game. Most commonly this is done in a process function. See\n * the <a href='pc.Game'>game</a>, <a href='pc.Layer'>layer</a> or <a href='pc.Scene'>scene</a> classes for more\n * information on overriding a process function.\n * <pre><code>\n * // bind the state to an input and an object\n * this.input.bindState(this, 'moving left', 'LEFT');\n *\n * // check for the state being active in the game, layer or scene process\n * process:function ()\n * {\n *    if (pc.device.input.isInputState(this, 'moving left'))\n *       // move the player left\n * }\n * </code></pre>\n * You can see an example of both input actions and states in the Asteroids sample game.\n * <p>\n * Rather than using this class directly, you can also use the <a href='pc.components.Input'>input component</a>\n * and <a href='pc.systems.Input'>system</a> which lets you bind input to an entity as a component.\n */\npc.Input = pc.Base('pc.Input',\n  /** @lends pc.Input */\n  {\n    _eventPos: null, // cached for speed\n\n    /**\n     * Extracts the position from an event (in a cross-browser way),and then sets the passed in pos\n     * @param {Object} e Event to extract the position from\n     * @param {pc.Point} [pos] Position object to set. Leave out to have a new (pooled) point returned\n     */\n    getEventPosition: function (e, pos)\n    {\n      if (this._eventPos == null)\n        this._eventPos = pc.Point.create(0, 0);\n\n      var r = pos;\n      if (!pc.Tools.isValid(pos))\n        r = this._eventPos;\n\n      if (e.pageX || e.pageY)\n      {\n        r.x = e.pageX;\n        r.y = e.pageY;\n      } else\n      {\n        r.x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n        r.y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n      }\n\n      if (pc.Tools.isValid(e.alpha))\n      {\n        r.x = e.alpha;\n        r.y = e.gamma;\n      }\n\n      return r;\n    }\n\n  },\n  /** @lends pc.Input.prototype */\n  {\n    /** Current state bindings */\n    stateBindings: null,\n    /** Currently active states */\n    states: null,\n    /** Action bindings */\n    actionBindings: null,\n    /** Current position of the mouse on-screen, updated continuously */\n    mousePos: null,\n    /** indicates if the left mouse button is currently down */\n    mouseLeftButtonDown: false,\n    /** indicates if the right mouse button is currently down */\n    mouseRightButtonDown: false,\n    /** Current device orientation, updated continuously */\n    deviceOrientation: null,\n\n    init: function ()\n    {\n      this._super();\n      this.stateBindings = new pc.Hashtable();\n      this.states = new pc.Hashtable();\n      this.actionBindings = new pc.Hashtable();\n      this.mousePos = pc.Point.create(0, 0);\n      this.deviceOrientation = pc.Point.create(0, 0);\n    },\n\n    /**\n     * Binds an input state to an object, such as 'turning left' or 'firing' to an input code.\n     * You can bind an input to any object, however typically it's to a layer, scene or game. The input will not\n     * trigger if the object is not presently active.\n     * If you specify a UIElement (optional), the state is only triggered if the event occurs inside\n     * the bounds of the element (typically a positional event like a touch start or mouse move)\n     * @param {Object} obj An object to bind the state to\n     * @param {String} stateName The name of the state, e.g. \"turning left\"\n     * @param {String} input The name of the input, i.e. 'LEFT' (see pc.InputType)\n     * @param {Object} [uiTarget] Optional UI object to bind the input to\n     */\n    bindState: function (obj, stateName, input, uiTarget)\n    {\n      if (obj.uniqueId == null)\n        throw \"Oops, you can't bind a state to an object if it doesn't have a uniqueId function\";\n      if (!pc.InputType.getCode(input))\n        throw \"Unknown input code \" + input + ' - see pc.InputType for a list of input names';\n\n      input = input.toUpperCase();\n      // There can be many bindings associated with a particular input, so we see\n      // if there is already one, and then append this to the array, otherwise\n      // we create the array\n      var binding = { stateName: stateName, object: obj, input: input, state: {on: false, event: null}, uiTarget: uiTarget };\n      var bindingSet = this.stateBindings.get(input);\n      if (bindingSet == null)\n        this.stateBindings.put(input, [ binding ]);\n      else\n      // otherwise append a new binding\n        bindingSet.push(binding);\n\n      // now setup a state for this object/input combination\n      this.states.put(obj.uniqueId + '\\\\\\\\' + stateName, {on: false, event: null});\n\n      // if this is a positional type binding, add it to the positional tracking array\n      if (pc.InputType.isPositional(pc.InputType.getCode(input)))\n        this._positionals.push(binding);\n    },\n\n\n    /**\n     * Clears any on states related to an object.\n     * @param {Object} obj The object to clear states for\n     */\n    clearStates: function (obj)\n    {\n      var bindings = this.stateBindings.entries();\n\n      for (var b = 0; b < bindings.length; b++)\n      {\n        var bindingSet = bindings[b];\n        for (var i = 0; i < bindingSet.length; i++)\n        {\n          var binding = bindingSet[i];\n          if (binding.object == obj)\n          {\n            var state = this.states.get(next.object.uniqueId + '\\\\\\\\' + next.stateName);\n            state.on = false;\n            state.event = null;\n            if (pc.InputType.isPositional(binding.input))\n              pc.tools.arrayRemove(this._positionals, binding);\n          }\n        }\n      }\n    },\n\n    /**\n     * Returns true if the named state is currently active. If you need anything more than the state boolean\n     * use getInputState, which includes the actual event.\n     * @param {Object} obj Object to check the binding against\n     * @param {String} stateName A string representing a previously setup state, i.e. 'turning left'\n     * @returns {Boolean} true if the state is currently on (such as a key being down)\n     */\n    isInputState: function (obj, stateName)\n    {\n      // lookup is very slow; have to find the state for a certain stateName and object\n      // todo: oops this is creating strings for every check (usually every frame)-- get rid of it\n      // add a state property to the bound object and update it when the state changes\n      var state = this.states.get(obj.uniqueId + '\\\\\\\\' + stateName);\n      if (state == null) throw 'Ooops, unknown state ' + stateName;\n      return state.on;\n    },\n\n    /**\n     * Gets the present input state object (which includes the event data).\n     * @param {Object} obj Object to check against (such as a layer, scene or game)\n     * @param {String} stateName Name of the state to check for\n     * @return {Object} state object containing the state.state and state.event data\n     */\n    getInputState: function (obj, stateName)\n    {\n      return this.states.get(obj.uniqueId + '\\\\\\\\' + stateName);\n    },\n\n    /**\n     * Binds an input event to an action and object; e.g. bindAction(playerShip, 'fire', 'CTRL')\n     * will trigger an action callback on the playerShip entity when the CTRL key is pressed down.\n     * You can bind an input to a layer, scene or entity. The input will not trigger if the object\n     * is not presently active.\n     * <p>\n     * For positional events (such as a mouse or touch input) the action will only fire if the position\n     * of the event is within the bounds of the object (based on a call to getScreenRect). You can optionally\n     * provide a uiTarget object to provide a different bounding rectangle. If the object provides no getScreenRect\n     * method, then no bounding check will be carried out.\n     * <pre><code>\n     * For example:\n     * var menuLayer = new Layer();                     // a menu layer\n     * var menuOption = new TextElement('New Game');    // a menu item\n     *\n     * // trigger the 'new game' action for the menuLayer, when a mouse click occurs within the menuOption element\n     * pc.device.input.bindAction(menuLayer, 'new game', 'MOUSE_BUTTON_LEFT_DOWN', menuOption);\n     * </code></pre>\n     * Note: If the uiTarget element is not provided, the bounding rectangle of the obj is used (as long as\n     * the object provides a getScreenRect() method, otherwise there is no checking\n     *\n     * @param {pc.Base} obj The entity, layer or scene to bind this action to (must implement onAction)\n     * @param {String} actionName The name of the action, e.g. 'FIRE' or 'JUMP'\n     * @param {String} input The input code as a string\n     * @param {pc.Base} [uiTarget] An optional element to limit the input to only within the bounds of the element (must\n     * implement getScreenRect)\n     */\n    bindAction: function (obj, actionName, input, uiTarget)\n    {\n      // There can be many bindings associated with a particular input event, so we see\n      // if there is already one, and then append this to the array, otherwise\n      // we create the array\n      input = input.toUpperCase();\n\n      var bindingSet = this.actionBindings.get(input);\n      if (bindingSet == null)\n        this.actionBindings.put(input, [\n          { actionName: actionName, object: obj, input: input, uiTarget: uiTarget }\n        ]);\n      else\n      // otherwise append a new binding\n        bindingSet.push({ actionName: actionName, input: input, object: obj, uiTarget: uiTarget });\n    },\n\n    /**\n     * Triggers an action to be fired. Typically this will be fired in response to an input, but it can\n     * also be used to simulate an event.\n     * @param {Number} eventCode event code\n     * @param {Event} event An event object\n     */\n    fireAction: function (eventCode, event)\n    {\n      var keyName = pc.InputType.getName(eventCode);\n      if(keyName == null) // Unsupported key code, ignore\n        return false;\n      var bindingSet = this.actionBindings.get(keyName);\n      if (bindingSet == null) return false;\n\n      // cycle through all the bindings against this input type and fire the object callbacks\n      for (var i = 0; i < bindingSet.length; i++)\n      {\n        var binding = bindingSet[i];\n        var obj = bindingSet[i].object;\n        if (!obj.isActive || obj.isActive())\n        {\n          // if it's a positional event type (like a mouse down or move, then we only\n          // fire events to objects where the event is within its spatial bounds\n          if (pc.InputType.isPositional(eventCode))\n          {\n            var pos = this.Class.getEventPosition(event);\n\n            if (pc.InputType.isDeviceOrientation(eventCode))\n            {\n              obj.onAction(binding.actionName, event, pos, binding.uiTarget);\n              return true;\n            }\n\n            var er = null;\n            if (pc.valid(binding.uiTarget))\n              er = binding.uiTarget.getScreenRect();\n            else\n              er = obj.getScreenRect ? obj.getScreenRect() : null;\n\n            if (er && er.containsPoint(pos))\n            {\n              var res = obj.onAction(binding.actionName, event, pos, binding.uiTarget);\n              if (pc.valid(res) && !res)\n                break;\n            }\n          } else\n          {\n            var r = obj.onAction(binding.actionName);\n            if (pc.valid(r) && !r)\n              break;\n          }\n        }\n      }\n      return true;\n    },\n\n\n    /*** INTERNALS **/\n\n    _onReady: function ()\n    {\n      // touch input\n      var eventSource = pc.device.isCocoonJS ? document.body : pc.device.canvas;\n      eventSource.addEventListener('touchstart', this._touchStart.bind(this), true);\n      eventSource.addEventListener('touchend', this._touchEnd.bind(this), true);\n      eventSource.addEventListener('touchmove', this._touchMove.bind(this), true);\n\n      // mouse input\n      eventSource.addEventListener('mouseup', this._mouseUp.bind(this), true);\n      eventSource.addEventListener('mousedown', this._mouseDown.bind(this), true);\n      eventSource.addEventListener('mousemove', this._mouseMove.bind(this), true);\n      eventSource.addEventListener('dblclick', this._mouseDoubleClick.bind(this), true);\n      if (!pc.device.isCocoonJS)\n      {\n          eventSource.addEventListener('mousewheel', this._mouseWheel.bind(this), true);\n          eventSource.addEventListener('DOMMouseScroll', this._mouseWheel.bind(this), true);\n          eventSource.addEventListener('contextmenu', this._contextMenu.bind(this), true);\n\n        // key input\n        window.addEventListener('keydown', this._keyDown.bind(this), true);\n        window.addEventListener('keyup', this._keyUp.bind(this), true);\n      }\n\n      // device orientation\n      window.addEventListener('deviceorientation', this._deviceOrientation.bind(this), true);\n\n    },\n\n    _positionals: [], // array of bindings that need to be checked against positional events like mouse move and touch\n\n    // Checks the positional event to see if it's a new event INSIDE an on-screen rectangle that has been\n    // bound to a state. This is so when a positional event, like a mouse move, 'slides' over an element\n    // we can turn the state on, as well as detecting when it slides out of the area of the uiTarget\n\n    _checkPositional: function (moveEvent)\n    {\n      // check existing tracked states -- did we move out of an element\n      for (var i = 0; i < this._positionals.length; i++)\n      {\n        var binding = this._positionals[i];\n\n        if (moveEvent.type == 'mousemove' && pc.InputType.isTouch(pc.InputType.getCode(binding.input)))\n          continue;\n\n        if (moveEvent.type == 'touchmove' && !pc.InputType.isTouch(pc.InputType.getCode(binding.input)))\n          continue;\n\n        if (pc.InputType.getCode(binding.input) == pc.InputType.MOUSE_BUTTON_LEFT_UP ||\n          pc.InputType.getCode(binding.input) == pc.InputType.MOUSE_BUTTON_LEFT_DOWN ||\n          pc.InputType.getCode(binding.input) == pc.InputType.MOUSE_BUTTON_RIGHT_UP ||\n          pc.InputType.getCode(binding.input) == pc.InputType.MOUSE_BUTTON_RIGHT_DOWN\n          )\n          continue;\n\n        var er = null;\n        if (pc.valid(binding.uiTarget))\n          er = binding.uiTarget.getScreenRect();\n        else\n          er = binding.object.getScreenRect ? binding.object.getScreenRect() : null;\n\n        if (er)\n        {\n          if (!er.containsPoint(this.Class.getEventPosition(moveEvent)))\n          {\n            // no longer in the right position, turn state off\n            var state = this.states.get(binding.object.uniqueId + '\\\\\\\\' + binding.stateName);\n            state.on = false;\n            state.event = moveEvent;\n          } else\n          {\n            // moved into position, turn back on\n            var state2 = this.states.get(binding.object.uniqueId + '\\\\\\\\' + binding.stateName);\n            state2.on = true;\n            state2.event = moveEvent;\n          }\n        }\n      }\n    },\n\n    _changeState: function (eventCode, stateOn, event)\n    {\n      // grab all the bindings to this event code\n      var keyName = pc.InputType.getName(eventCode);\n      if (keyName == null)\n      {\n        this.warn(\"Unknown keycode = \" + eventCode);\n        return false;\n      }\n\n      var bindingSet = this.stateBindings.get(keyName);\n      //console.log('change state = ' + this.inputType.getName(event.keyCode,+ ' bindings=' + bindingSet);\n      if (bindingSet == null) return false;\n\n      // cycle through all the bindings against this input type and change the state\n      for (var i = 0; i < bindingSet.length; i++)\n      {\n        var binding = bindingSet[i];\n        if (!binding.object.isActive || binding.object.isActive())\n        {\n          if (pc.InputType.isPositional(eventCode))\n          {\n            // if binding has a uiElement, then make sure the event hit is within the on-screen\n            // rectangle\n            var pos = this.Class.getEventPosition(event);\n            var er = null;\n\n            if (pc.valid(binding.uiTarget))\n              er = binding.uiTarget.getScreenRect();\n            else\n              er = binding.object.getScreenRect ? binding.object.getScreenRect() : null;\n\n            if (er)\n            {\n              if (er.containsPoint(pos))\n              {\n                var state = this.states.get(binding.object.uniqueId + '\\\\\\\\' + binding.stateName);\n                state.on = stateOn;\n                state.event = event;\n              }\n            } else\n            {\n              // positional, but no uiTarget\n              state = this.states.get(binding.object.uniqueId + '\\\\\\\\' + binding.stateName);\n              state.on = stateOn;\n              state.event = event;\n            }\n          }\n          else\n          {\n            state = this.states.get(binding.object.uniqueId + '\\\\\\\\' + binding.stateName);\n            state.on = stateOn;\n            state.event = event;\n          }\n        }\n      }\n      return true;\n    },\n\n    _lastMouseMove: null,\n\n    _lastDeviceOrientation: null,\n\n    /**\n     * Called by the pc.device main loop to process any move events received. We only handle events\n     * here so they are processed once per cycle, not every time we get them (i.e. stop handling\n     * a flood of mouse move or touch events\n     */\n    process: function ()\n    {\n      if (this._lastMouseMove)\n      {\n        this._checkPositional(this._lastMouseMove);\n        this.fireAction(pc.InputType.MOUSE_MOVE, this._lastMouseMove);\n        this.Class.getEventPosition(this._lastMouseMove, this.mousePos);\n        this._lastMouseMove = null;\n      }\n\n      if (this._lastDeviceOrientation)\n      {\n        this._changeState(pc.InputType.DEVICE_ORIENTATION, true, this._lastDeviceOrientation);\n        this.fireAction(pc.InputType.DEVICE_ORIENTATION, this._lastDeviceOrientation);\n        this.Class.getEventPosition(this._lastDeviceOrientation, this.deviceOrientation);\n        this._lastDeviceOrientation = null;\n      }\n    },\n\n    ///////////////////////////////////////////////////////////////////////////////////\n    //\n    //  EVENT HANDLERS\n    //\n    ///////////////////////////////////////////////////////////////////////////////////\n\n    _keyDown: function (event)\n    {\n        this._changeState(event.keyCode, true, event);\n        this.fireAction(event.keyCode, event);\n    },\n\n    _keyUp: function (event)\n    {\n      this._changeState(event.keyCode, false, event);\n    },\n\n    _deviceOrientation: function (event)\n    {\n      this._lastDeviceOrientation = event;\n    },\n\n    _touchStart: function (event)\n    {\n      for (var i = 0, len = event.touches.length; i < len; i++)\n      {\n        this._changeState(pc.InputType.TOUCH, true, event.touches[i]);\n        this.fireAction(pc.InputType.TOUCH, event.touches[i]);\n      }\n\n    },\n\n    _touchEnd: function (event)\n    {\n      for (var i = 0, len = event.changedTouches.length; i < len; i++)\n      {\n        this._checkPositional(event.changedTouches[i]);\n        this._changeState(pc.InputType.TOUCH_END, false, event.changedTouches[i]);\n        this.fireAction(pc.InputType.TOUCH_END, event.changedTouches[i]);\n      }\n    },\n\n    _touchMove: function (event)\n    {\n      for (var i = 0, len = event.touches.length; i < len; i++)\n      {\n        this._checkPositional(event.touches[i]);\n        this._changeState(pc.InputType.TOUCH_MOVE, false, event.changedTouches[i]);\n        this.fireAction(pc.InputType.TOUCH_MOVE, event.touches[i]);\n      }\n    },\n\n    _mouseUp: function (event)\n    {\n      if (event.button == 0 || event.button == 1)\n      {\n        this._changeState(pc.InputType.MOUSE_BUTTON_LEFT_DOWN, false, event);\n        this._changeState(pc.InputType.MOUSE_BUTTON_LEFT_UP, true, event);\n        this.fireAction(pc.InputType.MOUSE_BUTTON_LEFT_UP, event);\n        this.mouseLeftButtonDown = false;\n      } else\n      {\n        this._changeState(pc.InputType.MOUSE_BUTTON_RIGHT_DOWN, false, event);\n        this._changeState(pc.InputType.MOUSE_BUTTON_RIGHT_UP, true, event);\n        this.fireAction(pc.InputType.MOUSE_BUTTON_RIGHT_UP, event);\n        this.mouseRightButtonDown = false;\n      }\n    },\n\n    _mouseDown: function (event)\n    {\n      if (event.button == 0 || event.button == 1)\n      {\n        this._changeState(pc.InputType.MOUSE_BUTTON_LEFT_DOWN, true, event);\n        this._changeState(pc.InputType.MOUSE_BUTTON_LEFT_UP, false, event);\n        this.fireAction(pc.InputType.MOUSE_BUTTON_LEFT_DOWN, event);\n        this.mouseLeftButtonDown = true;\n      } else\n      {\n        this._changeState(pc.InputType.MOUSE_BUTTON_RIGHT_DOWN, true, event);\n        this._changeState(pc.InputType.MOUSE_BUTTON_RIGHT_UP, false, event);\n        this.fireAction(pc.InputType.MOUSE_BUTTON_RIGHT_DOWN, event);\n        this.mouseRightButtonDown = true;\n      }\n    },\n    _mouseDoubleClick: function (event) {\r\n        if (event.button == 0 || event.button == 1) {\r\n            this._changeState(pc.InputType.MOUSE_BUTTON_LEFT_DBLCICK, true, event);\r\n            this.fireAction(pc.InputType.MOUSE_BUTTON_LEFT_DBLCICK, event);\r\n        }\r\n        else {\r\n            this._changeState(pc.InputType.MOUSE_BUTTON_RIGHT_DBLCICK, true, event);\r\n            this.fireAction(pc.InputType.MOUSE_BUTTON_RIGHT_DBLCICK, event);\r\n        }\r\n    },\n    _mouseMove: function (event)\n    {\n      this._lastMouseMove = event;\n    },\n\n    _contextMenu: function (event)\n    {\n      this._changeState(pc.InputType.MOUSE_BUTTON_RIGHT_UP, true, event);\n      this.fireAction(pc.InputType.MOUSE_BUTTON_RIGHT_UP, event);\n    },\n\n    _mouseWheel: function (event) {\r\n        // event.wheelDelta supported by IE and Chrome\r\n        // event.detail supported by firefox\r\n        if (event.wheelDelta > 0 || event.detail > 0) {\r\n            this.fireAction(pc.InputType.MOUSE_WHEEL_UP, event);\r\n        }\r\n        else {\r\n            this.fireAction(pc.InputType.MOUSE_WHEEL_DOWN, event);\r\n\r\n        }        \r\n        event.preventDefault();\r\n    }\n  });\n\npc.InputType = pc.Base.extend('pc.InputType',\n  {\n    // STATICS\n    nameToCode: null,\n    codeToName: null,\n\n    POSITIONAL_EVENT_START: 1000,\n    MOUSE_MOVE: 1100, // Basic mouse movement\n    MOUSE_BUTTON_LEFT_UP: 1110,\n    MOUSE_BUTTON_LEFT_DOWN: 1111,\n    MOUSE_BUTTON_LEFT_DBLCICK: 1112,\n    MOUSE_BUTTON_RIGHT_UP: 1120,\n    MOUSE_BUTTON_RIGHT_DOWN: 1121,\n    MOUSE_BUTTON_RIGHT_DBLCICK: 1122,\n    MOUSE_WHEEL_UP: 1130,\n    MOUSE_WHEEL_DOWN: 1131,\n    TOUCH: 1000,\n    TOUCH_MOVE: 1001,\n    TOUCH_END: 1002,\n    DEVICE_ORIENTATION: 1020,\n\n    init: function ()\n    {\n      this.nameToCode = new pc.Hashtable();\n      this.codeToName = new pc.Hashtable();\n\n      this.addInput(8, 'BACKSPACE');\n      this.addInput(9, 'TAB');\n      this.addInput(13, 'ENTER');\n      this.addInput(16, 'SHIFT');\n      this.addInput(17, 'CTRL');\n      this.addInput(18, 'ALT');\n      this.addInput(19, 'PAUSE');\n      this.addInput(20, 'CAPS');\n      this.addInput(27, 'ESC');\n      this.addInput(32, 'SPACE');\n      this.addInput(33, 'PAGE_UP');\n      this.addInput(34, 'PAGE_DOWN');\n      this.addInput(35, 'END');\n      this.addInput(36, 'HOME');\n      this.addInput(37, 'LEFT');\n      this.addInput(38, 'UP');\n      this.addInput(39, 'RIGHT');\n      this.addInput(40, 'DOWN');\n      this.addInput(45, 'INSERT');\n      this.addInput(46, 'DELETE');\n\n      // add alphanumierics\n      for (var c = 48; c < 91; c++)\n      {\n        var ch = String.fromCharCode(c);\n        this.addInput(c, ch);\n      }\n\n      this.addInput(91, 'WINDOW_LEFT');\n      this.addInput(92, 'WINDOW_RIGHT');\n      this.addInput(93, 'SELECT');\n      this.addInput(96, 'NUM_0');\n      this.addInput(97, 'NUM_1');\n      this.addInput(98, 'NUM_2');\n      this.addInput(99, 'NUM_3');\n      this.addInput(100, 'NUM_4');\n      this.addInput(101, 'NUM_5');\n      this.addInput(102, 'NUM_6');\n      this.addInput(103, 'NUM_7');\n      this.addInput(104, 'NUM_8');\n      this.addInput(105, 'NUM_9');\n      this.addInput(106, '*');\n      this.addInput(107, '+');\n      this.addInput(109, '-');\n      this.addInput(110, '.');\n      this.addInput(111, '/');\n      this.addInput(112, 'F1');\n      this.addInput(113, 'F2');\n      this.addInput(114, 'F3');\n      this.addInput(115, 'F4');\n      this.addInput(116, 'F5');\n      this.addInput(117, 'F6');\n      this.addInput(118, 'F7');\n      this.addInput(119, 'F8');\n      this.addInput(120, 'F9');\n      this.addInput(121, 'F10');\n      this.addInput(122, 'F11');\n      this.addInput(123, 'F12');\n      this.addInput(144, 'NUM_LOCK');\n      this.addInput(145, 'SCROLL_LOCK');\n      this.addInput(186, ';');\n      this.addInput(187, '=');\n      this.addInput(188, ',');\n      this.addInput(189, '-');\n      this.addInput(190, '.');\n      this.addInput(191, '/');\n      this.addInput(192, '`');\n      this.addInput(219, '[');\n      this.addInput(220, '\\\\');\n      this.addInput(221, ']');\n      this.addInput(222, '\\'');\n\n      this.addInput(this.DEVICE_ORIENTATION, 'DEVICE_ORIENTATION');\n\n      this.addInput(this.TOUCH, 'TOUCH');\n      this.addInput(this.TOUCH_MOVE, 'TOUCH_MOVE');\n      this.addInput(this.TOUCH_END, 'TOUCH_END');\n\n      this.addInput(this.MOUSE_BUTTON_LEFT_DOWN, 'MOUSE_BUTTON_LEFT_DOWN');\n      this.addInput(this.MOUSE_BUTTON_LEFT_UP, 'MOUSE_BUTTON_LEFT_UP');\n      this.addInput(this.MOUSE_BUTTON_LEFT_DBLCICK, 'MOUSE_BUTTON_LEFT_DBLCICK');\n      this.addInput(this.MOUSE_BUTTON_RIGHT_DOWN, 'MOUSE_BUTTON_RIGHT_DOWN');\n      this.addInput(this.MOUSE_BUTTON_RIGHT_UP, 'MOUSE_BUTTON_RIGHT_UP');\n      this.addInput(this.MOUSE_BUTTON_RIGHT_DBLCICK, 'MOUSE_BUTTON_RIGHT_DBLCICK');\n      // add some legacy support for the old MOUSE_BUTTON refs\n      this.nameToCode.put(\"MOUSE_LEFT_BUTTON\", this.MOUSE_BUTTON_LEFT_UP);\n      this.nameToCode.put(\"MOUSE_RIGHT_BUTTON\", this.MOUSE_BUTTON_RIGHT_UP);\n\n      this.addInput(this.MOUSE_WHEEL_UP, 'MOUSE_WHEEL_UP');\n      this.addInput(this.MOUSE_WHEEL_DOWN, 'MOUSE_WHEEL_DOWN');\n      this.addInput(this.MOUSE_MOVE, 'MOUSE_MOVE');\n    },\n\n    isDeviceOrientation: function (inputCode)\n    {\n      return inputCode == this.DEVICE_ORIENTATION;\n    },\n\n    isTouch: function (inputCode)\n    {\n      return inputCode == this.TOUCH;\n    },\n\n    isPositional: function (inputCode)\n    {\n      return inputCode >= this.POSITIONAL_EVENT_START;\n    },\n\n    /**\n     * Private utility method used by the constructor to add the input codes and lookup\n     * names to both indexes/hash tables\n     * @param inputCode event input code (i.e. event.keyCode)\n     * @param inputName the human name of the input\n     */\n    addInput: function (inputCode, inputName)\n    {\n      this.codeToName.put(inputCode, inputName);\n      this.nameToCode.put(inputName, inputCode);\n    },\n\n    /**\n     * Returns the name of an input based on the event code\n     * @param inputCode\n     */\n    getName: function (inputCode)\n    {\n      return this.codeToName.get(inputCode);\n    },\n\n    /**\n     * Returns the code of an input based on the input name\n     * @param inputName\n     */\n    getCode: function (inputName)\n    {\n      return this.nameToCode.get(inputName);\n    }\n\n\n  },\n  {}\n);\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.Hashmap\n * @description\n * [Extends <a href='pc.Layer'>pc.Base</a>]\n * <p>\n * An implementation of a simple hashmap you can use to store key value pairs.\n * <p>\n * <pre><code>\n * // create a hashmap\n * var map = new pc.Hashmap();\n * map.put('key', 'value');\n * map.get('key') === 'value';\n * map.hasKey('key'); // true\n * map.remove('key');\n * </code></pre>\n */\n\npc.Hashmap = pc.Base.extend('pc.Hashmap',\n    {},\n    /** @lends pc.Hashmap.prototype */\n    {\n        init:function()\n        {\n           this._super();//console.log(this.items.toString());\n           this.items = {};\n        },\n\n        /** number of items in the map */\n        length: 0,\n        /** an object containing all the items as properties */\n        items: {},\n\n        /**\n         * Put a key, value pair into the map\n         * @param {String} key Key to map the value to\n         * @param {Object} value The value\n         */\n        put: function(key, value)\n        {\n            if (!pc.valid(key)) throw \"invaid key\";\n            this.items[key] = value;\n            this.length++;\n        },\n\n        /**\n         * Get a value using a key\n         * @param {String} key The key\n         * @return {Object} Value mapped to the key\n         */\n        get: function(key)\n        {\n           return this.items[key];\n        },\n\n        /**\n         * Indicates whether a key exists in the map\n         * @param {String} key The key\n         * @return {Boolean} True if the key exists in the map\n         */\n        hasKey: function(key)\n        {\n            return this.items.hasOwnProperty(key);\n        },\n\n        /**\n         * Remove an element from the map using the supplied key\n         * @param {String} key Key of the item to remove\n         */\n        remove: function(key)\n        {\n            if (this.hasKey(key))\n            {\n                this.length--;\n                delete this.items[key];\n            }\n        },\n\n        /**\n         * @return {Array} Returns an array of all the keys in the map\n         */\n        keys: function()\n        {\n            var keys = [];\n            for (var k in this.items)\n                keys.push(k);\n            return keys;\n        },\n\n        /**\n         * @return {Array} Returns an array of all the values in the map\n         */\n        values: function()\n        {\n            var values = [];\n            for (var k in this.items)\n                values.push(this.items[k]);\n            return values;\n        },\n\n        /**\n         * Removes all items in the map\n         */\n        clear: function()\n        {\n            this.items = {};\n            this.length = 0;\n        }\n    });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n *\n * xmlToJSON function:\n * This work is licensed under Creative Commons GNU LGPL License.\n * License: http://creativecommons.org/licenses/LGPL/2.1/\n * Version: 0.9\n * Author:  Stefan Goessner/2006\n * Web:     http://goessner.net/\n */\n\n/**\n * @class pc.Tools\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * A collection of useful tools. This is a static class, so you can just call methods directly, i.e.\n * <p><pre><code>\n * var cleanValue = pc.Tools.checked(value, 'default');\n * </code></pre>\n * There are shortcuts for the following common tools functions to make like a little easier:\n * <p><pre><code>\n * pc.valid = pc.Tools.isValid;\n * pc.checked = pc.Tools.checked;\n * pc.assert = pc.Tools.assert;\n * </code></pre>\n */\npc.Tools = pc.Base.extend('pc.Tools',\n    /** @lends pc.Tools */\n    {\n        /**\n         * Checks if a param is valid (null or undefined) in which case the default value will be returned\n         * @param {*} p Parameter to check\n         * @param {*} def Default value to return if p is either null or undefined\n         * @return {*} p if valid, otherwise def (default)\n         */\n        checked:function (p, def)\n        {\n            if (!pc.valid(p))\n                return def;\n            return p;\n        },\n\n        /**\n         * Check if a value is valid (not null or undefined)\n         * @param {*} p A value\n         * @return {Boolean} true if the value is not undefined and not null\n         */\n        isValid:function (p)\n        {\n            return !(p == null || typeof p === 'undefined');\n        },\n\n        /**\n         * Tests a boolean evaluation and throws an exception with the error string.\n         * @param {Boolean} test A boolean result test\n         * @param {String} error A string to throw with the exception\n         */\n        assert:function (test, error)\n        {\n            if (!test) throw error;\n        },\n\n        /**\n         * Removes an element from an array\n         * @param {Array} array The array to remove the element from\n         * @param {*} e The element to remove\n         */\n        arrayRemove:function (array, e)\n        {\n\n            //for (var i = 0; i < array.length; i++)\n            for (var i = array.length - 1; i >= 0; i--)\n            {\n                if (array[i] == e)\n                    array.splice(i, 1);\n            }\n        },\n\n        /**\n         * Adds an element to an array, but only if it isn't already there\n         * @param array the array to add to\n         * @param e the element to add\n         */\n        arrayExclusiveAdd:function (array, e)\n        {\n            if (array.indexOf(e) == -1)\n                array.push(e);\n        },\n\n        /**\n         * Convers XML to a json string\n         * @param {String} xml XML source data as a string\n         * @param {String} tab String to use for tabulation\n         * @return {String} JSON string form of the XML\n         */\n        xmlToJson:function (xml, tab)\n        {\n            var X = {\n                toObj:function (xml)\n                {\n                    var o = {};\n                    if (xml.nodeType == 1)\n                    {   // element node ..\n                        if (xml.attributes.length)   // element with attributes  ..\n                            for (var i = 0; i < xml.attributes.length; i++)\n                                o[xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue || \"\").toString();\n                        if (xml.firstChild)\n                        { // element has child nodes ..\n                            var textChild = 0, cdataChild = 0, hasElementChild = false;\n                            for (var n = xml.firstChild; n; n = n.nextSibling)\n                            {\n                                if (n.nodeType == 1) hasElementChild = true;\n                                else if (n.nodeType == 3 && n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) textChild++; // non-whitespace text\n                                else if (n.nodeType == 4) cdataChild++; // cdata section node\n                            }\n                            if (hasElementChild)\n                            {\n                                if (textChild < 2 && cdataChild < 2)\n                                { // structured element with evtl. a single text or/and cdata node ..\n                                    X.removeWhite(xml);\n                                    for (var n = xml.firstChild; n; n = n.nextSibling)\n                                    {\n                                        if (n.nodeType == 3)  // text node\n                                            o[\"#text\"] = X.escape(n.nodeValue);\n                                        else if (n.nodeType == 4)  // cdata node\n                                            o[\"#cdata\"] = X.escape(n.nodeValue);\n                                        else if (o[n.nodeName])\n                                        {  // multiple occurence of element ..\n                                            if (o[n.nodeName] instanceof Array)\n                                                o[n.nodeName][o[n.nodeName].length] = X.toObj(n);\n                                            else\n                                                o[n.nodeName] = [o[n.nodeName], X.toObj(n)];\n                                        }\n                                        else  // first occurence of element..\n                                            o[n.nodeName] = X.toObj(n);\n                                    }\n                                }\n                                else\n                                { // mixed content\n                                    if (!xml.attributes.length)\n                                        o = X.escape(X.innerXml(xml));\n                                    else\n                                        o[\"#text\"] = X.escape(X.innerXml(xml));\n                                }\n                            }\n                            else if (textChild)\n                            { // pure text\n                                if (!xml.attributes.length)\n                                    o = X.escape(X.innerXml(xml));\n                                else\n                                    o[\"#text\"] = X.escape(X.innerXml(xml));\n                            }\n                            else if (cdataChild)\n                            { // cdata\n                                if (cdataChild > 1)\n                                    o = X.escape(X.innerXml(xml));\n                                else\n                                    for (var n = xml.firstChild; n; n = n.nextSibling)\n                                        o[\"#cdata\"] = X.escape(n.nodeValue);\n                            }\n                        }\n                        if (!xml.attributes.length && !xml.firstChild) o = null;\n                    }\n                    else if (xml.nodeType == 9)\n                    { // document.node\n                        o = X.toObj(xml.documentElement);\n                    }\n                    else\n                        alert(\"unhandled node type: \" + xml.nodeType);\n                    return o;\n                },\n                toJson:function (o, name, ind)\n                {\n                    var json = name ? (\"\\\"\" + name + \"\\\"\") : \"\";\n                    if (o instanceof Array)\n                    {\n                        for (var i = 0, n = o.length; i < n; i++)\n                            o[i] = X.toJson(o[i], \"\", ind + \"\\t\");\n                        json += (name ? \":[\" : \"[\") + (o.length > 1 ? (\"\\n\" + ind + \"\\t\" + o.join(\",\\n\" + ind + \"\\t\") + \"\\n\" + ind) : o.join(\"\")) + \"]\";\n                    }\n                    else if (o == null)\n                        json += (name && \":\") + \"null\";\n                    else if (typeof(o) == \"object\")\n                    {\n                        var arr = [];\n                        for (var m in o)\n                            arr[arr.length] = X.toJson(o[m], m, ind + \"\\t\");\n                        json += (name ? \":{\" : \"{\") + (arr.length > 1 ? (\"\\n\" + ind + \"\\t\" + arr.join(\",\\n\" + ind + \"\\t\") + \"\\n\" + ind) : arr.join(\"\")) + \"}\";\n                    }\n                    else if (typeof(o) == \"string\")\n                        json += (name && \":\") + \"\\\"\" + o.toString() + \"\\\"\";\n                    else\n                        json += (name && \":\") + o.toString();\n                    return json;\n                },\n                innerXml:function (node)\n                {\n                    var s = \"\"\n                    if (\"innerHTML\" in node)\n                        s = node.innerHTML;\n                    else\n                    {\n                        var asXml = function (n)\n                        {\n                            var s = \"\";\n                            if (n.nodeType == 1)\n                            {\n                                s += \"<\" + n.nodeName;\n                                for (var i = 0; i < n.attributes.length; i++)\n                                    s += \" \" + n.attributes[i].nodeName + \"=\\\"\" + (n.attributes[i].nodeValue || \"\").toString() + \"\\\"\";\n                                if (n.firstChild)\n                                {\n                                    s += \">\";\n                                    for (var c = n.firstChild; c; c = c.nextSibling)\n                                        s += asXml(c);\n                                    s += \"</\" + n.nodeName + \">\";\n                                }\n                                else\n                                    s += \"/>\";\n                            }\n                            else if (n.nodeType == 3)\n                                s += n.nodeValue;\n                            else if (n.nodeType == 4)\n                                s += \"<![CDATA[\" + n.nodeValue + \"]]>\";\n                            return s;\n                        };\n                        for (var c = node.firstChild; c; c = c.nextSibling)\n                            s += asXml(c);\n                    }\n                    return s;\n                },\n                escape:function (txt)\n                {\n                    return txt.replace(/[\\\\]/g, \"\\\\\\\\\")\n                        .replace(/[\\\"]/g, '\\\\\"')\n                        .replace(/[\\n]/g, '\\\\n')\n                        .replace(/[\\r]/g, '\\\\r');\n                },\n                removeWhite:function (e)\n                {\n                    e.normalize();\n                    for (var n = e.firstChild; n;)\n                    {\n                        if (n.nodeType == 3)\n                        {  // text node\n                            if (!n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/))\n                            { // pure whitespace text node\n                                var nxt = n.nextSibling;\n                                e.removeChild(n);\n                                n = nxt;\n                            }\n                            else\n                                n = n.nextSibling;\n                        }\n                        else if (n.nodeType == 1)\n                        {  // element node\n                            X.removeWhite(n);\n                            n = n.nextSibling;\n                        }\n                        else                      // any other node\n                            n = n.nextSibling;\n                    }\n                    return e;\n                }\n            };\n            if (xml.nodeType == 9) // document node\n                xml = xml.documentElement;\n            var json = X.toJson(X.toObj(X.removeWhite(xml)), xml.nodeName, \"\\t\");\n            return \"{\\n\" + tab + (tab ? json.replace(/\\t/g, tab) : json.replace(/\\t|\\n/g, \"\")) + \"\\n}\";\n        }\n    },\n    {\n        // Static class, so nothing required here\n    }\n)\n;\n\n\npc.tools = new pc.Tools();\n\n// quick short cuts for common tools\npc.valid = pc.Tools.isValid;\npc.checked = pc.Tools.checked;\npc.assert = pc.Tools.assert;\n\n\n/**\n *\n *  Base64 encode / decode\n *  http://www.webtoolkit.info/\n *\n **/\n\n\n\n\npc.Base64 = pc.Base.extend('pc.Base64',\n    {\n        // private property\n        _keyStr : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n\n        // public method for encoding\n        encode : function (input) {\n            var output = \"\";\n            var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n            var i = 0;\n\n            input = pc.Base64._utf8_encode(input);\n\n            while (i < input.length) {\n\n                chr1 = input.charCodeAt(i++);\n                chr2 = input.charCodeAt(i++);\n                chr3 = input.charCodeAt(i++);\n\n                enc1 = chr1 >> 2;\n                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n                enc4 = chr3 & 63;\n\n                if (isNaN(chr2)) {\n                    enc3 = enc4 = 64;\n                } else if (isNaN(chr3)) {\n                    enc4 = 64;\n                }\n\n                output = output +\n                    this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\n                    this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\n\n            }\n\n            return output;\n        },\n\n        // public method for decoding\n        decode : function (input) {\n            var output = [];\n            var chr1, chr2, chr3;\n            var enc1, enc2, enc3, enc4;\n            var i = 0;\n\n            input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n            while (i < input.length) {\n\n                enc1 = this._keyStr.indexOf(input.charAt(i++));\n                enc2 = this._keyStr.indexOf(input.charAt(i++));\n                enc3 = this._keyStr.indexOf(input.charAt(i++));\n                enc4 = this._keyStr.indexOf(input.charAt(i++));\n\n                chr1 = (enc1 << 2) | (enc2 >> 4);\n                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n                chr3 = ((enc3 & 3) << 6) | enc4;\n\n                output.push(String.fromCharCode(chr1));\n\n                if (enc3 != 64) {\n                    output.push(String.fromCharCode(chr2));\n                }\n                if (enc4 != 64) {\n                    output.push(String.fromCharCode(chr3));\n                }\n\n            }\n\n            return output.join('');\n\n        },\n\n        // private method for UTF-8 encoding\n        _utf8_encode : function (string) {\n            string = string.replace(/\\r\\n/g,\"\\n\");\n            var utftext = \"\";\n\n            for (var n = 0; n < string.length; n++) {\n\n                var c = string.charCodeAt(n);\n\n                if (c < 128) {\n                    utftext += String.fromCharCode(c);\n                }\n                else if((c > 127) && (c < 2048)) {\n                    utftext += String.fromCharCode((c >> 6) | 192);\n                    utftext += String.fromCharCode((c & 63) | 128);\n                }\n                else {\n                    utftext += String.fromCharCode((c >> 12) | 224);\n                    utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n                    utftext += String.fromCharCode((c & 63) | 128);\n                }\n\n            }\n\n            return utftext;\n        },\n\n        // private method for UTF-8 decoding\n        _utf8_decode : function (utftext) {\n            var string = \"\";\n            var i = 0;\n            var c = c1 = c2 = 0;\n\n            while ( i < utftext.length ) {\n\n                c = utftext.charCodeAt(i);\n\n                if (c < 128) {\n                    string += String.fromCharCode(c);\n                    i++;\n                }\n                else if((c > 191) && (c < 224)) {\n                    c2 = utftext.charCodeAt(i+1);\n                    string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n                    i += 2;\n                }\n                else {\n                    c2 = utftext.charCodeAt(i+1);\n                    c3 = utftext.charCodeAt(i+2);\n                    string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n                    i += 3;\n                }\n\n            }\n\n            return string;\n        }\n\n    },\n    {});\n\n// fix for browsers that don't natively support atob or btoa (ie. IE)\nif (!window.btoa) window.btoa = pc.Base64.encode\nif (!window.atob) window.atob = pc.Base64.decode",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.Color\n * @augments pc.Pooled\n * @description\n * A general purpose representation of a color. You can create a color either an array [R,G,B] or using a hex color\n * string in the form of #RRGGBB. (For alpha see the pc.component.Alpha and pc.components.Fade).\n * <p>\n *     Create a color using either new:\n * <pre><code>\n * var color = new pc.Color([255, 0, 0]); // super red\n * var color2 = new pc.Color('#00FF00'); // super green\n * </code></pre>\n * <p>\n *     Or, as a pooled object:\n * <pre><code>\n * var color = pc.Color.create([255, 0, 0]); // super red\n * </code></pre>\n */\npc.Color = pc.Pooled.extend('pc.Color',\n  /** @lends pc.Color */\n  {\n    /**\n     * Constructs a color object using the passed in color\n     * @param {Array|String} color Can either be a string in the form of #RRGGBB or an array of 3 numbers representing red,\n     * green, blue levels, i.e. full red is [255, 0, 0]\n     */\n    create: function (color)\n    {\n      var n = this._super();\n      n.config(color);\n      return n;\n    }\n  },\n  /** @lends pc.Color.prototype */\n  {\n    /** Array of current colors */\n    rgb: [],\n    /** Representation of the current color as an rgb string. Automatically updates as you change color */\n    color: null,\n\n    /**\n     * Constructs a new color using the passed in color string. Used if you call new pc.Color, but typically\n     * you should be using pc.Color.create as this is a pooled class\n     * @param {Array|String} color Can either be a string in the form of #RRGGBB or an array of 3 numbers representing red,\n     * green, blue levels, i.e. full red is [255, 0, 0]\n     */\n    init: function (color)\n    {\n      if (color != undefined)\n        this.config(color);\n    },\n\n    /**\n     * Configure this color object with a given color\n     * @param {Array|String} color Can either be a string in the form of #RRGGBB or an array of 3 numbers representing red,\n     * green, blue levels, i.e. full red is [255, 0, 0]\n     */\n    config: function (color)\n    {\n      if (!color) return;\n\n      if (Array.isArray(color))\n        this.rgb = color;\n      else\n      {\n        if (color.charAt(0) === '#')\n        {\n          this.rgb[0] = parseInt(color.substring(1, 3), 16);\n          this.rgb[1] = parseInt(color.substring(3, 5), 16);\n          this.rgb[2] = parseInt(color.substring(5, 7), 16);\n        } else\n          throw \"Invalid color: use either array [r,g,b] or '#RRGGBB'\";\n      }\n      this._updateColorCache();\n    },\n\n    /**\n     * Sets this color object to a given color (synonym for config(color)\n     * @param {Array|String} color Can either be a string in the form of #RRGGBB or an array of 3 numbers representing red,\n     * green, blue levels, i.e. full red is [255, 0, 0]\n     */\n    set: function (color)\n    {\n      this.config(color);\n    },\n\n    /**\n     * Sets the red component of the color\n     * @param {Number} r Red component of the color to set\n     */\n    setRed: function (r)\n    {\n      this.rgb[0] = pc.Math.limit(r, 0, 255);\n      this._updateColorCache();\n    },\n\n    /**\n     * Adds to the red component of the color\n     * @param {Number} r Red component\n     */\n    addRed: function (r)\n    {\n      this.rgb[0] = pc.Math.limitAdd(this.rgb[0], r, 0, 255);\n      this._updateColorCache();\n    },\n\n    /**\n     * Subtracts from the red component of the color\n     * @param {Number} r Red component\n     */\n    subRed: function (r)\n    {\n      this.rgb[0] = pc.Math.limitAdd(this.rgb[0], -r, 0, 255);\n      this._updateColorCache();\n    },\n\n    /**\n     * Sets the green component of the color\n     * @param {Number} g Green component of the color to set\n     */\n    setGreen: function (g)\n    {\n      this.rgb[1] = pc.Math.limit(g, 0, 255);\n      this._updateColorCache();\n    },\n\n    /**\n     * Adds to the green component of the color\n     * @param {Number} g Green component\n     */\n    addGreen: function (g)\n    {\n      this.rgb[1] = pc.Math.limitAdd(this.rgb[1], g, 0, 255);\n      this._updateColorCache();\n    },\n\n    /**\n     * Subtracts from the green component of the color\n     * @param {Number} g Green component\n     */\n    subGreen: function (g)\n    {\n      this.rgb[1] = pc.Math.limitAdd(this.rgb[1], -g, 0, 255);\n      this._updateColorCache();\n    },\n\n    /**\n     * Sets the blue component of the color\n     * @param {Number} b Blue component of the color to set\n     */\n    setBlue: function (b)\n    {\n      this.rgb[2] = pc.Math.limit(b, 0, 255);\n      this._updateColorCache();\n    },\n\n    /**\n     * Adds to the blue component of the color\n     * @param {Number} b Blue component of the color to set\n     */\n    addBlue: function (b)\n    {\n      this.rgb[2] = pc.Math.limitAdd(this.rgb[2], b, 0, 255);\n      this._updateColorCache();\n    },\n\n    /**\n     * Subtracts from the blue component of the color\n     * @param {Number} b Blue component\n     */\n    subBlue: function (b)\n    {\n      this.rgb[2] = pc.Math.limitAdd(this.rgb[2], -b, 0, 255);\n      this._updateColorCache();\n    },\n\n    /**\n     * Darkens the color by the given value (1..255)\n     * @param {Number} amt Amount to darken the color by\n     */\n    darken: function (amt)\n    {\n      this.subRed(amt);\n      this.subGreen(amt);\n      this.subBlue(amt);\n    },\n\n    /**\n     * Lightens the color by the given amount (1..255)\n     * @param {Number} amt Amount to lighten the color by\n     */\n    lighten: function (amt)\n    {\n      this.addRed(amt);\n      this.addGreen(amt);\n      this.addBlue(amt);\n    },\n\n    _updateColorCache: function ()\n    {\n      // todo: this is constructing a string on every adjustment: can we save on that?\n      this.color = 'rgb(' + this.rgb[0] + ',' + this.rgb[1] + ',' + this.rgb[2] + ')';\n    }\n\n\n  });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.DebugPanel\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * This class is used to create the real-time debugging panels. An instance of this class is automatically constructed\n * by the pc.device system. When onReady is triggered the panel will automatically attach to a canvas element with the\n * id 'debug'.\n * <p>\n * <pre><code>\n * &ltcanvas id=\"debug\"&gt&lt/canvas&gt\n * </code></pre>\n * The debug panel will automatically size to the available space in the canvas element.\n * <p>\n * You can gain access to the debug panel through pc.device.debugPanel member.\n */\n\npc.DebugPanel = pc.Base('pc.DebugPanel',\n    {},\n    /** @lends pc.DebugPanel.prototype */\n    {\n        x:0,\n        y:0,\n        panelHeight:0,\n        panelWidth:0,\n        canvas:null,\n        ctx:null,\n        statusText:null,\n        active:false,\n        timeGraph:null,\n        memGraph:null,\n        entityGraph:null,\n        poolGraph:null,\n        currentMem:0,\n        lastMem:0,\n\n        init:function ()\n        {\n            this._super();\n        },\n\n        onReady:function ()\n        {\n            this.attach('pcDebug');\n        },\n\n        /**\n         * Attach the debug panel to a canvas element with the supplied id\n         * @param {String} canvasElement Id of a canvas element to attach to\n         */\n        attach:function (canvasElement)\n        {\n            this.canvas = document.getElementById(canvasElement);\n            if (this.canvas == null)\n            {\n                this.warn('Showing debug requires a div with an id of \"debug\" to be added to your dom.');\n                pc.device.showDebug = false;\n                return;\n            }\n\n            // resize the canvas to be the size of it's parent (containing element)\n            this.panelElement = this.canvas.parentNode;\n            this.ctx = this.canvas.getContext('2d');\n            this.onResize();\n\n            var np = 4;\n            // create the graphs\n            this.timeGraph = new pc.CanvasLineGraph(this.ctx, 'Performance', '', 10,\n                [\n                    {name:'process (ms)', color:'#f55'},\n                    { name:'render (ms)', color:'#5f5'}\n                ], 10, 10, (this.panelWidth / np) - 10, this.panelHeight - 20);\n\n            if (typeof console.memory === 'undefined' || console.memory.totalJSHeapSize == 0)\n            {\n                this.memGraph = new pc.CanvasLineGraph(this.ctx, 'Memory', 'Memory profiling not available', 0,\n                    [\n                        {name:'mem used (mb)', color:'#55f'}\n                    ], (this.panelWidth / np) + 10, 10, (this.panelWidth / np) - 10, this.panelHeight - 20);\n            } else\n            {\n                this.memGraph = new pc.CanvasLineGraph(this.ctx, 'Memory', '', ((console.memory.totalJSHeapSize / 1024 / 1024) * 1.2),\n                    [\n                        {name:'mem used (mb)', color:'#55f'}\n                    ], (this.panelWidth / np) + 10, 10, (this.panelWidth / np) - 10, this.panelHeight - 20);\n            }\n\n            this.poolGraph = new pc.CanvasLineGraph(this.ctx, 'Pool Size', '', 100,\n                [\n                    {name:'pooled', color:'#5b1654'}\n                ], this.panelWidth - ((this.panelWidth / np) * 2) + 10, 10, (this.panelWidth / np) - 20, this.panelHeight - 20);\n\n            this.entityGraph = new pc.CanvasLineGraph(this.ctx, 'Entities', '', 100,\n                [\n                    { name:'drawn (total)', color:'#f9f007'}\n                ], this.panelWidth - (this.panelWidth / np) + 10, 10, (this.panelWidth / np) - 20, this.panelHeight - 20);\n\n            this.active = true;\n        },\n\n        onResize:function ()\n        {\n            if (this.canvas == null) return;\n\n            this.canvas.width = this.panelElement.offsetWidth;\n            this.canvas.height = this.panelElement.offsetHeight;\n            this.panelWidth = this.panelElement.offsetWidth;\n            this.panelHeight = this.panelElement.offsetHeight;\n\n            // clear the background\n            this.ctx.fillStyle = '#111';\n            this.ctx.fillRect(0, 0, this.panelWidth, this.panelHeight);\n\n            var np = 4;\n            if (this.timeGraph != null)\n                this.timeGraph.resize(10, 10, this.panelWidth / np - 10, this.panelHeight - 20);\n            if (this.memGraph != null)\n                this.memGraph.resize(this.panelWidth / np + 10, 10, this.panelWidth / np - 10, this.panelHeight - 20);\n            if (this.poolGraph != null)\n                this.poolGraph.resize(this.panelWidth - ((this.panelWidth / np) * 2) + 20, 10, this.panelWidth / np - 20, this.panelHeight - 20);\n            if (this.entityGraph != null)\n                this.entityGraph.resize(this.panelWidth - (this.panelWidth / np) + 10, 10, this.panelWidth / np - 20, this.panelHeight - 20);\n\n        },\n\n        _timeSince:0,\n\n        update:function (delta)\n        {\n            if (!this.active) return;\n\n            // update the averages\n            this._timeSince += delta;\n            if (this._timeSince > 30)\n            {\n                this._timeSince = 0;\n                if (this.timeGraph != null)\n                    this.timeGraph.addLine2(pc.device.lastProcessMS, pc.device.lastDrawMS);\n                if (this.entityGraph != null)\n                    this.entityGraph.addLine1(pc.device.elementsDrawn);\n                if (this.memGraph != null)\n                    if (typeof console.memory !== 'undefined')\n                        if (console.memory.totalJSHeapSize != 0)\n                            this.memGraph.addLine1((console.memory.usedJSHeapSize / 1024 / 1024));\n                if (this.poolGraph != null)\n                    this.poolGraph.addLine1(gamecore.Pool.totalPooled);\n            }\n        },\n\n        draw:function ()\n        {\n            if (!this.active) return;\n\n            if (this.timeGraph != null)\n                this.timeGraph.draw();\n            if (this.entityGraph != null)\n                this.entityGraph.draw();\n            if (this.memGraph != null) this.memGraph.draw();\n            if (this.poolGraph != null) this.poolGraph.draw();\n        }\n\n    });\n\n\n/**\n * CanvasLineGraph -- a line bar graph designed to be update quickly (optimized drawing)\n * rendered onto a canvas. Used primarily by the debug panel to display pretty graphs\n * of performance, memory, entity and network graphs.\n */\npc.CanvasLineGraph = pc.Base.extend('pc.CanvasLineGraph', {\n\n    height:0,\n    width:0,\n    ctx:null,\n    data:null,\n    maxY:0, // top most range value\n    x:0,\n    y:0,\n    labels:null,\n    graphName:null,\n    bgCanvas:null, // off screen canvas for background (grid etc)\n    graphCanvas:null, // off screen canvas for graph\n    message:null,\n    cursor:0, // position in the data array that is the head of the data\n\n    init:function (ctx, graphName, message, maxY, labels, x, y, width, height)\n    {\n        this._super();\n\n        this.ctx = ctx;\n        this.message = message;\n        this.graphName = graphName;\n        this.maxY = maxY;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.labels = labels;\n        this.graphX = this.x + this.graphLeftMargin;\n        this.graphY = this.y + 20;\n        this.cursor = 0;\n\n        this.graphCanvas = document.createElement('canvas');\n        this.bgCanvas = document.createElement('canvas');\n\n        this.resize(x, y, width, height);\n    },\n\n    resize:function (x, y, width, height)\n    {\n        this.width = Math.max(width, 1);\n        this.height = Math.max(height, 1);\n        this.x = x;\n        this.y = y;\n\n        // size the graph component\n        this.graphHeight = this.height - 40;\n        this.graphWidth = this.width - (this.graphLeftMargin + this.graphRightMargin);\n        this.graphX = this.graphLeftMargin;\n        this.graphY = 20;\n\n        this.bgCanvas.width = this.width;\n        this.bgCanvas.height = this.height;\n        this.graphCanvas.width = Math.max(this.graphWidth, 1);\n        this.graphCanvas.height = Math.max(this.graphHeight, 1);\n\n        // resize the data array?\n        this.resizeDataArray(this.graphWidth, this.labels.length);\n        this.renderBackground();\n    },\n\n    resizeDataArray:function (newSize, numDataPoints)\n    {\n        var start = 0;\n        if (newSize <= 0) newSize = 1;\n\n        if (this.data == null)\n            this.data = [];\n        else\n        {\n            // resize the array\n            if (newSize+1 > this.data.length) // growing?\n            {\n                start = this.data.length - 1;\n            }\n            else\n            {\n                // shrinking -- we cut from the begining\n                this.data.slice(0, newSize - this.data.length);\n                if (this.cursor > this.data.length - 1)\n                    this.cursor = this.data.length - 1;\n                return; // job done, no new init needed (it's smaller)\n            }\n        }\n\n        // add some new data -- the array is expanding\n        for (var i = start; i < newSize; i++)\n            this.data.push(new Array(numDataPoints));\n    },\n\n    _totalAdded:0,\n    linesSinceLastPeak:0, // set a new peak every n lines\n    lastPeak:0,\n    _total:0,\n\n    // we use this to add multiple data items -- saves using variable length arrays (which chew\n    // memory, thus we only currently support graphs with up to two data elements to a line.\n    // if you want more, add an addLine3 method\n    addLine2:function (lineData1, lineData2)\n    {\n        if (!this.data) return;\n\n        this._totalAdded++;\n        this._total = lineData1 + lineData2;\n        this.checkMaxRange(this._total);\n        this.data[this.cursor][0] = lineData1;\n        this.data[this.cursor][1] = lineData2;\n        this._updateGraph(this._total);\n    },\n\n    addLine1:function (lineData1)\n    {\n        if (!this.data) return;\n\n        this._totalAdded++;\n        this._total = lineData1;\n        this.checkMaxRange(this._total);\n        this.data[this.cursor][0] = lineData1;\n        this._updateGraph(lineData1);\n    },\n\n    checkMaxRange:function (max)\n    {\n        if (max > this.maxY)\n        {\n            this.maxY = max * 1.4;\n            // make sure the absolute smallest number of axis is equal to the height of the graph\n            if (this.maxY < this.height / this.gridLineInc)\n                this.maxY = this.height / this.gridLineInc;\n            this.renderBackground();\n            this.renderGraph(true);\n        }\n    },\n\n    _updateGraph:function (total)\n    {\n        this.linesSinceLastPeak++;\n        if (this.linesSinceLastPeak > this.width * 1.5)\n        {\n            this.linesSinceLastPeak++;\n            this.maxY = total * 1.4;\n            // make sure the absolute smallest number of axis is equal to the height of the graph\n            if (this.maxY < this.height / this.gridLineInc)\n                this.maxY = this.height / this.gridLineInc;\n\n            this.lastPeak = total * 1.4;\n            this.renderBackground();\n            this.linesSinceLastPeak = 0;\n        }\n\n        if (total > this.lastPeak)\n            this.lastPeak = total * 1.4;\n\n        this.cursor++;\n        if (this.cursor > this.data.length - 1)\n            this.cursor = 0;\n\n    },\n\n    margin:20,\n    linePixelSize:0,\n    yline:0,\n    unit:0,\n    gridY:0,\n    i:0,\n    n:0,\n    graphLeftMargin:30,\n    graphRightMargin:15,\n    graphHeight:0,\n    graphWidth:0,\n    graphX:0,\n    graphY:0,\n    gridLineInc:15,\n\n    /**\n     * Renders to an offscreen background canvas, which is only drawn on or resize\n     */\n    renderBackground:function ()\n    {\n        var ctx = this.bgCanvas.getContext('2d');\n\n        ctx.fillStyle = '#000';\n        ctx.fillRect(0, 0, this.width, this.height);\n\n        // graph title\n        ctx.fillStyle = '#aaa';\n        ctx.font = '11px sans-serif';\n        ctx.fillText(this.graphName, this.graphX, this.graphY - 6);\n\n        // draw the surround rectangle\n        ctx.strokeStyle = '#111';\n        ctx.strokeRect(this.graphX + 0.5, this.graphY + 0.5, this.graphWidth, this.graphHeight);\n\n        // DRAW GRID AND MARKERS (Y AXIS)\n        this.unit = (this.graphHeight) / this.maxY; // figure out the y scale\n        var graphLines = (this.graphHeight + this.gridLineInc) / this.gridLineInc;\n        var axisInc = this.maxY / graphLines;\n        var axisValue = 0;\n        var lineCount = 0;\n\n        for (this.gridY = this.graphHeight + this.graphY; this.gridY > this.graphY + 1; this.gridY -= this.gridLineInc)\n        {\n            lineCount++;\n            ctx.textAlign = 'right';\n            (lineCount % 2 == 0) ? ctx.fillStyle = '#111' : ctx.fillStyle = '#000';\n\n            var lineHeight = this.gridLineInc;\n            if (this.gridY - lineHeight < this.graphY)\n            {\n                lineHeight = (this.gridY - this.graphY);\n                ctx.fillRect(this.graphX + 1, this.graphY + 1, this.graphWidth - 2, lineHeight - 1);\n            } else\n                ctx.fillRect(this.graphX + 1, this.gridY - lineHeight - 1, this.graphWidth - 2, lineHeight);\n\n            axisValue = Math.round(axisInc * lineCount);\n            ctx.fillStyle = '#777';\n            ctx.fillText('' + axisValue, this.graphX - 5, this.gridY);\n        }\n\n        // DRAW LEGEND\n        ctx.globalAlpha = 1;\n        ctx.textAlign = 'left';\n        var legendY = this.height - 13;\n        var textX = this.graphLeftMargin + 3;\n\n        for (this.n = 0; this.n < this.labels.length; this.n++)\n        {\n            ctx.fillStyle = this.labels[this.n].color;\n            ctx.fillRect(textX, legendY, 5, 5);\n            ctx.fillStyle = '#888';\n            ctx.fillText(this.labels[this.n].name, textX + 8, legendY + 6);\n            textX += ctx.measureText(this.labels[this.n].name).width + 18;\n        }\n\n        this.renderGraph(true);\n    },\n\n    renderGraph:function (completeRedraw)\n    {\n        if (!this.data) return;\n\n        var gtx = this.graphCanvas.getContext('2d');\n        if (completeRedraw)\n        {\n            gtx.fillStyle = '#000';\n            gtx.fillRect(0, 0, this.graphWidth, this.graphHeight);\n        } else if (this._totalAdded > this.graphWidth) // we are appending a line\n            gtx.drawImage(this.graphCanvas, -1, 0); // so draw the previous graph shift by one\n\n        // now draw a new line on the far right side\n        var len = 0;\n\n        if (completeRedraw)\n        {\n            len = this.data.length - 1;\n            this.dx = 1;\n\n        } else\n        {\n            // draw the first set of lines across, prior to scrolling\n            if (this._totalAdded < this.graphWidth)\n                this.dx = this.cursor;\n            else\n                this.dx = this.graphWidth - 1;\n            len = this.dx + 1;\n        }\n\n        if (len == 0) return;\n\n        // dx is the count of pixels across the screen\n        // dpos is the cursor being drawn pointing inside the array\n        var dpos = this.cursor - 1;\n        if (dpos < 0) dpos = this.data.length - 1;\n\n        for (; this.dx < len; this.dx++)\n        {\n            if (dpos > this.data.length - 1) dpos = 0;\n\n            gtx.fillStyle = '#000';\n            gtx.fillRect(this.dx, 0, 1, this.graphHeight);\n\n            this.yline = this.graphHeight; // start at the bottom of the graph\n\n            for (this.i = 0; this.i < this.data[dpos].length; this.i++)\n            {\n                this.linePixelSize = (this.data[dpos][this.i] * this.unit);\n\n                gtx.strokeStyle = this.labels[this.i].color;\n                gtx.beginPath();\n                gtx.moveTo(this.dx, this.yline);\n\n                var lineY = this.yline - this.linePixelSize;\n                if (lineY < 0)\n                    lineY = 0;\n                gtx.lineTo(this.dx, lineY);\n                gtx.closePath();\n                gtx.stroke();\n\n                this.yline -= this.linePixelSize;\n            }\n            dpos++;\n        }\n\n    },\n\n    draw:function ()\n    {\n        this.ctx.save();\n        this.ctx.drawImage(this.bgCanvas, this.x, this.y);\n        this.renderGraph(false);\n        this.ctx.globalAlpha = 0.4;\n        this.ctx.drawImage(this.graphCanvas, this.x + this.graphX, this.y + this.graphY);\n\n        // draw the message over the top, if there is one\n        if (this.message)\n        {\n            this.ctx.font = '13px sans-serif';\n            this.ctx.fillStyle = '#333';\n            this.ctx.textAlign = 'center';\n            this.ctx.fillText(this.message, this.x + this.width / 2, this.y + this.height / 2 - 9);\n        }\n        this.ctx.restore();\n    }\n\n});\n\n",
    "/**\n * Playcraft Engine\n * System - the interface between the device (the real world) and the game\n */\n\n/**\n * @class pc.Device\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * pc.Device is the primary interface between your game and the underlying hardware. It's a singleton instance\n * that will be constructed automatically and is globally accessible at all times as pc.device\n * <p>\n * pc.device will automatically be setup once pc.JSLoader has completed loading all required javascipt through a call\n * to pc.device.boot passing in the Id of the canvas element for your game as well as the name of the game class\n * which pc.device will then dynamically construct. Typically you do not need to construct your own pc.Device, pc.start\n * will take care of it for you.\n */\npc.Device = pc.Base.extend('pc.Device',\n  { },\n  /** @lends pc.Device.prototype */\n  {\n    /** element Id of the game canvas */\n    canvasId: null,\n    /** canvas element upon which all drawing will occur */\n    canvas: null,\n    /** width of the current canvas */\n    canvasWidth: 0,\n    /** height of the current canvas */\n    canvasHeight: 0,\n    /** resource loader */\n    loader: null,\n\n    timer: null,\n    /** current 2D draw context */\n    ctx: null,\n    started: false,\n    /** current requested frame rate */\n    fps: 0,\n    /** last cycle frame rate */\n    currentFPS: 0,\n    tick: 0, // ms per cycle (just 1000/fps for convenience)\n\n    /** whether the device is running */\n    running: true,\n\n    /** global render scale */\n    scale: 1,\n    xmlParser: null,\n\n    // debug related\n    debugPanel: null,\n    /** whether the debug panel should be updated/drawn */\n    showDebug: true,\n    /** whether the game is running in development mode; false = production */\n    devMode: true,\n    enablePooling: true,\n    /** whether sound is enabled */\n    soundEnabled: true,\n\n    /** number of elements drawn in the last cycle */\n    elementsDrawn: 0,\n    /** how long in ms the last process cycle took */\n    lastProcessMS: 0,\n    /** how long in ms the last draw cycle took */\n    lastDrawMS: 0,\n\n    // device information\n    /** pc.Rect of the current screen dimensions */\n    screen: null, // the device's screen dimensions (i.e. the display)\n    /** pixel ratio of the screen -- typically 1 unless on a retina display where it's 2 */\n    pixelRatio: 1,\n    /** is this device an iPhone */\n    isiPhone: false,\n    /** is this device an iPhone 4 */\n    isiPhone4: false,\n    /** is this device an iPad*/\n    isiPad: false,\n    /** is this device an Android*/\n    isAndroid: false,\n    /** is this a touch device */\n    isTouch: false,\n    /** is this an ios device */\n    isiOS: false,\n    /** is this an iPod device */\n    isiPod: false,\n    /* is running inside cocoonjs */\n    isCocoonJS: false,\n\n    requestAnimFrame: null,\n    /** pc.Input handler global instance */\n    input: null,\n    /** the name of the game class that was constructed */\n    gameClass: null,\n    /** the game object constructed at startup */\n    game: null, // the currently running instance of the gameClass\n\n    /** amount of time the last cycle took in ms */\n    elapsed: 0,\n    /** time the last frame cycle was started */\n    lastFrame: 0,\n    /** the time now */\n    now: Date.now(),\n\n    /**\n     * Setup the system interface for the game. Typically this will just be automatically called\n     * by the game object and you don't need to worry about it.\n     */\n    boot: function (canvasId, gameClass)\n    {\n      if (this.devMode)\n        this.info('Playcraft Engine v' + pc.VERSION + ' starting');\n      this.canvasId = canvasId;\n      this.gameClass = gameClass;\n      this.fps = 60;\n      this.tick = 1000 / this.fps;\n\n      this.debugPanel = new pc.DebugPanel();\n      this.input = new pc.Input();\n      this.loader = new pc.Loader();\n      this.isAppMobi = (typeof AppMobi != \"undefined\");\n      this.isCocoonJS = navigator.isCocoonJS;\n\n      this.pixelRatio = gamecore.Device.pixelRatio;\n      this.isiPhone = gamecore.Device.isiPhone;\n      this.isiPhone4 = gamecore.Device.isiPhone4;\n      this.isiPad = gamecore.Device.isiPad;\n      this.isAndroid = gamecore.Device.isAndroid;\n      this.isTouch = gamecore.Device.isTouch;\n      this.isiOS = (this.isiPhone || this.isiPad);\n      this.device = gamecore.Device;\n\n      this.requestAnimFrame = gamecore.Device.requestAnimFrame;\n      this.requestAnimFrame = (function ()\n      {\n        var request =\n          window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame ||\n            function (callback, element)\n            {\n              window.setTimeout(callback, 1000 / 60, Date.now());\n            };\n\n        // apply to our window global to avoid illegal invocations (it's a native)\n        return function (callback, element)\n        {\n          request.apply(window, [callback, element]);\n        };\n      })();\n\n      window.onresize = this.onResize.bind(this);\n      this.onReady();\n    },\n\n    /**\n     * Indicates whether a sound format is playable on the current device\n     * @param {String} format Sound format to test: 'mp3', 'ogg' or 'wav'\n     * @return {Boolean} True is the format can be played\n     */\n    canPlay: function (format)\n    {\n      return gamecore.Device.canPlay(format);\n    },\n\n    _calcScreenSize: function ()\n    {\n      if (this.isAppMobi)\n      {\n        if (this.screen != null)\n          this.screen.release();\n\n        this.screen = pc.Dim.create(window.innerWidth, window.innerHeight);\n\n        this.canvas.width = this.screen.x;\n        this.canvas.height = this.screen.y;\n        if (!this.isCocoonJS)\n        {\n          this.canvas.innerWidth = this.screen.x;\n          this.canvas.innerHeight = this.screen.y;\n        }\n        this.canvasWidth = this.screen.x;\n        this.canvasHeight = this.screen.y;\n      } else\n      {\n        // if the game canvas is in a surrounding div, size based on that\n        if (this.isiPad || this.isiPhone || this.isCocoonJS)\n        {\n          this.canvas.width = window.innerWidth;\n          this.canvas.height = window.innerHeight;\n\n        } else\n        {\n          if (this.panelElement)\n          {\n            this.canvas.width = this.panelElement.offsetWidth;\n            this.canvas.height = this.panelElement.offsetHeight;\n          }\n        }\n\n        this.canvasWidth = this.canvas.width;\n        this.canvasHeight = this.canvas.height;\n\n        if (this.screen != null)\n          this.screen.release();\n        this.screen = pc.Dim.create(this.canvasWidth, this.canvasHeight);\n      }\n    },\n\n    /**\n     * Automatically called once the device is ready\n     */\n    onReady: function ()\n    {\n      if (this.isiOS)\n      {\n        this.showDebug = false;\n        if(!this.isCocoonJS)\n          this.soundEnabled = false;\n      }\n\n      if (this.started) return; // check we haven't already started\n      this.game = eval('new ' + this.gameClass + '()');\n      if (!this.game)\n        throw \"Invalid game class\";\n\n      if (this.isCocoonJS)\n      {\n        this.canvas = document.createElement('screencanvas');\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n      }\n      else\n      {\n        this.canvas = document.getElementById(this.canvasId);\n\n        if (!this.canvas)\n        {\n          // no canvas supplied, let's make one and fill the screen with it\n          this.canvas = document.createElement('canvas');\n//          this.canvas.width = window.innerWidth;\n//          this.canvas.height = window.innerHeight;\n        }\n      }\n\n      if (!this.canvas)\n        throw 'Abort! Could not attach to a canvas element using the id [' + this.canvasId + ']. ' +\n          'Add a canvas element to your HTML, such as <canvas id=\"pcGameCanvas\"></canvas>';\n\n      this.ctx = this.canvas.getContext('2d');\n\n      // automatically resize to match my parent container\n      this.panelElement = this.canvas.parentNode;\n      this.onResize();\n      this.info('Canvas is ' + this.screen);\n\n      // init the debug panel\n      if (this.showDebug)\n        this.debugPanel.onReady();\n\n      // start the editor\n      //if (this.editor)\n      //    this.editor.onReady();\n\n      this.lastFrame = Date.now();\n\n      // give the game a chance to do something at the start\n      // construct the game class and fire onReady\n\n      this.input._onReady();\n      this.game.onReady();\n\n      // start the central game timer\n      this.requestAnimFrame(this.cycle.bind(this));\n\n      this.started = true;\n    },\n\n    startTime: 0,\n\n    /**\n     * Called once per game cycle\n     * @param time System time in ms\n     */\n    cycle: function (time)\n    {\n      if (this.running !== false)\n      {\n        this.now = Date.now();\n        this.elapsed = this.now - this.lastFrame;\n        this.lastDrawMS = 0;\n\n        this.currentFPS = Math.round(1000.0 / this.elapsed);\n        this.elementsDrawn = 0;\n\n        this.startTime = Date.now();\n        // do not render frame when delta is too high\n        if (this.elapsed < 200)\n          this.running = this.game.process();\n        this.lastProcessMS = (Date.now() - this.startTime) - this.lastDrawMS;\n\n        // process the input system\n        pc.device.input.process();\n\n        if (this.showDebug)\n        {\n          this.debugPanel.update(this.elapsed);\n          this.debugPanel.draw(this.ctx);\n        }\n        this.lastFrame = this.now;\n        this.requestAnimFrame(this.cycle.bind(this));\n      }\n\n    },\n\n    /**\n     * Requests a resize of the canvas based on the supplied dimensions\n     * @param {Number} w Width of the canvas\n     * @param {Number} h Hight of the canvas\n     */\n    resize: function (w, h)\n    {\n      this.canvas.width = w;\n      this.canvas.height = h;\n      this.canvasWidth = this.canvas.width;\n      this.canvasHeight = this.canvas.height;\n\n      this.game.onResize(this.canvasWidth, this.canvasHeight);\n      this.debugPanel.onResize(this.canvasWidth, this.canvasHeight);\n    },\n\n    /**\n     * Called when the primary display canvas has changed size in the browser\n     */\n    onResize: function ()\n    {\n      if (this.canvas == null) return;\n\n      this._calcScreenSize();\n\n      var flip = false;\n      if (typeof window.orientation !== 'undefined' && window.orientation != 0)\n        flip = true;\n\n      if (flip)\n      {\n        // in landscape, flip things around\n//                var w = this.canvas.width;\n//                this.canvas.width = this.canvas.height;\n//                this.canvas.height = w;\n      }\n\n      this.canvasWidth = this.canvas.width;\n      this.canvasHeight = this.canvas.height;\n\n      this.game.onResize(this.canvasWidth, this.canvasHeight);\n      this.debugPanel.onResize();\n    },\n\n    /**\n     * Test whether a given rectangle overlaps any part of the device screen\n     * @param {Number} x x position of the top left of the rectangle to test\n     * @param {Number} y y position of the top left of the rectangle to test\n     * @param {Number} w width of the rectangle\n     * @param {Number} h height of the rectangle\n     * @return {Boolean} true is it's on screen\n     */\n    isOnScreen: function (x, y, w, h)\n    {\n      return pc.Math.isRectColliding(x, y, w, h, 0, 0, this.canvasWidth, this.canvasHeight);\n    },\n\n    /**\n     * Parses XML and returns an XMLDoc\n     */\n    parseXML: function (xml)\n    {\n      if (window.DOMParser)\n      {\n        // standard\n        if (!this.xmlParser)\n          this.xmlParser = new DOMParser();\n        return this.xmlParser.parseFromString(xml, \"text/xml\");\n\n      } else // ie\n      {\n        var xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n        xmlDoc.loadXML(xml);\n        return xmlDoc;\n      }\n    }\n\n  });\n\n\n// the singleton system by which we reference the device and setup events\npc.device = new pc.Device();\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.Sound\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * A sound resource can be loaded from a URI and played, including support for managing multichannel sound\n * (playing multiple sounds at once) and different formats used by different browsers.\n * <p>\n * In order to support all modern browsers, sounds need to be provided in both 'ogg' and 'mp3' formats. This is\n * becuase IE supports mp3 (but not ogg), chrome supports ogg and mp3, but safari and firefox only supports ogg. You\n * will need to create sound files into both ogg and mp3 to support all browsers.\n * <p>\n * To play a sound, you first need to load it from a URI:\n * <p><pre><code>\n * // check if sound is enabled\n * if (pc.device.soundEnabled)\n * {\n *    // add the sound to the resource loader\n *    pc.device.loader.add(\n *       // construct a new sound named shotgun, loading formats for\n *       // ogg and mp3 (shotgun.mp3 and shotgun.ogg)\n *       // and setup to play up to 5 of these sounds simultaneously\n *       new pc.Sound('shotgun', 'sounds/shotgun', ['ogg', 'mp3'], 5));\n * }\n * </code></pre>\n * <p>\n * Once you have the sound loaded you can play it:\n * <pre><code>\n * // grab the sound resource from the resource loader\n * var shotgunSound = pc.device.loader.get('shotgun').resource;\n * // play the sound (without looping)\n * shotgunSound.play(false);\n * </code></pre>\n * <p>\n * If the sound is looping, or it's a long sound you can stop it:\n * <pre><code>\n * shotgunSound.stop();\n * </code></pre>\n * You can adjust the volume of a sound:\n * <pre><code>\n * // set the volume to 50%\n * shotgunSound.setVolume(0.5);\n * </code></pre>\n * <p>\n * You can also change the starting position of sound or music using setPlayPosition:\n * <pre><code>\n * // start half way through\n * shotgunSound.setPlayPosition( shotgunSound.getDuration() / 2 );\n * </code></pre>\n */\n\npc.Sound = pc.Base.extend('pc.Sound', {},\n    /** @lends pc.Sound.prototype */\n    {\n        /** Array of the sound elements -- multichannel sound requires multiple element copies to play */\n        sounds: [],\n        /** Source URI for the sound resource */\n        src:null,\n        /** String name for the sound */\n        name: null,\n        /** Number of sounds loaded */\n        numLoaded: 0,\n        /** Whether the sound is loaded */\n        loaded:false,\n        /** Whether an error occured loading the sound */\n        errored:false,\n        /** Number of channels for the sound. No more than this number can be played at once */\n        channels:1,\n        /** Optional call back once the sound is loaded */\n        onLoadCallback:null,\n        /** Optional call back if the sound errors whilst loading */\n        onErrorCallback:null,\n\n        /**\n         * Construct a new sound, if the resource loader has already start the sound will be immediately loaded.\n         * @param {String} name Resource name (tag) you want to use\n         * @param {String} src URI for the sound\n         * @param {Number} channels Number of channels this sound can play at once\n         * @param {Function} [onLoadCallback] Function to be called once the sound has been loaded (including all channels)\n         * @param {Function} [onErrorCallback] Function to be called if the sound fails to load (on first error)\n         */\n        init:function (name, src, formats, channels, onLoadCallback, onErrorCallback)\n        {\n            this._super();\n            this.name = name;\n            this.channels = channels;\n\n            // append an extension to the src attribute that matches the format with what the device can play\n            var canplay = false;\n            for (var i=0; i < formats.length; i++)\n            {\n                if (pc.device.canPlay(formats[i]))\n                {\n                    this.src = pc.device.loader.makeUrl(src + '.' + formats[i]);\n                    canplay = true;\n                    break; // we set the src based on the first type we find (in the order they are provided)\n                }\n            }\n\n            if (canplay)\n            {\n                if (pc.device.loader.started) // load now if the loader has already been started\n                    this.load(onLoadCallback, onErrorCallback);\n            } else\n                this.errored = true;\n        },\n\n        /**\n         * Pauses the sound (on all channels)\n         */\n        pause: function()\n        {\n            if (!this.canPlay()) return;\n            for (var i=0, len=this.sounds.length; i < len; i++) {\n              var sound = this.sounds[i];\n              sound.pause();\n              if(pc.device.isCocoonJS) {\n                  sound.paused = true;\n              }\n            }\n        },\n\n        /**\n         * Stop playing a sound (on all channels) -- actually just a synonym for pause\n         */\n        stop: function()\n        {\n            if (!this.canPlay()) return;\n            this.pause();\n        },\n\n        /**\n         * Volume to play the sound at\n         * @param {Number} volume Volume as a range from 0 to 1 (0.5 is half volume)\n         */\n        setVolume: function(volume)\n        {\n            if (!this.canPlay()) return;\n            for (var i=0, len=this.sounds.length; i < len; i++)\n                this.sounds[i].volume = volume;\n        },\n\n        /**\n         * Gets the duration of the sound in seconds\n         * @return {Number} The duration in seconds\n         */\n        getDuration: function()\n        {\n            if (!this.canPlay()) return -1;\n            return this.sounds[0].duration;\n        },\n\n        /**\n         * Sets the playback rate of the sound where 0 is not playing and 2 is double speed. Negative values cause\n         * the sound to play backwards.\n         * WARNING: Only currently supported by Safari and Chrome.\n         * @param {Number} r The speed to play the sound at\n         */\n        setPlaybackRate:function (r)\n        {\n            if (!this.canPlay()) return;\n            for (var i = 0, len = this.sounds.length; i < len; i++)\n                this.sounds[i].playbackRate = r;\n        },\n\n        /**\n         * Start playing the sound at the specified time (instead of 0)\n         * @param {Number} time time (in seconds to start at)\n         */\n        setPlayPosition: function(time)\n        {\n            if (!this.canPlay()) return;\n            for (var i=0, len=this.sounds.length; i < len; i++)\n                this.sounds[i].currentTime = time;\n        },\n\n        /**\n         * Load a sound. If the game hasn't started then the sound resource\n         * will be added to the resource manager's queue.\n         * @param {Function} onLoadCallback function to call once the sound is loaded\n         * @param {Function} onLoadCallback function to call if the sound errors\n         */\n        load:function (onLoadCallback, onErrorCallback)\n        {\n            // user customized callbacks\n            this.onLoadCallback = onLoadCallback;\n            this.onErrorCallback = onErrorCallback;\n\n            if (this.loaded && onLoadCallback)\n            {\n                this.onLoadCallback(this);\n                return;\n            }\n            // load up multiple copies of the sound, one for each channel\n            for (var i=0; i < this.channels; i++)\n            {\n                var n = new Audio();\n                n.preload = 'auto';\n\n                if(pc.device.isCocoonJS) {\n                  (function(name, i, n) {\n                    n.ended = n.paused = true;\n                    n.addEventListener(\"ended\", function() {\n                      n.ended = true; });\n                  }(this.name,i,n));\n                }\n                // setup event handlers for this class -- we'll call the callbacks from there\n                n.addEventListener(\"canplaythrough\", this.onLoad.bind(this), false);\n                n.addEventListener(\"error\", this.onError.bind(this), false);\n                n.onerror = this.onError.bind(this);\n                n.onload = this.onLoad.bind(this);\n                n.src = this.src;\n                n.load();\n                this.sounds.push(n);\n\n                if (pc.device.isAppMobi)\n                    // force an onload for appmodi -- since it wont create one and the load is almost instant\n                    this.onLoad(null);\n\n            }\n        },\n\n        /**\n         * Force this sound to be reloaded\n         */\n        reload:function ()\n        {\n            this.loaded = false;\n            this.errored = false;\n            this.load();\n        },\n\n        onLoad:function (ev)\n        {\n            this.numLoaded++;\n\n            // remove the event listener so we don't get this happening multiple times\n            if (!pc.device.isAppMobi)\n                ev.target.removeEventListener(\"canplaythrough\", this.onLoad.bind(this), false);\n\n            if (this.numLoaded == this.channels)\n            {\n                this.loaded = true;\n                this.errored = false;\n                if (this.onLoadCallback)\n                    this.onLoadCallback(this);\n            }\n        },\n\n        onError:function ()\n        {\n            this.errored = true;\n            this.loaded = false;\n            if (this.onErrorCallback)\n                this.onErrorCallback(this);\n        },\n\n        /**\n         * Plays a sound\n         * @param {Boolean} loop True if you want the sound to just keep looking.\n         * @return {Object} Sound element that was played\n         */\n        play:function(loop)\n        {\n            if (!this.canPlay()) return null;\n\n            // find a free channel and play the sound (if there is one free)\n            for (var i=0, len=this.sounds.length; i < len; i++)\n            {\n                var sound = this.sounds[i];\n                if (sound.paused || sound.ended)\n                {\n                    if (loop)\n                        sound.loop = true;\n                    sound.play();\n                    if(pc.device.isCocoonJS) {\n                        sound.ended = sound.paused = false;\n                    }\n                    return sound;\n                }\n            }\n\n            // no sounds were free, so we just do nothing\n            this.warn(this.name + ' - all channels are in use');\n            return null;\n        },\n\n        /**\n         * @return {Boolean} true if the sound can be played\n         */\n        canPlay: function()\n        {\n            return (this.loaded && pc.device.soundEnabled && !this.errored);\n        }\n\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.Layer\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * A layer is a container for drawing and processing game elements. Layer's are contained with a\n * <a href='pc.Scene'>pc.Scene</a> which automatically handles calling the process and draw methods.\n * <p>\n * You can use the pc.Layer class to create your own custom layers, though typically <a href='pc.TileLayer'>\n * pc.TileLayer</a> and <a href='pc.EntityLayer'>pc.EntityLayer</a> should be used for typical game levels.\n * <p>\n * To create your own custom level, derive from pc.Level and override the draw and process methods:\n * <pre><code>\n * // construct a scene and add it to the game\n * myGameScene = new GameScene();\n *\n * // create your own layer class\n * MyLayer = pc.Layer.extend('MyLayer',\n * {},\n * {\n *    // override draw to do custom layer drawing\n *    draw:function()\n *    {\n *       // draw a rectangle\n *       pc.device.ctx.fillStyle = '#fff';\n *       pc.device.ctx.fillRect(0, 0, 10, 10);\n *    }\n *\n *    // override process to update or change things\n *    process:function()\n *    { }\n * });\n *\n * // construct the custom layer and add it to the scene\n * var myLayer = new MyLayer('Test layer', 1);\n * myGameScene.addLayer(myLayer);\n * </code></pre>\n * <h5>Pause/Resume</h5>\n * Layers can be paused/resumed, which will stop drawing and processing of a layer.\n * <pre><code>\n * myLayer.pause();\n * myLayer.resume();\n * </code></pre>\n * <h5>Z-Order Drawing</h5>\n * Layers support z-order draw sorting within their scenes. To change the z-order, either construct the layer\n * using a zIndex parameter, or call setZIndex to change the draw order layer\n * <p>\n * <h5>Origins and Parallax</h5>\n * A layer has an optional origin that can be used to use the layer as a viewport into a large world.\n * By changing the origin you can pan and move a layer. You should then use screenX() and screenY() to\n * modify where an element is drawn relative to layer's current origin offset.\n * <p>\n * <pre><code>\n * draw:function()\n * {\n *    // draw a rectangle (at world coordinate 100, 100)\n *    pc.device.ctx.fillStyle = '#fff';\n *    pc.device.ctx.fillRect(this.screenX(100), this.screenY(100), 10, 10);\n * }\n *\n * // override process to update or change things\n * process:function()\n * {\n *    // pan the origin to the right by 1 pixel every cycle\n *    this.setOrigin( this.origin.x + 1, 0);\n * }\n * </code></pre>\n * <p>\n * To center a layer around a player object set its origin to position the player at half the viewport width\n * and height. This should be done on every game update:\n * <pre><code>\n * process:function()\n * {\n *    myLayer.setOrigin(\n *       playerPos.x - (this.viewPort.w / 2),\n *       playerPos.y - (this.viewPort.h / 2));\n * }\n * </pre></code>\n * <p>\n * You can achieve parallax effects by panning one layer at a different rate to others. For example, changing\n * the origin of a background layer at a ratio to the main layer (this is most commonly done in a scene.process method):\n * <pre><code>\n * process:function()\n * {\n *    myLayer.setOrigin(\n *       playerPos.x - (this.viewPort.w / 2),\n *       playerPos.y - (this.viewPort.h / 2));\n *\n *    // pan the background at 10% of the speed of the\n *    myBackgroundLayer.setOrigin(\n *       playerPos.x - (this.viewPort.w / 2) / 10,\n *       playerPos.y - (this.viewPort.h / 2) / 10);\n * }\n * </pre></code>\n * <p>\n * When you have many layers tracking a single origin it can be a pain to keep them all up to date, so to make life easier\n * you can have a layer automatically track another layer's origin, including a ratio for parallax effects:\n * <pre><code>\n * // Automatically keep the background layer's origin relative to myLayer's\n * // at a ratio of 10:1 (slow panning)\n * myBackgroundLayer.setOriginTrack( myLayer, 10 );\n * </code></pre>\n */\n\npc.Layer = pc.Base.extend('pc.Layer', {},\n  /** @lends pc.Layer.prototype */\n  {\n    /** Name of the layer */\n    name: null,\n    /** whether the layer is presently paused */\n    paused: false,\n    /** whether the layer is active (isActive should be used over this as it also checks whether\n     * the scene is active */\n    active: false,\n    /** the scene this layer is within */\n    scene: null,\n    /** draw order of this layer, lower draws first (use setZIndex method to change in order to update the scene) */\n    zIndex: 0,\n    /** offset all drawing by this x, y amount */\n    offset: null,\n    /** current origin track -- layer's origin will automatically match the origin of another layer */\n    originTrack: null,\n    /** ratio of origin tracking on X */\n    originTrackXRatio: 1,\n    /** ratio of origin tracking on Y */\n    originTrackYRatio: 1,\n\n    /** When loading from TMX we have a layer name first, then bind to an actual layer after */\n    originTrackName: null,\n\n    /**\n     * World coordinate origin for this layer\n     */\n    origin: null,\n\n    /**\n     * @constructs pc.Layer\n     * @param {String} name Name you want to give the layer\n     * @param {Number} zIndex Draw order for this layer within it's scene (lower draws earlier)\n     */\n    init: function (name, zIndex)\n    {\n      this._super();\n\n      this.name = name;\n      this.origin = pc.Point.create(0, 0);\n      this._worldPos = pc.Point.create(0, 0);\n      this._screenPos = pc.Point.create(0, 0);\n      this.zIndex = pc.checked(zIndex, 0);\n      this.offset = pc.Point.create(0,0);\n      this.originTrack = null;\n      this.originTrackXRatio = 1;\n      this.originTrackYRatio = 1;\n    },\n\n    /**\n     * @return {String} A nice string representation of the layer\n     */\n    toString: function ()\n    {\n      return '' + this.name + ' (origin: ' + this.origin + ', zIndex: ' + this.zIndex + ')';\n    },\n\n    release: function ()\n    {\n      this.origin.release();\n    },\n\n    /**\n     * @return {Boolean} Is this layer active, and is it within a scene that is active\n     */\n    isActive: function ()\n    {\n      if (this.scene != null)\n        if (!this.scene.active) return false;\n      return this.active;\n    },\n\n    /**\n     * Make this layer active\n     */\n    setActive: function ()\n    {\n      this.scene.setLayerActive(this);\n    },\n\n    /**\n     * Make this layer inactive\n     */\n    setInactive: function ()\n    {\n      this.scene.setLayerInactive(this);\n    },\n\n    /**\n     * Change the z order drawing for this layer (lower draws earlier)\n     * @param {Number} z index as a value > 0\n     */\n    setZIndex: function (z)\n    {\n      this.zIndex = z;\n      if (this.scene)\n        this.scene.sortLayers();\n    },\n\n    _worldPos: null, // cached temp\n\n    /**\n     * Gets the world position of a screen position.\n     * @param {pc.Point} pos World position of this layer (cached, so you don't need to release it)\n     * @param {pc.Point} [returnPos] Optional return point (so you can pass in a point to be set)\n     */\n    worldPos: function (pos, returnPos)\n    {\n      if (returnPos)\n      {\n        returnPos.x = pos.x + this.origin.x - this.offset.x;\n        returnPos.y = pos.y + this.origin.y - this.offset.y;\n        return this._worldPos;\n      } else\n      {\n        this._worldPos.x = pos.x + this.origin.x - this.offset.x;\n        this._worldPos.y = pos.y + this.origin.y - this.offset.y;\n        return this._worldPos;\n      }\n    },\n\n    /**\n     * @param {Number} x X position in world co-ordinates\n     * @return {Number} X position relative to the screen (based on the layer's current origin and the viewport\n     * of the scene)\n     */\n    screenX: function (x)\n    {\n      return x + this.scene.viewPort.x - this.origin.x + this.offset.x;\n    },\n\n    /**\n     * @param {Number} y Y position in world co-ordinates\n     * @return {Number} Y position relative to the screen (based on the layer's current origin and the viewport\n     * of the scene)\n     */\n    screenY: function (y)\n    {\n      return y + this.scene.viewPort.y - this.origin.y + this.offset.y;\n    },\n\n    /**\n     * @param {Number} screenX X position relative to the screen (based on the layer's current origin and the viewport\n     * of the scene)\n     * @return {Number} X position in world co-ordinates\n     */\n    worldX: function(screenX) {\n      return screenX - (this.scene.viewPort.x - this.origin.x + this.offset.x);\n    },\n\n    /**\n     * @param {Number} screenY Y position relative to the screen (based on the layer's current origin and the viewport\n     * of the scene)\n     * @return {Number} Y position in world co-ordinates\n     */\n    worldY: function(screenY) {\n      return screenY - (this.scene.viewPort.y - this.origin.y + this.offset.y);\n    },\n\n    /**\n     * Adjust the offset for drawing the layer (think of it like the top left starting position for the layer\n     * @param x\n     * @param y\n     */\n    setOffset: function(x, y)\n    {\n      this.offset.x = x;\n      this.offset.y = y;\n    },\n\n    /**\n     * A layer uses whatever screen rectangle is defined by the scene it sits within,\n     * so this is just a helper method (and makes it compliant for things like input checking)\n     */\n    getScreenRect: function ()\n    {\n      return this.scene.getScreenRect();\n    },\n\n    /**\n     * Draw the layer's scene. Use the scene's viewport and origin members to correctly position things.\n     * Typical used for simple/custom layers with no entities or tiles.\n     */\n    draw: function ()\n    {\n    },\n\n    /**\n     * Sets tracking for this origin to always follow the origin of another layer. The ratio can be used\n     * to parallax the layer.\n     * @param {pc.Layer} trackLayer Layer to track\n     * @param {Number} [xRatio] Ratio to track horizontally (i.e. trackLayer.origin.x * xRatio)\n     * @param {Number} [yRatio] Ratio to track vertically (i.e. trackLayer.origin.y * yRatio)\n     */\n    setOriginTrack: function (trackLayer, xRatio, yRatio)\n    {\n      this.originTrack = trackLayer;\n      this.originTrackXRatio = pc.checked(xRatio, 1);\n      this.originTrackYRatio = pc.checked(yRatio, 1);\n    },\n\n    /**\n     * Sets the origin world point of the top left of this layer.\n     * @param {Number} x Set offset origin for the layer to x\n     * @param {Number} y Set offset origin for the layer to y\n     */\n    setOrigin: function (x, y)\n    {\n      var ix = Math.round(x);\n      var iy = Math.round(y);\n      if (this.origin.x == ix && this.origin.y == iy)\n        return false;\n      this.origin.x = ix;\n      this.origin.y = iy;\n      return true;\n    },\n\n    /**\n     * Process the layer (if you overide this method make sure you call this._super();\n     */\n    process: function ()\n    {\n      if (this.originTrack)\n      {\n        this.setOrigin(this.originTrack.origin.x * this.originTrackXRatio,\n          this.originTrack.origin.y * this.originTrackYRatio);\n      }\n    },\n\n    /**\n     * Pauses this layer\n     */\n    pause: function ()\n    {\n      this.paused = true;\n    },\n\n    /**\n     * Resumes all active layers\n     */\n    resume: function ()\n    {\n      this.paused = false;\n    },\n\n    /**\n     * Called when the layer changes size (triggered by a browser or device resize event)\n     * @param {Number} width New width of the underlying canvas\n     * @param {Number} height New height of the underlying canvas\n     */\n    onResize: function (width, height)\n    {\n    },\n\n    /**\n     * Notification call when this layer has been added to a scene\n     */\n    onAddedToScene: function ()\n    {\n    },\n\n    /**\n     * Notification call when this layer has been removed from a scene\n     */\n    onRemovedFromScene: function ()\n    {\n    },\n\n    /**\n     * Fired when a bound event/action is triggered in the input system. Use bindAction\n     * to set one up. Override this in your layer to do something about it.\n     * @param {String} actionName The name of the action that happened\n     * @param {Object} event Raw event object\n     * @param {pc.Point} pos Position, such as a touch input or mouse position\n     * @param {pc.Base} uiTarget the uiTarget where the action occurred\n     */\n    onAction: function (actionName, event, pos, uiTarget)\n    {\n    },\n\n    /**\n     * Parse properties from the XML, such as zIndex.\n     *\n     * @param layerXML XML Node to load properties from\n     */\n    configFromTMX:function(layerXML)\n    {\n      var info = {properties:{}};\n      var props = info.properties;\n      var pr = layerXML.getElementsByTagName('properties')[0];\n      if(pr)\n      {\n        var props = pr.getElementsByTagName('property');\n\n        for (var b = 0; b < props.length; b++)\n        {\n          var prop = props[b];\n          props[prop.getAttribute('name')] = prop.getAttribute('value');\n        }\n      }\n\n      this.configFromJson(info);\n    },\n\n    /**\n     * Configure the layer from layer custom properties in the Tiled\n     * JSON/JSONP file.\n     *\n     * @param info Layer object\n     */\n    configFromJson:function(info)\n    {\n      if('properties' in info)\n      {\n        var props = info.properties;\n        var zIndex = props.zIndex || props.zindex;\n        if(pc.valid(zIndex)) this.setZIndex(zIndex);\n\n        var trackLayer = props.tracklayer || props.trackLayer;\n        if(pc.valid(trackLayer) && trackLayer != this.name)\n          this.originTrackName = trackLayer;\n\n        var trackXRatio = props.trackxratio || props.trackXRatio || props.trackRatio || props.trackratio;\n        if(pc.valid(trackXRatio))\n          this.originTrackXRatio = trackXRatio;\n\n        var trackYRatio = props.trackyratio || props.trackYRatio || props.trackRatio || props.trackratio;\n        if(pc.valid(trackYRatio))\n          this.originTrackYRatio = trackYRatio;\n      }\n\n    }\n\n  });\n\n\n\n\n\n\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.EntityLayer\n * @description\n * [Extends <a href='pc.Layer'>pc.Layer</a>]\n * <p>\n * An entity layer is a container for <a href='pc.Entity'>entities</a> and systems.\n * See the <a href='../guides/entitysystems'>entity systems</a> guide for more information on how components,\n * entities and systems work together.\n * <p>\n * An entity layer is constructed similarly to a regular layer, except it also has a distinct 'world' size\n * which can be referenced by systems.\n * <pre><code>\n * var entityLayer = new pc.EntityLayer('my entity layer', 10000, 10000);\n * </code></pre>\n * The entity layer will automatically construct both an <a href='pc.EntityManager'>pc.EntityManager</a> and a\n * <a href='pc.SystemManager'>pc.SystemManager</a>.\n * <p>\n * Once you have an entity layer created you will need to add it to the scene:\n * <pre><code>\n * myScene.addLayer(entityLayer);\n * </code></pre>\n * You can then add entities to the layer:\n * <pre><code>\n * // create a new entity (it will automatically be added to the\n * // entity layer specified in the constructor\n * var box = pc.Entity.create(entityLayer);\n * box.addComponent( pc.components.Rect.create({ color:#ffffff }) );\n * </code></pre>\n * Entity layers are driven by systems, which must be added to the layer in order for anything to happen.\n * When you add components to an entity, you must also remember to add the corresponding system to the layer where\n * the entity exists. You can see which systems are required for components in the \"used by\" list in the component\n * API documentation.\n * <p>\n * To add a system, just construct it and call addSystem:\n * <pre><code>\n * // fire up the systems we need for the game layer\n * entityLayer.addSystem(new pc.systems.Physics());\n * entityLayer.addSystem(new pc.systems.Particles());\n * entityLayer.addSystem(new pc.systems.Effects());\n * entityLayer.addSystem(new pc.systems.Render());\n * </code></pre>\n *\n */\npc.EntityLayer = pc.Layer.extend('pc.EntityLayer',\n    /** @lends pc.EntityLayer */\n    {\n        /**\n         * Creates an entity layer from a TMX layer XML data resource\n         * @param {String} scene\n         * @param {String} groupXML\n         * @param {pc.EntityFactory} entityFactory\n         */\n        loadFromTMX:function (scene, groupXML, entityFactory, worldSizeX, worldSizeY)\n        {\n            var layerName = groupXML.getAttribute('name');\n\n            // create the new layer and add it to the scene - when you have the name\n            var n = new pc.EntityLayer(layerName, worldSizeX, worldSizeY, entityFactory);\n            n.configFromTMX(groupXML);\n            scene.addLayer(n);\n\n            // Parse object xml instances and turn them into entities\n            // XML = <object type=\"EnemyShip\" x=\"2080\" y=\"256\" width=\"32\" height=\"32\"/>\n            var objs = groupXML.getElementsByTagName('object');\n            for (var i = 0; i < objs.length; i++)\n            {\n                var objData = objs[i];\n                var entityType = objData.getAttribute('type');\n                var x = parseInt(objData.getAttribute('x'));\n                var y = parseInt(objData.getAttribute('y'));\n                var w = parseInt(objData.getAttribute('width'));\n                var h = parseInt(objData.getAttribute('height'));\n                var shape = null;\n\n                // either it's a polygon shape, or it's a rectangle (has w and h)\n                var polygon = objData.getElementsByTagName(\"polygon\");\n                if(polygon.length == 0) polygon = objData.getElementsByTagName(\"polyline\");\n                if (polygon.length > 0)\n                {\n                    var pointsString = polygon[0].getAttribute('points');\n                    var points = [];\n                    var pairs = pointsString.split(' ');\n                    for (var j = 0; j < pairs.length; j++)\n                    {\n                        var nums = pairs[j].split(',');\n                        points.push([parseInt(nums[0]), (parseInt(nums[1]))]);\n                    }\n                    shape = pc.Poly.create(x, y, points);\n                }\n                else\n                {\n                    // plain rectangle (just need the width and height)\n                    shape = pc.Dim.create(w, h);\n                }\n\n                // parse parameters into options\n                var options = {};\n                var ps = objData.getElementsByTagName(\"properties\");\n\n                if (ps.length)\n                {\n                    var props = ps[0].getElementsByTagName(\"property\");\n                    for (var p = 0; p < props.length; p++)\n                    {\n                        var name = props[p].getAttribute(\"name\");\n                        var value = props[p].getAttribute(\"value\");\n                        options[name] = value;\n                        if (name.toLowerCase() === 'entity')\n                            entityType = value;\n                    }\n                }\n\n                // create a new entity\n                // ask the entity factory to create entity of this type and on this layer\n                //\n                if (entityType)\n                    entityFactory.createEntity(n, entityType, x, y, 0, shape, options);\n                else\n                    this.warn('Entity loaded from map with no \"entity\" type property set. x=' + x + ' y=' + y)\n            }\n\n        },\n\n      /**\n       * Creates an entity layer from a Javascript object from a Tiled JSON/JSONP file\n       * @param {String} scene\n       * @param {String} info Json data for the entity layer\n       * @param {pc.EntityFactory} entityFactory\n       */\n      loadFromJson:function (scene, info, entityFactory, worldSizeX, worldSizeY)\n      {\n        var layerName = info.name;\n\n        // create the new layer and add it to the scene - when you have the name\n        var n = new pc.EntityLayer(layerName, worldSizeX, worldSizeY, entityFactory);\n        n.configFromJson(info);\n        scene.addLayer(n);\n\n        // Parse object xml instances and turn them into entities\n        // XML = <object type=\"EnemyShip\" x=\"2080\" y=\"256\" width=\"32\" height=\"32\"/>\n        var objs = info.objects;\n        for (var i = 0; i < objs.length; i++)\n        {\n          var objData = objs[i];\n          var entityType = objData.type;\n          var x = objData.x;\n          var y = objData.y;\n          var w = objData.width;\n          var h = objData.height;\n          var shape = null;\n\n          // either it's a polygon shape, or it's a rectangle (has w and h)\n          var polygon = pc.checked(objData.polygon, objData.polyline);\n          if(pc.valid(polygon))\n          {\n            shape = pc.Poly.create(x, y, polygon);\n          }\n          else\n          {\n            // plain rectangle (just need the width and height)\n            shape = pc.Dim.create(w, h);\n          }\n\n          // parse parameters into options\n          var options = objData.properties;\n\n          if('entity' in options)\n          {\n            entityType = options.entity;\n          }\n\n          // create a new entity\n          // ask the entity factory to create entity of this type and on this layer\n          //\n          if (entityType)\n            entityFactory.createEntity(n, entityType, x, y, 0, shape, options);\n          else\n            this.warn('Entity loaded from map with no \"entity\" type property set. x=' + x + ' y=' + y)\n        }\n\n      }\n\n\n    },\n    /** @lends pc.EntityLayer.prototype */\n    {\n        /** Size of the world */\n        worldSize:null,\n\n        /** Entity manager for this layer */\n        entityManager:null,\n\n        /** System manager for this layer */\n        systemManager:null,\n\n        /**\n         * @param {String} name Name of the layer\n         * @param {Number} worldSizeX X size of the world in pixels\n         * @param {Number} worldSizeY Y size of the world in pixels\n         * @param {pc.EntityFactory} entityFactory Optional factory class to use to construct entities (primarily\n         * used by level loaders to create entities specified in map files.\n         */\n        init:function (name, worldSizeX, worldSizeY, entityFactory)\n        {\n            this._super(name);\n            this.entityFactory = entityFactory;\n            this.systemManager = new pc.SystemManager(this);\n            this.entityManager = new pc.EntityManager(this);\n\n            this.worldSize = pc.Dim.create(pc.checked(worldSizeX, 10000), pc.checked(worldSizeY, 10000));\n        },\n\n        /**\n         * Sets the origin for the layer\n         * @param {Number} x x origin to set\n         * @param {Number} y y origin to set\n         * @return {Boolean} Whether the origin actually changed (was it already set to the passed in origin)\n         */\n        setOrigin:function (x, y)\n        {\n            var didChange = this._super(x, y);\n            if (didChange)\n                this.systemManager.onOriginChange(x, y);\n            return didChange;\n        },\n\n        /**\n         * Get the entity manager for this layer\n         * @return {pc.EntityManager}\n         */\n        getEntityManager:function ()\n        {\n            return this.entityManager;\n        },\n\n        /**\n         * Get the system manager for this layer\n         * @return {pc.SystemManager}\n         */\n        getSystemManager:function ()\n        {\n            return this.systemManager;\n        },\n\n        /**\n         * Add a system to the layer\n         * @param {pc.systems.System} system The system to add to the layer\n         */\n        addSystem:function (system)\n        {\n            this.systemManager.add(system, this.entityManager);\n        },\n\n        /**\n         * Gets all the systems that can handle a given component type, such as 'physics'\n         * @param {String} componentType Type of component to match\n         * @return {pc.LinkedList} Linked list of systems that match\n         */\n        getSystemsByComponentType:function (componentType)\n        {\n            return this.systemManager.getByComponentType(componentType);\n        },\n\n        /**\n         * Removes a system from this layer's system manager\n         * @param {pc.systems.System} system The system to remove\n         */\n        removeSystem:function (system)\n        {\n            this.systemManager.remove(system);\n        },\n\n        /**\n         * Master process for the layer\n         */\n        process:function ()\n        {\n            this._super();\n            this.systemManager.processAll();\n            this.entityManager.cleanup();\n        },\n\n        /**\n         * Called automatically when the viewport is changing size.\n         * @param {Number} width Width to resize to\n         * @param {Number} height Height to resize to\n         */\n        onResize:function (width, height)\n        {\n            this.systemManager.onResize(width, height);\n        }\n\n\n    });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.TileSet\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * @description\n * A set of tiles consisting of a spritesheet, types and properties map. You can use a tile set to define the types\n * of tiles you want to appear in a <a href='pc.TileMap'>tile map</a> (and thus a <a href='pc.TileLayer'>tile layer</a>).\n * <p>\n * To construct a tile set, use a spritesheet containing the tile images you want to use:\n * <pre><code>\n * var tileSet = new pc.TileSet(tileSheet);\n * </code></pre>\n * Tiles are references by number, sequentially from the top and then across the spritesheet. Each tile number\n * corresponds to one frame of the spritsheet. There is presently no support for animated tiles.\n * <p>\n * You can also set properties on tiles which can later be used to indicate special areas of a map:\n * <pre><code>\n * tileSet.addProperty(0, 'climbable', 'true');\n * </code></pre>\n * To later check if a tile has a particular property use the hasProperty method:\n * <pre><code>\n * var tileNumber = this.getTile(1, 1);\n * if (tileNumber >= 0)\n *    if (tileSet.hasProperty(tileNumber, 'climable');\n *       // climb\n * </code></pre>\n * For convenience, you should probably just use the tileHasProperty method in the <a href='pc.TileMap'>pc.TileMap</a>\n * class.\n * <pre><code>\n * tileLayer.tileMap.tileHasProperty(1, 1, 'climbable')\n * </code></pre>\n */\n\n\npc.TileSet = pc.Base.extend('pc.TileSet',\n  {},\n  /** @lends pc.TileSet.prototype */\n  {\n    /** sprite sheet used for tiles */\n    tileSpriteSheet: null,\n    /** pc.Hashmap of properties */\n    props: null,\n    drawOffsetX: 0,\n    drawOffsetY: 0,\n    /** First tile ID in this set */\n    idOffset:0,\n\n    /**\n     * Constructs a new tile set using the supplied tile sheet\n     * @param {pc.SpriteSheet} spriteSheet Sprite sheet to use for tile images\n     * @param {Number} drawOffsetX optional offset to draw tiles at\n     * @param {Number} drawOffsetY optional offset to draw tiles at\n     */\n    init: function (spriteSheet, drawOffsetX, drawOffsetY, idOffset)\n    {\n      this.tileSpriteSheet = pc.checked(spriteSheet, null);\n      if (this.tileSpriteSheet)\n      {\n        this.props = new Array(spriteSheet.totalFrames);\n        for (var i = 0; i < this.props.length; i++)\n        {\n          this.props[i] = new pc.Hashmap();\n        }\n      }\n\n      this.drawOffsetX = pc.checked(drawOffsetX, 0);\n      this.drawOffsetY = pc.checked(drawOffsetY, 0);\n      this.idOffset = pc.checked(idOffset, 0);\n    },\n\n    /**\n     * Draw a tile; typically for debugging or other strange purposes. Usually drawing is handled by the tile layer\n     * @param {Object} ctx Context to draw the tile upon\n     * @param {Number} tileNumber\n     * @param {Number} x Frame x position within the sprite sheet\n     * @param {Number} y Frame y position within the sprite sheet\n     */\n    drawTile: function (ctx, tileNumber, x, y)\n    {\n      tileNumber -= this.idOffset;\n      this.tileSpriteSheet.drawFrame(\n        ctx,\n        tileNumber % this.tileSpriteSheet.framesWide,\n        pc.Math.floor(tileNumber / this.tileSpriteSheet.framesWide),\n        x + this.drawOffsetX, y + this.drawOffsetY);\n    },\n\n    /**\n     * Adds a key/value property to a tile type\n     * @param {Number} tileNumber Tile number to add the tile to\n     * @param {String} key Key string\n     * @param {String} value Value to add\n     */\n    addProperty: function (tileNumber, key, value)\n    {\n      tileNumber -= this.idOffset;\n      this.props[tileNumber - 1].put(key, value);\n    },\n\n    /**\n     * Checks if a particular tile number (tile type) has a given property set\n     * @param {Number} tileNumber Tile number to check\n     * @param {String} key The key to test for\n     * @return {Boolean} true if the property is set\n     */\n    hasProperty: function (tileNumber, key)\n    {\n      tileNumber -= this.idOffset;\n      return this.props[tileNumber - 1].hasKey(key);\n    },\n\n    /**\n     * Gets all the properties associated with a given tile number\n     * @param {Number} tileNumber Tile number to get properties for\n     * @return {pc.Hashmap} Hashmap of the properties\n     */\n    getProperties: function (tileNumber)\n    {\n      tileNumber -= this.idOffset;\n      return this.props[tileNumber - 1];\n    },\n\n    /**\n     * Returns the width of tiles in the tile set. By default this is the tile width from the sprite sheet, but\n     * feel free to override if you want to get all funky.\n     * @return {Number} width of tiles\n     */\n    getTileWidth: function ()\n    {\n      return this.tileSpriteSheet.tileWidth;\n    },\n\n    /**\n     * Returns the height of tiles in the tile set. By default this is the tile height from the sprite sheet, but\n     * feel free to override if you want to get all funky.\n     * @return {Number} height of tiles\n     */\n    getTileHeight: function ()\n    {\n      return this.tileSpriteSheet.tileHeight;\n    }\n\n\n  });\n\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.TileMap\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * @description\n * A map of tiles using by pc.TileLayer to what to draw. See <a href='pc.TileLayer'>pc.TileLayer</a> for details\n * on using a tile map with a tile layer.\n * <p>\n * A tile map contains both a 2d array of tile data, size of each tile and the size of the map. It also links to\n * a spritesheet which contains the tile images to render.\n * <p>\n * An example tile map setup:\n * <pre><code>\n * var tileMap = new pc.TileMap([new pc.TileSet(tileSheet)], 100, 100, 32, 32);\n *\n * // set all the tiles to empty\n * tileMap.generate(0);\n *\n * // set the tile at tile position x=3, y=2 to tile number 1\n * tileMap.setTile(3, 2, 1);\n * </code></pre>\n * <p>\n * You can directly access tile data using the tiles member:\n * <pre><code>\n * tileMap.tiles[tileY][tileX] = tileType;\n * </code></pre>\n * <p>\n * If you do modify the tile map though, and you're using prerendering you will need to call prerender on the tile\n * layer so the prerendered images are updated.\n */\n\npc.TileMap = pc.Base.extend('pc.TileMap',\n  /** @lends pc.TileMap */\n  {\n    EMPTY_TILE: -1\n  },\n  /** @lends pc.TileMap.prototype */\n  {\n    /** 2d array of tile data */\n    tiles: null,\n    /** Number of tiles the map is wide */\n    tilesWide: 0,\n    /** Number of tiles the map is high */\n    tilesHigh: 0,\n    /** Width of each tile */\n    tileWidth: 0,\n    /** Height of each tile */\n    tileHeight: 0,\n    /** Current tile set */\n    tileSets: null,\n\n    /**\n     * Constructs a new tile map using the supplied dimensions and tile set\n     * @param {Array} tileSets Tile sets to use\n     * @param {Number} tilesWide Number of tiles the map is wide\n     * @param {Number} tilesHigh Number of tiles the map is high\n     * @param {Number} tileWidth Width of each tile (e.g. 32)\n     * @param {Number} tileHeight Height of each tile (e.g. 32)\n     * @param {Array} tiles An array of tile data ordered by y then x\n     */\n    init: function (tileSets, tilesWide, tilesHigh, tileWidth, tileHeight, tiles)\n    {\n      this.tiles = tiles;\n      this.tilesWide = pc.Math.round(tilesWide);\n      this.tilesHigh = pc.Math.round(tilesHigh);\n\n      if(pc.valid(tileWidth))\n        this.tileWidth = tileWidth;\n      else if(tileSets.length > 0) // Maybe they don't have any tiles (yet?)\n        this.tileWidth = tileSets[0].tileSpriteSheet.frameWidth;\n\n      if(pc.valid(tileHeight))\n        this.tileHeight = tileHeight;\n      else if(tileSets.length > 0) // Maybe they don't have any tiles (yet?)\n        this.tileHeight = tileSets[0].tileSpriteSheet.frameHeight/2;\n\n      this.tileSets = tileSets;\n    },\n\n    /**\n     * Checks against this tilemap's tileset to see if the tile at a given location has a property set\n     * @param {Number} tileX X tile location to check\n     * @param {Number} tileY Y tile location to check\n     * @param {String} property Property string to check for\n     */\n    tileHasProperty: function (tileX, tileY, property)\n    {\n      // get the number of the tile at tileX, tileY\n      var tileNumber = this.getTile(tileX, tileY);\n      if (tileNumber == this.Class.EMPTY_TILE)\n        return false;\n\n      //for(var i=0; i < this.tileSets.length; i++) {\n\n      //}\n      return this.getTileSetForTileId(tileNumber).hasProperty(tileNumber, property);\n    },\n\n    /**\n     * Generate a new tile map, optionally populating with a given tile type\n     * @param {Number} tileType Type of tile to set the map to. Leave off to leave the tile map empty\n     */\n    generate: function (tileType)\n    {\n      this.tiles = new Array(this.tilesHigh);\n      var t = pc.checked(tileType, this.Class.EMPTY_TILE);\n\n      for (var aty = 0; aty < this.tilesHigh; aty++)\n      {\n        this.tiles[aty] = new Array(this.tilesWide);\n        for (var atx = 0; atx < this.tilesWide; atx++)\n          this.tiles[aty][atx] = t;\n      }\n    },\n\n    /**\n     * Populate an area of the tile map with a given tile type\n     * @param {Number} x tile X position to start the paint\n     * @param {Number} y tile Y position to start the paint\n     * @param {Number} w How wide to paint\n     * @param {Number} h How high to paint\n     * @param {Number} tileType Type of tile to paint\n     */\n    paint: function (x, y, w, h, tileType)\n    {\n      for (var aty = y; aty < y + h; aty++)\n        for (var atx = x; atx < x + w; atx++)\n          this.tiles[aty][atx] = tileType;\n    },\n\n    /**\n     * Checks if a given tile location is within the tile map dimensions\n     * @param {Number} x Tile x\n     * @param {Number} y Tile y\n     * @return {Boolean} true if the location is on the map\n     */\n    isOnMap: function (x, y)\n    {\n      return (x >= 0 && x < this.tilesWide && y >= 0 && y < this.tilesHigh);\n    },\n\n    /**\n     * Clear a region of the tile map (setting the tiles to 0)\n     * @param {Number} tx Starting tile x\n     * @param {Number} ty Starting tile y\n     * @param {Number} tw Number of tiles wide to clear\n     * @param {Number} th Number of tiles high to clear\n     */\n    clear: function (tx, ty, tw, th)\n    {\n      this.paint(tx, ty, tw, th, this.Class.EMPTY_TILE);\n    },\n\n    /**\n     * Sets a tile at a given location\n     * @param {Number} tx Tile x\n     * @param {Number} ty Tile y\n     * @param {Number} tileType Type to set\n     */\n    setTile: function (tx, ty, tileType)\n    {\n      this.tiles[ty][tx] = tileType;\n    },\n\n    /**\n     * Get the tile type at a given tile location\n     * @param {Number} tx Tile x\n     * @param {Number} ty Tile y\n     * @return {Number} type of tile at that location or -1 if not on the map\n     */\n    getTile: function (tx, ty)\n    {\n      if (!this.isOnMap(tx, ty)) return -1;\n      return this.tiles[ty][tx];\n    },\n\n    /**\n     * True if the given x/y fit within the tilesWide/tilesHigh box of the\n     * map.\n     *\n     * @param tx Tile column to check\n     * @param ty Tile row to check\n     */\n    isValidTile: function(tx, ty) {\n      return (tx >= 0 && tx < this.tilesWide &&\n              ty >= 0 && ty < this.tilesHigh);\n    },\n\n    /**\n     * Given a tile id, locate the tile set it should be in.  For tile ID's that are out of range (too high)\n     * this should return the last tile set in the list.\n     *\n     * The tile set to use is the last tile set whose start offset is less than or equal to the given\n     * tile id.\n     *\n     * This assumes the tileSets list is not empty.\n     *\n     * @param tileId Tile ID we are looking for\n     */\n    getTileSetForTileId: function(tileId)\n    {\n      var i;\n      for(i=1; i < this.tileSets.length; i++)\n      {\n        var tileSet = this.tileSets[i];\n        if(tileSet.idOffset >= tileId) {\n          break;\n        }\n      }\n      return this.tileSets[i-1];\n    },\n\n    /**\n     * Draw a given tile from the tile map, at a given screen position\n     * @param tileX Tile x to draw (within the tile map)\n     * @param tileY Tile y to draw (within the tile map)\n     * @param x Screen X to draw the tile at\n     * @param y Screen Y to draw the tile at\n     */\n    drawTile: function (tileX, tileY, x, y)\n    {\n      this.drawTileByIdTo(pc.device.ctx, tileX, tileY, x, y);\n    },\n\n    /**\n     * Draw a tile, given by id, using the given graphics context.\n     *\n     * Used for pre-rendering tiles, mainly.\n     *\n     * @param ctx Rendering context to draw with\n     * @param tileX Tile x to draw (within the tile map)\n     * @param tileY Tile y to draw (within the tile map)\n     * @param x X position to draw to\n     * @param y Y position to draw to\n     */\n    drawTileTo: function(ctx, tileX, tileY, x, y)\n    {\n      var tileId = this.tiles[tileY][tileX];\n      if(tileId != this.Class.EMPTY_TILE) {\n        var tileSet = this.getTileSetForTileId(tileId);\n        tileSet.drawTile(ctx, tileId, x, y);\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    /**\n     * Loads a tile map from a TMX formatted data stream\n     * @param {String} layerXML XML string loaded from a Tiled TMX file\n     * @param tileHeight\n     * @param tileWidth\n     */\n    loadFromTMX: function (layerXML, tileWidth, tileHeight)\n    {\n      this.tileWidth = tileWidth;\n      this.tileHeight = tileHeight;\n\n      this.tilesWide = parseInt(layerXML.getAttribute('width'));\n      this.tilesHigh = parseInt(layerXML.getAttribute('height'));\n\n      var data = layerXML.getElementsByTagName('data')[0];\n      if (data.getAttribute('compression'))\n      {\n        this.error('map: ' + name + ': TMX map compression not supported, use base64 (uncompressed)');\n        return;\n      }\n\n      this.tiles = new Array(this.tilesHigh);\n      if (data.getAttribute('encoding') == 'base64')\n      {\n        // convert the base64 data to tiles\n        var tileData = '';\n        for (var n = 0; n < data.childNodes.length; n++)\n          tileData += data.childNodes[n].nodeValue;\n\n        // trim\n        tileData = tileData.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n        var decoded = pc.Base64.decode(tileData);\n\n        // decode as an array\n        var row = null;\n        var atx = 0;\n        var aty = 0;\n        for (var i = 0; i < decoded.length / 4; i++)\n        {\n          var b = 0;\n          for (var j = 3; j >= 0; --j)\n            b += decoded.charCodeAt((i * 4) + j) << (j << 3);\n          if(atx == 0)\n            this.tiles[aty] = row = new Array(this.tilesWide);\n          row[atx] = b-1; // TMX uses zero for \"no tile\", playcraft uses -1\n          atx++;\n          if(atx == this.tilesWide)\n          {\n            atx = 0;\n            aty++;\n          }\n        }\n      }\n    },\n\n    /**\n     * Loads a tile map from a Tiled formatted javascript object\n     * @param {String} info Object loaded from Tiled JSON file\n     * @param tileHeight Width of each tile (pixels)\n     * @param tileWidth Height of each tile (pixels)\n     */\n    loadFromJson: function (info, tileWidth, tileHeight)\n    {\n      this.tileWidth = tileWidth;\n      this.tileHeight = tileHeight;\n\n      this.tilesWide = info.width;\n      this.tilesHigh = info.height;\n\n      this.tiles = new Array(this.tilesHigh);\n\n      // decode as an array\n      info.data.forEach(function(tileId, i) {\n        var atx = i % this.tilesWide;\n        var aty = Math.floor(i / this.tilesWide);\n        if(atx==0)\n          this.tiles[aty] = row = new Array(this.tilesWide);\n        row[atx] = tileId-1; // TMX uses zero for \"no tile\", playcraft uses -1\n      }, this)\n    }\n\n\n\n  });\n\n\n\n\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.TileLayer\n * @description\n * [Extends <a href='pc.Layer'>pc.Layer</a>]\n * <p>\n * A tile layer is a specialized layer capable of managing and rendering large graphics layers using tiles of a\n * set dimension. Tile layers are more efficient to edit, update and render due to the set size of each tile.\n * <p>\n * To create a tile layer, first create a <a href='pc.TileMap'>tile map</a> containing the tile images and map data:\n * <pre><code>\n * // grab a tile sheet previously added to the resource loader\n * var tileSheet = new pc.SpriteSheet(\n *    { image:pc.device.loader.get('myTiles').resource,\n *      frameWidth:32, frameHeight:32 });\n *\n * // create a tile map to hold our tile data, using the supplied tile sheet\n * // 100 tiles wide by 100 tiles high with a tile height and width of 32\n * var tileMap = new pc.TileMap([new pc.TileSet(tileSheet)], 100, 100, 32, 32);\n *\n * // set all the tiles to empty\n * tileMap.generate(0);\n *\n * // set the tile at tile position x=3, y=2 to tile number 1\n * tileMap.setTile(3, 2, 1);\n *\n * // create the tile layer using the supplied tile map\n * var myTileLayer = new pc.TileLayer('my tile layer', true, tileMap);\n * </code></pre>\n * <p>\n * Refer to <a href='pc.TileMap'>pc.TileMap</a> and <a href='pc.TileSet'>pc.TileSet</a> for more information on tile\n * graphics and maps.\n * <p>\n * <h5>Tiled Editor Integration</h5>\n * You can dynamically construct a tile layer using XML data from the Tiled map editor using the static loadFromTMX\n * constructor. Typically this is not used directly; you should use the pc.Scene loadFromTMX method for more information\n * on loading levels using Tiled.\n * <p>\n * <h5>Prerendering</h5>\n * By default, tile layers will use prerendering in order to \"prebake\" large blocks of tiles into cached images.\n * These images are then drawn instead of the individual tiles. This results in a large performance boost (5x to 10x) in\n * rendering speed. Prerendering is enabled by default.\n * <p>\n * There are some cases where prerendering may not be the best option, these include:\n * <ul>\n *     <li>When tile maps are regularly changing during a game - you will need to constantly re-render the tile blocks\n *     which is a slow process (relative to just drawing the tiles on each update)</li>\n *     <li>If the size of tiles is greater than 256x256 you may find only a minor speed difference (at the expense\n *     of graphics memory). Prerendering is disabled by default if you specify a tile map with a tile size greater\n *     than 256x256.</li>\n * </ul>\n * <p>\n * You can disable prerendering using the constructor option:\n * <pre><code>\n * // false indicates prerendering should not be used\n * var myTileLayer = new pc.TileLayer('my tile layer', false);\n * </code></pre>\n * <p>\n * If you change the tile map, you can use the prerender method to update the cache images.\n */\n\npc.TileLayer = pc.Layer.extend('pc.TileLayer',\n    /** @lends pc.TileLayer */\n    {\n        /**\n         * Constructs a tile layer using data from a TMX formatted (XML base 64) data stream\n         * @param {pc.Scene} scene Scene to add the new layer to\n         * @param {String} layerXML XML data for layer\n         * @param {Number} tileWidth Width of each tile\n         * @param tileHeight Height of each tile\n         */\n        loadFromTMX:function (scene, layerXML, tileWidth, tileHeight, tileSets)\n        {\n            var name = layerXML.getAttribute('name');\n            var newLayer = new pc.TileLayer(name, true, null, tileSets);\n\n            // fill in the rest using the data from the TMX file\n\n            newLayer.configFromTMX(layerXML);\n            newLayer.tileMap.loadFromTMX(layerXML, tileWidth, tileHeight);\n            scene.addLayer(newLayer);\n        },\n\n      /**\n       * Constructs a tile layer using data from a TMX formatted (XML base 64) data stream\n       * @param {pc.Scene} scene Scene to add the new layer to\n       * @param {String} info Data for layer as a javascript object\n       * @param {Number} tileWidth Width of each tile\n       * @param tileHeight Height of each tile\n       */\n      loadFromJson:function (scene, info, tileWidth, tileHeight, tileSets)\n      {\n        var name = info.name;\n        var newLayer = new pc.TileLayer(name, true, null, tileSets);\n\n        // fill in the rest using the data from the TMX file\n\n        newLayer.configFromJson(info);\n        newLayer.tileMap.loadFromJson(info, tileWidth, tileHeight);\n        scene.addLayer(newLayer);\n      }\n\n    },\n    /** @lends pc.TileLayer.prototype */\n    {\n        /** pc.TileMap data used for this tile layer */\n        tileMap:null,\n        /** show a debugging grid around all the tiles */\n        debugShowGrid:false,\n        /** array of prerendered images */\n        prerenders:null,\n        /** indicates if prerendering is currently in use */\n        usePrerendering:true,\n        /** the size of the prerender chunks - default is 512 */\n        prerenderSize:512,\n\n        /**\n         * Constructor for the tile layer\n         * @param {String} name Name of the layer\n         * @param {Boolean} [usePrerendering] Whether prerendering should be used (defaults to true)\n         * @param {pc.TileMap} [tileMap] Tile map data used for the tile layer\n         * @param {pc.TileSet} [tileSet] If no tile map is supplied, you can optional provide a tile set and a\n         * tile map will be constructed using this tile set\n         */\n        init:function (name, usePrerendering, tileMap, tileSets)\n        {\n            this._super(name);\n            if (pc.valid(tileMap))\n                this.tileMap = tileMap;\n            else\n                this.tileMap = new pc.TileMap(tileSets);\n\n            this.usePrerendering = pc.checked(usePrerendering, true);\n            if (this.tileMap && this.tileMap.tileWidth > 256)\n                this.usePrerendering = false;\n        },\n\n        /**\n         * Set the tile map\n         * @param {pc.TileMap} tileMap The tile map to set\n         */\n        setTileMap:function (tileMap)\n        {\n            this.tileMap = tileMap;\n            if (this.usePrerendering)\n                this.prerender();\n        },\n\n        /**\n         * Prerender using the current tilemap and tileset. Called automatically when a tile map is changed or when\n         * the tile layer is constructed. Only needs to be called again if you change the tile map or tile set.\n         */\n        prerender:function ()\n        {\n            var totalWidth = this.tileMap.tilesWide * this.tileMap.tileWidth;\n            var totalHeight = this.tileMap.tilesHigh * this.tileMap.tileHeight;\n\n            var prerendersWide = Math.ceil(totalWidth / this.prerenderSize);\n            var rows = Math.ceil(totalHeight / this.prerenderSize);\n\n            this.prerenders = [];\n            for (var cy = 0; cy < rows; cy++)\n            {\n                this.prerenders[cy] = [];\n\n                for (var cx = 0; cx < prerendersWide; cx++)\n                {\n                    var prw = (x == prerendersWide - 1) ? totalWidth - x * this.prerenderSize : this.prerenderSize;\n                    var prh = (y == rows - 1) ? totalHeight - y * this.prerenderSize : this.prerenderSize;\n\n                    // draw the tiles in this prerender area\n                    var tw = prw / this.tileMap.tileWidth + 1;\n                    var th = prh / this.tileMap.tileHeight + 1;\n\n                    var nx = (cx * this.prerenderSize) % this.tileMap.tileWidth,\n                        ny = (cy * this.prerenderSize) % this.tileMap.tileHeight;\n\n                    var tx = Math.floor(cx * this.prerenderSize / this.tileMap.tileWidth),\n                        ty = Math.floor(cy * this.prerenderSize / this.tileMap.tileHeight);\n\n                    var canvas = document.createElement('canvas');\n                    canvas.width = prw;\n                    canvas.height = prh;\n                    var ctx = canvas.getContext('2d');\n                    var empty = true;\n                    for (var x = 0; x < tw; x++)\n                    {\n                        for (var y = 0; y < th; y++)\n                        {\n                            if (x + tx < this.tileMap.tilesWide && y + ty < this.tileMap.tilesHigh)\n                            {\n                                  if(this.tileMap.drawTileTo(\n                                      ctx,\n                                      x + tx, y + ty,\n                                      (x * this.tileMap.tileWidth) - nx,\n                                      (y * this.tileMap.tileHeight) - ny))\n                                    empty = false;\n                            }\n                        }\n                    }\n\n                    if(empty) canvas = null;\n                    this.prerenders[cy][cx] = canvas;\n                }\n            }\n        },\n\n        /**\n         * Draws the tile layer to the current context (typically called automatically by the scene)\n         */\n        draw:function ()\n        {\n            this._super();\n            if (!this.tileMap || !this.tileMap.tilesWide) return;\n\n            if (this.usePrerendering)\n                this.drawPrerendered();\n            else\n                this.drawTiled();\n        },\n\n        /**\n         * Draws the tiled version of the layer (called automatically by a call to draw if prerendering is not used)\n         */\n        drawTiled:function ()\n        {\n            // figure out which tiles are on screen\n            var tx = Math.floor(this.origin.x / this.tileMap.tileWidth);\n            if (tx < 0) tx = 0;\n            var ty = Math.floor(this.origin.y / this.tileMap.tileHeight);\n            if (ty < 0) ty = 0;\n\n            var tw = (Math.ceil((this.origin.x + this.scene.viewPort.w) / this.tileMap.tileWidth) - tx) + 2;\n            if (tx + tw >= this.tileMap.tilesWide - 1) tw = this.tileMap.tilesWide - 1 - tx;\n            var th = (Math.ceil((this.origin.y + this.scene.viewPort.h) / this.tileMap.tileHeight) - ty) + 2;\n            if (ty + th >= this.tileMap.tilesHigh - 1) th = this.tileMap.tilesHigh - 1 - ty;\n\n            for (var y = ty, c = ty + th; y < c + 1; y++)\n            {\n                var ypos = this.screenY(y * this.tileMap.tileHeight);\n\n                for (var x = tx, d = tx + tw; x < d; x++)\n                {\n                    this.tileMap.drawTileTo(\n                        pc.device.ctx, x, y,\n                        this.screenX(x * this.tileMap.tileWidth), ypos);\n\n                    if (this.debugShowGrid)\n                    {\n                        pc.device.ctx.save();\n                        pc.device.ctx.strokeStyle = '#222222';\n                        pc.device.ctx.strokeRect(this.screenX(x * this.tileMap.tileWidth), this.screenY(y * this.tileMap.tileHeight),\n                            this.tileMap.tileWidth, this.tileMap.tileHeight);\n                        pc.device.ctx.restore();\n                    }\n                }\n            }\n        },\n\n        /**\n         * Draws the prerendered version of the layer (called automatically by a call to draw if prerendering is used)\n         */\n        drawPrerendered:function ()\n        {\n            if (!this.prerenders)\n                this.prerender();\n\n            var drawX = -(this.origin.x) + this.scene.viewPort.x;\n            var drawY = -(this.origin.y) + this.scene.viewPort.y;\n            var startPX = Math.max(Math.floor(this.origin.x / this.prerenderSize), 0);\n            var startPY = Math.max(Math.floor(this.origin.y / this.prerenderSize), 0);\n            var maxPX = startPX + Math.ceil((this.origin.x + this.scene.viewPort.w) / this.prerenderSize);\n            var maxPY = startPY + Math.ceil((this.origin.y + this.scene.viewPort.h) / this.prerenderSize);\n\n            maxPX = Math.min(maxPX, this.prerenders[0].length);\n            maxPY = Math.min(maxPY, this.prerenders.length);\n\n            for (var cy = startPY; cy < maxPY; cy++)\n            {\n                for (var cx = startPX; cx < maxPX; cx++)\n                {\n                   var prerender = this.prerenders[cy % this.prerenders.length][cx % this.prerenders[0].length];\n                   if(prerender)\n                      pc.device.ctx.drawImage(prerender,\n                          drawX + (cx * this.prerenderSize), drawY + (cy * this.prerenderSize));\n                }\n            }\n        }\n\n\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.Entity\n * @description\n * [Extends <a href='pc.Pooled'>pc.Pooled</a>]\n * <p>\n * Entities are the primary 'things' that are in a game. They serve as the primary container for components.\n * <p>\n * To add an entity to a game you must place it within an <a href='pc.EntityLayer'>entity layer</a>.\n * <p>\n * <pre><code>\n * var entityLayer = new pc.EntityLayer('my entity layer', 10000, 10000);\n * </code></pre>\n * <p>\n * You can then construct an entity by allocating it from the entity pool, and assigning it to the layer:\n * <pre><code>\n * var newEntity = pc.Entity.create(entityLayer);\n * </code></pre>\n * <h5>Components</h5>\n * To add functionality to the entity, you need to add components. Components are discreet bits of functionality\n * you can use across many entities. A spaceship for example, might have a sprite component for the artwork, a spatial\n * component (where it is in the world), an input handling component and a physics component. All of these components\n * combine together let you create an awesome flying menace.\n * <p>\n * For example, to create a simple entity that consists of a red box, we add two components, one for the spatial (its\n * position and dimensions), and one to indicate we want to draw a rectangle.\n * <pre><code>\n * // add a spatial component\n * box.addComponent( pc.components.Spatial.create({ x:100, y: 100, w:50, h:50 }) );\n *\n * // add a red rectangle\n * box.addComponent( pc.components.Rect.create({ color:'#ff2222' }) );\n * </code></pre>\n * <h5>Tagging</h5>\n * Entities can be tagged and searched for. You can add multiple tags to a single entity to categorize it in different\n * ways. Tags are the primary way you should 'type' an entity - as opposed to using a class hierarchy.\n * <p>\n * To add a tag an entity use:\n * <pre><code>\n * entity.addTag('enemy');\n * entity.addTag('monster');\n * </code></pre>\n * You can then grab all entities in a layer that have a tag:\n * <pre><code>\n * entityLayer.entityManager.getTagged('enemy'); // return a pc.LinkedList\n * </code></pre>\n * You can remove a tag:\n * <pre><code>\n * entity.removeTag('monster');\n * </code></pre>\n * And quickly test if an entity has a tag:\n * <pre><code>\n * entity.hasTag('enemy') == true;\n * </code></pre>\n * And finally, you can inspect all the tags an entity has by looking at the tags member:\n * <pre><code>\n * entity.tags[0] === 'enemy';\n * </code></pre>\n */\n\npc.Entity = pc.Pooled.extend('pc.Entity',\n    /** @lends pc.Entity */\n    {\n        /**\n         * Constructs an entity by acquiring it from the object pool\n         * @param {pc.Layer} layer Layer the entity should be added to\n         * @return {pc.Entity} A pc.Entity\n         */\n        create: function(layer)\n        {\n            var n = this._super();\n            if (!layer) throw 'Entity requires a valid layer to be placed on';\n            if (!layer.Class.isA) throw 'Entity requires a valid layer to be placed on';\n            if (!layer.Class.isA('pc.EntityLayer')) throw 'Entities can only be placed on pc.EntityLayer objects';\n            n.config(layer);\n            return n;\n        }\n    },\n    /** @lends pc.Entity.prototype */\n    {\n        /** layer this entity is on */\n        layer: null,\n        /** array of strings representing the tags this entity has (read-only) */\n        tags: [],\n        /** whether this entity is presently active (read-only) */\n        active: true,\n\n        _componentCache: null,  // cache of components for entity -- not to be used for anything but speed reading\n\n        /**\n         * Constructs a new entity by acquiring it from the object pool\n         * @param {pc.Layer} layer Layer the entity should be added to\n         */\n        init: function(layer)\n        {\n            this._super();\n            this.tags = [];\n            this.layer = null;\n            this.active = true;\n            this._componentCache = new pc.Hashmap();\n            if (pc.valid(layer))\n                this.config(layer);\n        },\n\n        /**\n         * Configures an entity with the given layer (typically this is called by create or init and does not\n         * need to be called directly.\n         * @param {pc.EntityLayer} layer Layer to add the entity too\n         */\n        config: function(layer)\n        {\n            this.layer = layer;\n            this.active = true;\n            layer.entityManager.add(this);\n        },\n\n        /**\n         * Releases the entity back into the object pool. Should not be used directly unless you know what you're\n         * doing. Use entity.remove for most sitations.\n         */\n        release: function()\n        {\n            this.tags.length = 0;\n            this.active = false;\n            this._componentCache.clear();\n            this._super();\n        },\n\n        /**\n         * Add a tag to the entity - actually just a pass through function to entity.layer.entityManager.addTag\n         * @param {String} tag Tag to add to the entity.\n         */\n        addTag: function(tag)\n        {\n            this.layer.entityManager.addTag(this, tag);\n        },\n\n        /**\n         * Tests if this entity has a given tag\n         * @param {String} tag The tag to look for\n         * @return {Boolean} true if the tag exists on this entity\n         */\n        hasTag: function(tag)\n        {\n            for (var i=0; i < this.tags.length; i++)\n                if (this.tags[i].toLowerCase() === tag.toLowerCase()) return true;\n            return false;\n        },\n\n        /**\n         * Removes a tag from an entity\n         * @param {String} tag Tag to remove\n         */\n        removeTag: function(tag)\n        {\n            this.layer.entityManager.removeTag(this, tag);\n        },\n\n        /**\n         * Add a component to this entity\n         * @param {pc.components.Component} component Component to add\n         * @return {pc.components.Component} Component that was added\n         */\n        addComponent: function(component)\n        {\n            return this.layer.entityManager.addComponent(this, component);\n        },\n\n        /**\n         * Remove a component from the entity\n         * @param {pc.components.Component} component Component to remove\n         */\n        removeComponent: function(component)\n        {\n            this.layer.entityManager.removeComponent(this, component);\n        },\n\n        /**\n         * Remove the component of a given type\n         * @param {String} componentType Component type to remove (e.g. 'physics')\n         */\n        removeComponentByType: function(componentType)\n        {\n            this.removeComponent(this._componentCache.get(componentType.toLowerCase()));\n        },\n\n        /**\n         * Retrieves a reference to a component on the entity using a given type\n         * @param {String} componentType Type string of the component to get\n         * @return {pc.components.Component} The component matching the type\n         */\n        getComponent: function(componentType)\n        {\n            return this._componentCache.get(componentType.toLowerCase());\n        },\n\n        /**\n         * Get the components in this entity\n         * @return {pc.Hashtable} A hashtable of component objects keyed by component type\n         */\n        getAllComponents: function()\n        {\n            // use internal cache for speed\n            return this._componentCache;\n            //return this.layer.entityManager.getComponents(this);\n        },\n\n        /**\n         * Get an array containing strings of all the types of components on this entity\n         * @return {Array} Array of strings with all the component types\n         */\n        getComponentTypes: function()\n        {\n            // todo: could optimize this if required by caching the types as well (instead of generating\n            // an array on every check. Don't think it's used very often though.\n            return this._componentCache.keys();\n        },\n\n        /**\n         * Check whether the entity has a component of a given type\n         * @param {String} componentType Component type to check for\n         * @return {Boolean} true if a component with the given type is on the entity\n         */\n        hasComponentOfType: function(componentType)\n        {\n            return this._componentCache.hasKey(componentType.toLowerCase());\n            //return this.layer.entityManager.hasComponentOfType(this, componentType);\n        },\n\n        /**\n         * Remove this entity from the layer\n         */\n        remove: function()\n        {\n            this.layer.entityManager.remove(this);\n        },\n\n        // INTERNALS\n        _handleComponentRemoved: function(component)\n        {\n            this._componentCache.remove(component.getType());\n        },\n\n        _handleComponentAdded: function(component)\n        {\n            this._componentCache.put(component.getType(), component);\n        }\n\n\n\n    });\n\n\n/**\n * EntityFactory -- for creating entities (mostly just an interface class you extend from to create an entity factory).\n */\npc.EntityFactory = pc.Base.extend('pc.EntityFactory',\n    { },\n    {\n        /**\n         * Called by the entity loader\n         * @param {pc.Layer} layer Layer the entity should be placed on\n         * @param {String} type String type of the entity to create\n         * @param {Number} x X position\n         * @param {Number} y Y position\n         * @param {Number} dir Facing angle\n         * @param {Object} shape Collision shape (either pc.Dim for rectangle or pc.Poly for polygons)\n         * @param {Object} options Properties assigned to the entity\n         */\n        createEntity:function (layer, type, x, y, dir, shape, options)\n        { }\n    });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.Sprite\n * @description\n * [Extends <a href='pc.Sprite'>pc.Pooled</a>]\n * <p>\n * Sprites are instances of a sprite sheet used for rendering.\n * <p>\n * To create a sprite, pass a sprite sheet into the constructor:\n * <pre><code>\n * var zombieSprite = new pc.Sprite( zombieSpriteSheet );\n * </code></pre>\n * You can then use setAnimation to select an animation from the sheet:\n * <pre><code>\n * zombieSprite.setAnimation('attacking right');\n * </code></pre>\n * To draw the sprite, use the draw method:\n * <pre><code>\n * zombieSprite.draw(pc.device.ctx, 100, 100);\n * </code></pre>\n * To cycle animations, call update:\n * <pre><code>\n * zombieSprite.update(pc.device.elapsed);\n * </code></pre>\n * <p>\n * Check the <a href='http://playcraftlabs.com/develop/guide/spritesandanimation'>sprites and animation guide</a> for\n * more information and features.\n */\n\npc.Sprite = pc.Pooled.extend('pc.Sprite',\n    /** @lends pc.Sprite */\n    {\n        /**\n         * Construct a new sprite object by acquiring it from the free pool and configuring it\n         * @param {pc.SpriteSheet} spriteSheet Sprite sheet to use\n         * @return {pc.Sprite} A sprite object\n         */\n        create:function (spriteSheet)\n        {\n            var n = this._super();\n            n.config(spriteSheet);\n            return n;\n        }\n    },\n    /** @lends pc.Sprite.prototype */\n    {\n        /** Current animation frame */\n        currentFrame:0,\n        /** Current animation object reference */\n        currentAnim:null,\n        /** pc.SpriteSheet used by this sprite */\n        spriteSheet:null,\n        /** speed different this instance uses, versus the animation speed */\n        animSpeedOffset:0,\n        /** Name of the current animation */\n        currentAnimName:null,\n        /** Alpha level */\n        alpha:1,\n        /** X-scale for drawing */\n        scaleX: 1,\n        /** Y-scale for drawing */\n        scaleY: 1,\n        /** Whether the sprite is active; false = not drawn or updated */\n        active:true,\n        /** Whether the sprite is held. Won't progress on animation, but will still draw */\n        hold: false,\n        /** Number of times the animation has played */\n        loopCount:0,\n        /** Current composite drawing operation to use */\n        compositeOperation: null,\n\n        _acDelta: 0,\n\n        /**\n         * Constructs a new sprite using the sprite sheet\n         * @param {pc.SpriteSheet} spriteSheet Spritesheet to use\n         */\n        init:function(spriteSheet)\n        {\n            this._super();\n            this.config(spriteSheet);\n        },\n\n        /**\n         * Configure the sprite object with a given sprite sheet - typically called by init or create\n         * @param {pc.SpriteSheet} spriteSheet Spritesheet to configure with\n         */\n        config: function(spriteSheet)\n        {\n            this.spriteSheet = pc.checked(spriteSheet, null);\n            if (this.spriteSheet)\n                this.reset();\n        },\n\n        /**\n         * Clear the sprite back to a starting state (using first animation)\n         */\n        reset:function ()\n        {\n            this.currentFrame = 0;\n            this.alpha = 1;\n            this.loopCount = 0;\n            this.scaleX = 1;\n            this.scaleY = 1;\n            this.active = true;\n            this.hold = false;\n            if (this.spriteSheet.animations.size() > 0)\n            {\n                this.currentAnim = this.spriteSheet.animations.get(this.spriteSheet.animations.keys()[0]);\n                this.currentFrame = 0;\n\n            } else\n                this.currentAnim = null;\n        },\n\n        /**\n         * Change the sprite sheet\n         * @param {pc.SpriteSheet} spriteSheet Sprite sheet to change to\n         */\n        setSpriteSheet: function(spriteSheet)\n        {\n            this.spriteSheet = spriteSheet;\n            this.reset();\n        },\n\n        /**\n         * Change the drawing scale of this sprite instance\n         * @param {Number} scaleX x-scale to use\n         * @param {Number} scaleY y-scale to use\n         */\n        setScale: function(scaleX, scaleY)\n        {\n            this.scaleX = scaleX;\n            this.scaleY = scaleY;\n        },\n\n        /**\n         * Sets the composite drawing operation for this sprite. Set to null to clear it back to the default.\n         * @param {String} o Composite drawing operation to use\n         */\n        setCompositeOperation: function(o)\n        {\n            this.compositeOperation = o;\n        },\n\n        /**\n         * Draw the sprite using the given context at a given location, and a certain direction\n         * @param {Context} ctx Context to draw the sprite image on\n         * @param {Number} x x-position\n         * @param {Number} y y-position\n         * @param {Number} dir Direction to draw it at\n         */\n        draw:function (ctx, x, y, dir)\n        {\n            if (this.alpha != 1)\n                this.spriteSheet.alpha = this.alpha;\n            if (this.compositeOperation != null)\n                this.spriteSheet.setCompositeOperation(this.compositeOperation);\n            if (this.scaleX != 1 || this.scaleY != 1)\n                this.spriteSheet.setScale(this.scaleX, this.scaleY);\n            this.spriteSheet.draw(ctx, this, x, y, dir);\n            if (this.scaleX != 1 || this.scaleY != 1)\n                this.spriteSheet.setScale(1, 1);\n            if (this.alpha != 1)\n                this.spriteSheet.alpha = 1;\n            if (this.compositeOperation != null)\n                this.spriteSheet.setCompositeOperation('source-over');\n        },\n\n        /**\n         * Draws a single frame of the current sprite sheet\n         * @param {Context} ctx Context to draw the sprite image on\n         * @param {Number} frameX The frame to draw (x)\n         * @param {Number} frameY The frame to draw (y)\n         * @param {Number} x x-position\n         * @param {Number} y y-position\n         * @param {Number} angle Direction to draw it at\n         */\n        drawFrame: function(ctx, frameX, frameY, x, y, angle)\n        {\n            if (this.alpha != 1)\n                this.spriteSheet.alpha = this.alpha;\n            if (this.scaleX != 1 || this.scaleY != 1)\n                this.spriteSheet.setScale(this.scaleX, this.scaleY);\n            if (this.compositeOperation != null)\n                this.spriteSheet.setCompositeOperation(this.compositeOperation);\n            this.spriteSheet.drawFrame(ctx, frameX, frameY, x, y, angle);\n            if (this.scaleX != 1 || this.scaleY != 1)\n                this.spriteSheet.setScale(1, 1);\n            if (this.alpha != 1)\n                this.spriteSheet.alpha = 1;\n            if (this.compositeOperation != null)\n                this.spriteSheet.setCompositeOperation('source-over');\n        },\n\n        /**\n         * Updates the sprite animation based on the time elapsed\n         * @param {Number} elapsed Amount of time to move the animation forward by\n         */\n        update:function (elapsed)\n        {\n            if (this.currentAnim == null || !this.active || this.hold) return;\n\n            // call the spritesheet class to actually do a sprite update, keep in mind though that the spritesheet\n            // doesn't retain any present state, it just sets the state object, which in this case is passed in as the\n            // this param -- this is so spritesheets (and the underlying image) may be used by more than one sprite\n            // at the same time\n            this.spriteSheet.update(this, elapsed);\n        },\n\n        /**\n         * Change this sprites animation. Animation frames always start from 0 again.\n         * @param {String} name Key name of the animation to switch to.\n         * @param {Number} speedOffset allows you to modify the animation speed for this instance of a sprite\n         * @param {Number} force Restart the animation, even if this is the currently playing animation (default is true)\n         */\n        setAnimation:function (name, speedOffset, force)\n        {\n            var f = pc.checked(force, true);\n            if (!f)\n                if (this.currentAnim && this.currentAnim.name === name) return;\n\n            this.currentAnim = this.spriteSheet.animations.get(name);\n            this.currentFrame = 0;\n            this.loopCount = 0;\n            this.active = true;\n            this.held = false;\n            this.animSpeedOffset = pc.checked(speedOffset, 0);\n            this.currentAnimName = name;\n        },\n\n        /**\n         * Changes the speed of animation by the given offset. Good for randomizing when you have lots of the same\n         * sprite on-screen\n         * @param {Number} speedOffset Time in ms to offset by (can be negative to slow an animation down)\n         */\n        setAnimationSpeedOffset: function(speedOffset)\n        {\n            this.animSpeedOffset = speedOffset;\n        },\n\n        /**\n         * Changes the current frame\n         * @param {Number} frame Frame to change to\n         */\n        setCurrentFrame: function(frame)\n        {\n            this.currentFrame = frame;\n        },\n\n        /**\n         * Returns the name of the current animation\n         * @return {String} Current animation name\n         */\n        getAnimation:function ()\n        {\n            return this.currentAnimName;\n        },\n\n        /**\n         * Changes the draw alpha for the sprite\n         * @param {Number} a Alpha level to change to (0.5 = 50% transparent)\n         */\n        setAlpha:function (a)\n        {\n            this.alpha = a;\n        },\n\n        /**\n         * Adds to the current alpha level\n         * @param {Number} a Amount to add\n         */\n        addAlpha:function (a)\n        {\n            this.alpha += a;\n            if (this.alpha > 1) this.alpha = 1;\n        },\n\n        /**\n         * Subtracts from the current alpha level\n         * @param {Number} a Amount to subtract\n         */\n        subAlpha:function (a)\n        {\n            this.alpha -= a;\n            if (this.alpha < 0) this.alpha = 0;\n        }\n\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.SpriteSheet\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * Spritesheets are a tool used to configure an image into being a sprite. A spritesheet defines the frame size,\n * source placement and the animations that make up a sprite.\n * <p>\n * To create an on-screen sprite you need to setup a sprite sheet template, then construct a pc.Sprite object\n * using the sheet.\n * <p>\n * To create a sprite sheet you must first load an image resource using the resource loader. You can then use that\n * to construct a sprite sheet:\n * <p>\n * <pre><code>\n * // grab the zombie image resource from the loader\n * var zombieImage = pc.device.loader.get('zombie').resource;\n *\n * // create the spritesheet\n * var zombieSpriteSheet = new pc.SpriteSheet(\n *      { image:zombieImage, frameWidth:80, frameHeight:72 });\n * </code></pre>\n * The sprite sheet class is pretty flexible in how you define the frames. You can actually just specify the number of\n * frames wide and high the sheet is and it will figure our the frame size for you.\n * <p>\n * <h5>Adding Animations</h5>\n * To define the walk animation for the zombie, you just use addAnimation:\n * <pre><code>\n * zombieSpriteSheet.addAnimation({ name:'walking right', frameCount:16, time:1400 });\n * </code></pre>\n * Here we've defined an animation with the tag 'walking right', a frame count of 16 and a total animation time of 1400.\n * <p>\n * Notice we didn't say where in the image the frames start, that's because the default starting frame is 0 for both\n * x and y.\n * <p>\n * To specify a starting frame use the frameX and frameY options.\n * <pre><code>\n * zombieSpriteSheet.addAnimation({ name:'attacking right', frameX: 0, frameY: 2, frameCount:16, time:500 });\n * </code></pre>\n * In this case, the attack animation starts at frame 0 on the x-axis, and the 3rd frame down. It is then 16 frames\n * long.\n * <h5>Making Sprites</h5>\n * To make an actual sprite you can draw on the screen, use the <a href='pc.Sprite'>pc.Sprite</a> class.\n */\n\npc.SpriteSheet = pc.Base.extend('pc.SpriteSheet',\n  /** @lends pc.SpriteSheet */\n  {},\n  /** @lends pc.SpriteSheet.prototype */\n  {\n    /** X scale to draw the image at */\n    scaleX: 1,\n    /** Y scale to draw the image at */\n    scaleY: 1,\n    /** source x position where frames start in the image */\n    sourceX: 0,\n    /** source y position where frames start in the image */\n    sourceY: 0,\n    /** alpha level to draw the image at */\n    alpha: 1,\n    /** whether rotation should be used, or ignored when rendering frames */\n    useRotation: false,\n    /** composite drawing operation */\n    compositeOperation: null,\n    /** total number of frames (read-only) */\n    totalFrames: 0,\n    /** Hashtable of animations keyed by animation name */\n    animations: null,\n\n    frameOffsetX: 0,\n    frameOffsetY: 0,\n\n    /**\n     * Array of frame information; each element is an array with\n     * the positional values:\n     *\n     * [0] - x position\n     * [1] - y position\n     * [2] - width\n     * [3] - height\n     * [4] - image to draw from\n     * [5] - registration x\n     * [6] - regsitration y\n     */\n    frames: null,\n\n    /**\n     * Constructs a new sprite sheet with options. You can use either framesWide or frameWidth, and the logical\n     * default will be assumed. Frame width is assumed to be image.width / framesWide or frames wide will default to\n     * image.width/frameWidth.\n     * @param {pc.Image} options.image Image to use for the sheet\n     * @param {Number} options.framesWide Number of frames wide the sprite sheet is\n     * @param {Number} options.framesHigh Number of frames high the sprite sheet is\n     * @param {Number} options.frameHeight Height of each frame in pixels\n     * @param {Number} options.frameWidth Width of each frame in pixels\n     * @param {Number} options.scaleX X Scale to draw the image at\n     * @param {Number} options.scaleY Y Scale to draw the image at\n     * @param {Number} options.sourceX Source x position in the image\n     * @param {Number} options.sourceY Source y position in the image\n     * @param {Number} options.frameOffsetX Offset frame drawing on the x-axis\n     * @param {Number} options.frameOffsetY Offset frame drawing on the y-axis\n     * @param {Number} options.alpha Alpha level to draw the image at (0.5 is 50% visible)\n     * @param {Boolean} options.useRotation True means the canvas rotation will be used to draw images as an angle\n     * @param {Array} options.frames Specific definitions for each frame; defaults to a grid calculated from above options\n     * @param {Array} options.frames[n] Array with positional frame information\n     * @param {Array} options.frames[n][0] Left edge of the frame\n     * @param {Array} options.frames[n][1] Top edge of the frame\n     * @param {Array} options.frames[n][2] Width of the frame\n     * @param {Array} options.frames[n][3] Height of the frame\n     * @param {Array} options.frames[n][4] Source image for the frame\n     * @param {Array} options.frames[n][5] Registration X for the frame\n     * @param {Array} options.frames[n][6] Registration Y for the frame\n     */\n    init: function (options)\n    {\n      this._super();\n\n      var image = options.image;\n      var frameWidth = this.frameWidth =\n          ('frameWidth' in options) ? options.frameWidth :\n          ('framesWide' in options && options.framesWide > 0 && 'image' in options) ?\n              Math.floor(options.image.width / options.framesWide) :\n          ('image' in options) ? options.image.width :\n          0; // No fixed width\n\n      var frameHeight = this.frameHeight =\n          ('frameHeight' in options) ? options.frameHeight :\n          ('framesHigh' in options && options.framesHigh > 0 && 'image' in options) ?\n              Math.floor(options.image.height / options.framesHigh) :\n          ('image' in options) ? options.image.height :\n          0; // No fixed height\n\n      var framesWide = this.framesWide =\n        ('framesWide' in options) ? options.framesWide :\n        ('image' in options && frameWidth > 0) ?\n            Math.floor(options.image.width / frameWidth) :\n        ('frames' in options) ? options.frames.length :\n        1;\n      var framesHigh = this.framesHigh =\n        ('framesHigh' in options) ? options.framesHigh :\n        ('image' in options && 'frameHeight' in options) ?\n            Math.floor(options.image.height / frameHeight) :\n        1;\n\n      this.scaleX = pc.checked(options.scaleX, 1);\n      this.scaleY = pc.checked(options.scaleY, 1);\n      this.sourceX = pc.checked(options.sourceX, 0);\n      this.sourceY = pc.checked(options.sourceY, 0);\n      this.frameOffsetX = pc.checked(options.frameOffsetX, 0);\n      this.frameOffsetY = pc.checked(options.frameOffsetY, 0);\n      this.alpha = pc.checked(options.alpha, 1);\n      this.useRotation = pc.checked(options.useRotation, true);\n\n      this.options = options; //DELME\n\n      this.animations = new pc.Hashtable();\n      if('frames' in options)\n      {\n        this.frames = options.frames;\n        this.totalFrames = options.frames.length;\n      }\n      else if(pc.valid(image))\n      {\n        // In this case, used a fixed size grid over the image provided\n        if (!image.width || !image.height)\n          throw \"Invalid image (zero width or height)\";\n\n        this.image = image;\n        this.totalFrames = framesWide * framesHigh;\n        this.frames = [];\n        var frameIndex = 0;\n        for (var fy = 0; fy < framesHigh; fy++)\n        {\n          for (var fx = 0; fx < framesWide; fx++)\n          {\n            // x, y, width, height, image, regX, regY\n            this.frames.push([\n              fx * frameWidth,\n              fy * frameHeight,\n              frameWidth,\n              frameHeight,\n              image, 0, 0\n            ]);\n          }\n        }\n      }\n      else\n      {\n        if(frameWidth || frameHeight)\n        {\n          // Probably a mistake\n          throw new Error('No image provided for sprite sheet grid');\n        }\n        // Add frames later\n        this.frames = [];\n        this.totalFrames = 0;\n      }\n\n      if('animations' in options)\n      {\n        if('forEach' in options.animations)\n        {\n          options.animations.forEach(this.addAnimation, this);\n        }\n        else\n        {\n          for(var animName in options.animations)\n          {\n            if(options.animations.hasOwnProperty(animName))\n            {\n              var anim = options.animations[animName];\n              if(!('name' in anim))\n                anim.name = animName;\n              this.addAnimation(anim);\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * Defines an animation\n     * @param {String} options.name A descriptive name for the animation (required)\n     * @param {Number} [options.frameX] The starting frame X position (in frames, not pixels) defaults to 0\n     * @param {Number} [options.frameY] The starting frame Y position (in frames, not pixels) defaults to 0\n     * @param {Number} [options.frames] A 2d-array of frame numbers ([ [0, 0], [0, 1] ]) , note these are OFFSET by frameX and frameY. Use null\n     * to automatically sequence through all frames across the image, or specify frame count\n     * @param {Number} [options.frameCount] number of frames to use, starting from frameX, frameY and stepping forward across the spritesheet\n     * @param {Number} [options.frameRate] Frames per second; by default, calculated from \"time\"\n     * @param {Number} [options.time=1000] Milliseconds to loop through entire sequence; ignored if frameRate specified.\n     * @param {Number} [options.loops=0] Number of times to cycle through this animation, use 0 to loop infinitely\n     * @param {Boolean} [options.holdOnEnd] Whether to hold the last frame when the animation has played through\n     * @param {Number} [options.scaleX] X scaling to apply (negative values reverse the image)\n     * @param {Number} [options.scaleY] Y scaling to apply (negative values reverse the image)\n     * @param {Number} [options.framesWide] Number of frames to go across before stepping down\n     * @param {Number} [options.framesHigh] Number of frames down\n     */\n    addAnimation: function (options)\n    {\n      if (!pc.valid(options.name)) throw \"Animation requires a name for reference\";\n\n      options.frameX = pc.checked(options.frameX, 0);\n      options.frameY = pc.checked(options.frameY, 0);\n      options.directions = pc.checked(options.directions, 1);\n      options.time = pc.checked(options.time, 1000);\n      options.loops = pc.checked(options.loops, 0);\n      options.holdOnEnd = pc.checked(options.holdOnEnd, false);\n      options.dirAcross = pc.checked(options.dirAcross, false);\n      options.scaleX = pc.checked(options.scaleX, 1);\n      options.scaleY = pc.checked(options.scaleY, 1);\n      options.offsetX = pc.checked(options.offsetX, 0);\n      options.offsetY = pc.checked(options.offsetY, 0);\n      options.framesWide = pc.checked(options.framesWide, this.framesWide);\n      options.framesHigh = pc.checked(options.framesHigh, this.framesHigh);\n      options.frameCount = pc.checked(options.frameCount, 0);\n\n      // no frames specified, create the frames array automagically\n      if (!pc.valid(options.frames))\n      {\n        var frames = options.frames = [];\n\n        // If they don't provide a frameCount, calculate\n        // it from framesWide/framesHigh.\n        // TODO This is a pretty confusing and probably incorrect feature ...\n        if (options.frameCount == 0)\n          options.frameCount = options.framesWide * options.framesHigh;\n\n        var startFrame = options.frameX + (options.frameY * this.framesWide);\n        var endFrame = startFrame + options.frameCount;\n\n        // start at frameX, frameY and move across and down.  When\n        // moving to the next row, fall back to the start of the row.\n        for(var n = startFrame; n < endFrame; n++)\n        {\n          x = n % this.framesWide\n          y = Math.floor(n / this.framesWide)\n          frames.push([x, y]);\n        }\n      }\n\n      options.frameCount = options.frames.length;\n\n\n      if('frameRate' in options)\n      {\n        options.frameTime = 1000 / options.frameRate;\n        options.time = options.frameTime * options.frames.length;\n      }\n      else\n      {\n        options.frameRate = options.frames.length / options.time;\n        options.frameTime = options.time / options.frames.length;\n      }\n\n      this.animations.put(options.name, options);\n    },\n\n    /**\n     * Change this sprites animation. Animation frames always start from 0 again.\n     * @param name Key name of the animation to switch to.\n     */\n    setAnimation: function (state, name, speedOffset)\n    {\n      state.currentAnim = this.animations.get(name);\n      if (state.currentAnim == null)\n        this.warn('attempt to set unknown animation [' + name + ']');\n      state.currentFrame = 0;\n      state.held = false;\n      state.animSpeedOffset = pc.checked(speedOffset, 0);\n    },\n\n    /**\n     * Checks if this sheet has an animation of a given name\n     * @param {String} name Animation name\n     * @return {Boolean} true if the animation exists on this sheet\n     */\n    hasAnimation: function (name)\n    {\n      return (this.animations.get(name) != null);\n    },\n\n    /**\n     * Sets the scale to draw the image at\n     * @param {Number} scaleX Value to multiply the image width by (e.g. width * scaleX)\n     * @param {Number} scaleY Value to multiply the image height by (e.g. height * scaleX)\n     */\n    setScale: function (scaleX, scaleY)\n    {\n      this.scaleX = scaleX;\n      this.scaleY = scaleY;\n    },\n\n    /**\n     * Sets the componsite drawing operation for this sprite sheet. Set to null to clear it back to the default.\n     * @param {String} o Composite drawing operation\n     */\n    setCompositeOperation: function (o)\n    {\n      this.compositeOperation = o;\n    },\n\n    dirTmp: 0,\n\n    /**\n     * Draw a sprite using a frame from the sprite sheet\n     * @param {pc.Sprite} state Sprite to draw\n     * @param {Number} x On-screen x position\n     * @param {Number} y On-screen y position\n     * @param {Number} dir The facing direction (in degrees)\n     */\n    draw: function (ctx, state, x, y, dir)\n    {\n      var frame;\n      var offsetX;\n      var offsetY;\n      var scaleX = this.scaleX;\n      var scaleY = this.scaleY;\n      if(state.currentAnim == null)\n      {\n        frame = this.frames[state.currentFrame];\n        offsetX = offsetY = 0;\n      }\n      else\n      {\n        var fx = state.currentAnim.frames[state.currentFrame][0];\n        var fy = state.currentAnim.frames[state.currentFrame][1];\n        offsetX = state.currentAnim.offsetX;\n        offsetY = state.currentAnim.offsetY;\n        scaleX *= state.currentAnim.scaleX;\n        scaleY *= state.currentAnim.scaleY;\n        frame = this.frames[fx + fy*this.framesWide];\n      }\n      if(!pc.valid(frame))\n        throw new Error('Frame out of bounds: '+state.currentFrame);\n\n      var frameSourceX = frame[0];\n      var frameSourceY = frame[1];\n      var frameWidth = frame[2];\n      var frameHeight = frame[3];\n      var frameImage = frame[4];\n      var frameRegX = frame[5];\n      var frameRegY = frame[6];\n\n      if (!frameImage.loaded || state == null || !state.active) return;\n\n      if (scaleX != 1 || scaleY != 1)\n        frameImage.setScale(scaleX, scaleY);\n\n      if (state.alpha != 1)\n        frameImage.alpha = state.alpha;\n\n      if (this.compositeOperation != null)\n        frameImage.setCompositeOperation(this.compositeOperation);\n\n      frameImage.draw(ctx,\n        this.sourceX + frameSourceX,\n        this.sourceY + frameSourceY,\n        Math.round(x + offsetX + this.frameOffsetX - frameRegX),\n        Math.round(y + offsetY + this.frameOffsetY - frameRegY),\n        frameWidth, frameHeight,\n        this.useRotation ? dir : 0);\n\n      // restore scaling (as images can be used amongst spritesheets, we need to be nice)\n      if (scaleX != 1 || scaleY != 1)\n        frameImage.setScale(1, 1);\n\n      // set the alpha back to normal\n      if (state.alpha != 1)\n        frameImage.alpha = 1;\n\n      if (this.compositeOperation != null)\n        frameImage.setCompositeOperation('source-over');\n\n    },\n\n    /**\n     * Draw a single frame from the sprite sheet\n     * @param {Context} ctx Device context to draw on\n     * @param {Number} frameX The x-pos of the frame to draw\n     * @param {Number} frameY The y-pos of the frame to draw\n     * @param {Number} x x-pos to draw on the target context\n     * @param {Number} y y-pos to draw on the target context\n     * @param {Number} angle Angle to draw the frame at\n     */\n    drawFrame: function (ctx, frameX, frameY, x, y, angle)\n    {\n      var frame = this.frames[frameX + frameY * this.framesWide];\n      if(!pc.valid(frame))\n        throw new Error('Frame out of bounds: '+x+','+y);\n\n      var frameSourceX = frame[0];\n      var frameSourceY = frame[1];\n      var frameWidth = frame[2];\n      var frameHeight = frame[3];\n      var frameImage = frame[4];\n      var frameRegX = frame[5];\n      var frameRegY = frame[6];\n\n      if (this.alpha != 1)\n        ctx.globalAlpha = this.alpha;\n\n      if (this.scaleX != 1 || this.scaleY != 1)\n        frameImage.setScale(this.scaleX, this.scaleY);\n\n      if (this.compositeOperation != null)\n        frameImage.setCompositeOperation(this.compositeOperation);\n\n      frameImage.draw(ctx,\n        this.sourceX + frameSourceX,\n        this.sourceY + frameSourceY,\n        pc.Math.round(x) + this.frameOffsetX - frameRegX,\n        pc.Math.round(y) + this.frameOffsetY - frameRegY,\n        frameWidth, frameHeight, angle);\n\n      if (this.scaleX != 1 || this.scaleY != 1)\n        frameImage.setScale(1, 1);\n      if (this.alpha != 1) ctx.globalAlpha = 1;\n      if (this.compositeOperation != null)\n        frameImage.setCompositeOperation('source-over');\n\n      return frame;\n    },\n\n    /**\n     * Draw all the frames of a sprite sheet according to the image and parameters you set it\n     * up with. Primarily this is intended for debugging or sprite testing.\n     * @param {Context} ctx Context to draw on\n     * @param {Number} x Starting x position to draw on the given context\n     * @param {Number} y Starting y position to draw on the given context\n     */\n    drawAllFrames: function (ctx, x, y)\n    {\n      for (var fy = 0; fy < this.framesHigh; fy++)\n        for (var fx = 0; fx < this.framesWide; fx++)\n          this.drawFrame(ctx, fx, fy, x + (fx * this.frameWidth), y + (fy * this.frameHeight));\n    },\n\n    getFrameInfo: function(x, y)\n    {\n      return this.frames[pc.checked(x, 0) + (pc.checked(y, 0) * this.framesWide)];\n    },\n\n    /**\n     * Get the width of a given frame on the source image\n     *\n     * @param {Number} [x=0] Spritesheet grid x\n     * @param {Number} [y=0] Spritesheet grid y\n     */\n    getFrameWidth: function(x, y)\n    {\n      return this.getFrameInfo(x, y)[2];\n    },\n\n    /**\n     * Get the height of a given frame on the source image\n     *\n     * @param {Number} [x=0] Spritesheet grid x\n     * @param {Number} [y=0] Spritesheet grid y\n     */\n    getFrameHeight: function(x, y)\n    {\n      return this.getFrameInfo(x, y)[2];\n    },\n\n    /**\n     * Get a sprite off the sheet as a Subimage that\n     * can be used indepently to draw or create another\n     * spritesheet.\n     *\n     * @param {Number} [x=0] Spritesheet grid x\n     * @param {Number} [y=0] Spritesheet grid y\n     */\n    getFrameAsImage: function(x, y)\n    {\n      var frame = this.getFrameInfo(x,y);\n      return new pc.Subimage(frame[4], {\n        x:frame[0],\n        y:frame[1],\n        w:frame[2],\n        h:frame[3]\n      });\n    },\n\n    /**\n     * Update the sprite based on the current animation, frame and timing. Typically called automatically\n     * from the sprite class\n     * @param {pc.Sprite} state Sprite to update\n     * @param {Number} delta Amount of time to move forward by\n     */\n    update: function (state, delta)\n    {\n      if (state.currentAnim == null || !state.active || state.held) return;\n\n      if (state.currentAnim.frames.length <= 1) return;\n\n      // see if enough time has past to increment the frame count\n      if (state._acDelta > (state.currentAnim.frameTime + state.animSpeedOffset))\n      {\n        state.currentFrame++;\n        if (state.currentFrame >= state.currentAnim.frames.length)\n        {\n          state.loopCount++;\n          // checked if we have looped the animation enough times\n          if (state.currentAnim.loops) // 0 means loop forever\n            if (state.loopCount >= state.currentAnim.loops)\n            {\n              if (state.currentAnim.holdOnEnd)\n              {\n                state.held = true;\n                if (state.currentFrame) state.currentFrame--;\n              }\n              else\n                state.active = false;\n            }\n\n          if (!state.held) state.currentFrame = 0; // take it from the top\n        }\n        state._acDelta -= state.currentAnim.frameTime;\n      } else\n      {\n        state._acDelta += delta;\n      }\n    },\n\n    /**\n     * Clear the sprite by nulling the image and animations\n     */\n    reset: function ()\n    {\n      this.image = null;\n      this.animations = null;\n      this.frames = null;\n    }\n\n  });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.Math\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * A collection of math tools you can use. This is a static class, so you do not need to construct it, and all\n * methods/members are accessed using pc.Math.\n */\npc.Math = pc.Base('pc.Math',\n  /** @lends pc.Math */\n  {\n    /** Quick lookup to convert radians to degrees */\n    RADIAN_TO_DEGREE: (180 / Math.PI),\n    /** Quick lookup to convert degrees to radians */\n    DEGREE_TO_RADIAN: (Math.PI / 180),\n    /** Quick lookup for Math.PI */\n    PI: Math.PI,\n\n    /** Quick lookup for Math.round */\n    round: Math.round,\n    /** Quick lookup for Math.random */\n    random: Math.random,\n    /** Quick lookup for Math.floor */\n    floor: Math.floor,\n\n    /**\n     * Find the square of a number\n     * @param {Number} number The square of the number\n     */\n    sqr: function (number)\n    {\n      return number * number;\n    },\n\n    /**\n     * Returns a random integer within the specified range. e.g. rand(10, 20) returns a value between 10 and 20.\n     * If you need a float random use randFloat.\n     * @param {Number} min the start of the range\n     * @param {Number} max the end of the range\n     * @returns {Number} A random number between (and including) the range\n     */\n    rand: function (min, max)\n    {\n      return pc.Math.round((pc.Math.random() * (max - min)) + min);\n    },\n\n    /**\n     * Returns a random float within the specified range. e.g. rand(10, 20) returns a value between 10 and 20.\n     * @param {Number} min the start of the range\n     * @param {Number} max the end of the range\n     * @returns {Number} A random number between (and including) the range\n     */\n    randFloat: function (min, max)\n    {\n      return (pc.Math.random() * (max - min)) + min;\n    },\n\n    /**\n     * Rotates a given angle by an amount in degrees\n     * @param {Number} angle Original angle\n     * @param {Number} by Amount to add in degrees (can be negative)\n     * @return {Number} A new angle, rotated by the amount given\n     */\n    rotate: function (angle, by)\n    {\n      var newDir = angle + by;\n      while (newDir > 359)\n        newDir -= 360;\n      while (newDir < 0)\n        newDir = 360 + newDir;\n      return newDir;\n    },\n\n    /**\n     * Resolve an angle to 0 to 360 (if the angle is negative)\n     * @param angle\n     * @returns {Number} an angle between\n     */\n    simplifyAngle: function(angle)\n    {\n      // if the angle is negative we add 360\n      if (angle < 0)\n        return angle + 360;\n      if (angle > 360)\n        return angle % 360;\n\n      return angle;\n    },\n\n    /**\n     * Calculates the angle difference based on two angles and a direction (clockwise or counterclockwise)\n     * @param {Number} angleA Starting angle in degrees\n     * @param {Number} angleB Ending angle in degrees\n     * @param {Boolean} clockwise True if the difference should be calculated in a clockwise direction\n     * @return {Number} Angle difference in degrees\n     */\n    angleDiff: function (angleA, angleB, clockwise)\n    {\n      if (!clockwise)\n      {\n        var diff = angleA - angleB;\n        if (diff < 0) diff += 360;\n        return diff;\n      } else\n      {\n        if (angleB < angleA) // wrapping around 0/360\n          angleB += 360;\n        return angleB - angleA;\n      }\n    },\n\n    /**\n     * Is the first angle closest by going clockwise of the second angle\n     * @param {Number} angleA Angle to target\n     * @param {Number} angleB Angle clockwise is relative to\n     * @return {Boolean} True if angle A is clockwise to angle B\n     */\n    isClockwise: function (angleA, angleB)\n    {\n      if (angleA > angleB)\n        return (Math.abs(angleA - angleB)) < (angleB + (360 - angleA));\n      else\n        return (angleA + (360 - angleB)) < (Math.abs(angleB - angleA));\n    },\n\n    /**\n     * Returns whether an angle is facing to the right from a side-scrolling 2d perspective\n     * @param {Number} angle Angle to test\n     * @return {Boolean} true is facing to the right, otherwise false (meaning it's facing left)\n     */\n    isFacingRight: function (angle)\n    {\n      if (angle > 270 || angle < 90) return true;\n      return false;\n    },\n\n    /**\n     * Converts radians to degrees\n     * @param {Number} radians Radians\n     * @return {Number} Radians from degrees\n     */\n    radToDeg: function (radians)\n    {\n      return (radians * pc.Math.RADIAN_TO_DEGREE);\n    },\n\n    /**\n     * Converts degrees to radains\n     * @param {Number} degrees Degrees to convert\n     * @return {Number} Number of radians\n     */\n    degToRad: function (degrees)\n    {\n      return degrees * pc.Math.DEGREE_TO_RADIAN;\n    },\n\n    /**\n     * Gives you the angle of a given vector x, y\n     * @param {Number} x x component of the 2d vector\n     * @param {Number} y y component of the 2d vector\n     * @return Angle in degrees\n     */\n    angleFromVector: function (x, y)\n    {\n      // angle to vector\n      var a = pc.Math.radToDeg(Math.atan2(y, x));\n      if (a < 0) a += 360;\n      return a;\n    },\n\n    /**\n     * Gives you the x, y vector of a given angle in degrees. This method creates a pc.Point which you should\n     * release after use\n     * @param {Number} angle Angle in degrees\n     * @return {pc.Point} A newly acquired pc.Point with the vector.\n     */\n    vectorFromAngle: function (angle)\n    {\n      var vx = Math.cos(pc.Math.degToRad(angle));\n      var vy = Math.sin(pc.Math.degToRad(angle));\n      return pc.Point.create(vx, vy);\n    },\n\n    /**\n     * A fast check if a point is within a rectangle\n     * @param {Number} x x-position of the point to test\n     * @param {Number} y y-position of the point to test\n     * @param {Number} rx x-position of the rectangle\n     * @param {Number} ry y-position of the rectangle\n     * @param {Number} rw width of the rectangle\n     * @param {Number} rh height of the rectangle\n     * @return {Boolean} true is the point is within the rectangle\n     */\n    isPointInRect: function (x, y, rx, ry, rw, rh)\n    {\n      return x >= rx && x <= (rx + rw) &&\n        y >= ry && y <= (ry + rh);\n    },\n\n    /**\n     * Checks if one rectangle is completely contained in another\n     * @param {Number} x x-position of the point to test\n     * @param {Number} y y-position of the point to test\n     * @param {Number} w height of the rectangle to test\n     * @param {Number} h width of the rectangle to test\n     * @param {Number} rx x-position of the rectangle\n     * @param {Number} ry y-position of the rectangle\n     * @param {Number} rw width of the rectangle\n     * @param {Number} rh height of the rectangle\n     * @return {Boolean} true is the rectangle is fully within the other\n     */\n    isRectInRect: function (x, y, w, h, rx, ry, rw, rh)\n    {\n      if (!pc.Math.isPointInRect(x, y, rx, ry, rw, rh)) return false;\n      if (!pc.Math.isPointInRect(x + w, y, rx, ry, rw, rh)) return false;\n      if (!pc.Math.isPointInRect(x, y + h, rx, ry, rw, rh)) return false;\n      return pc.Math.isPointInRect(x + w, y + h, rx, ry, rw, rh);\n    },\n\n    /**\n     * Fast test if one rectangle is overlapping another at any point\n     * @param {Number} x x-position of the point to test\n     * @param {Number} y y-position of the point to test\n     * @param {Number} w height of the rectangle to test\n     * @param {Number} h width of the rectangle to test\n     * @param {Number} rx x-position of the rectangle\n     * @param {Number} ry y-position of the rectangle\n     * @param {Number} rw width of the rectangle\n     * @param {Number} rh height of the rectangle\n     * @return {Boolean} true if the rectangle overlaps anywhere\n     */\n    isRectColliding: function (x, y, w, h, rx, ry, rw, rh)\n    {\n      return !(y + h < ry || y > ry + rh ||\n        x + w < rx || x > rx + rw);\n    },\n\n    /**\n     * Forces a given value to be within a range (lowest to highest)\n     * @param {Number} v The value to check\n     * @param {Number} lowest Lowest value it can be\n     * @param {Number} highest Highest value it can be\n     * @return {Number} Original value or the edge of the fence if needed\n     */\n    limit: function (v, lowest, highest)\n    {\n      if (v < lowest) return lowest;\n      if (v > highest) return highest;\n      return v;\n    },\n\n    /**\n     * Same as limit, but allows an increment value as well (which can be negative)\n     * @param {Number} v Original value\n     * @param {Number} inc Amount to add (can be negative)\n     * @param {Number} lowest Lowest value to fence\n     * @param {Number} highest Highest value to fence\n     * @return {Number} Value with inc added fenced by the lowest and highest limits\n     */\n    limitAdd: function (v, inc, lowest, highest)\n    {\n      if (v + inc < lowest) return lowest;\n      if (v + inc > highest) return highest;\n      return v + inc;\n    }\n  },\n  {\n    // No instance, since this is an all static class\n  });\n\n\n/**\n * @class pc.Rect\n * @description\n * [Extends <a href='pc.Pooled'>pc.Pooled</a>]\n * <p>\n * Represents a rectangle.\n */\npc.Rect = pc.Pooled('pc.Rect',\n  /** @lends pc.Rect */\n  {\n    /**\n     * Constructs a new rectangle\n     * @param {Number} x x-position of the top left of the rectangle\n     * @param {Number} y y-position of the top left of the rectangle\n     * @param {Number} w width of the rectangle\n     * @param {Number} h height of the rectangle\n     * @return {pc.Rect} A new rectangle (acquired from the free object pool}\n     */\n    create: function (x, y, w, h)\n    {\n      var newDim = this._super();\n      newDim.x = x;\n      newDim.y = y;\n      newDim.w = w;\n      newDim.h = h;\n      return newDim;\n    }\n  },\n  /** @lends pc.Rect.prototype */\n  {\n    /** x position of the top left of the rectangle */\n    x: 0,\n    /** y position of the top left of the rectangle */\n    y: 0,\n    /** width of the rectangle */\n    w: 0,\n    /** height of the rectangle */\n    h: 0,\n\n    /**\n     * Checks if one rectangle is completely contained in another\n     * @param {Number} x x-position of the point to test\n     * @param {Number} y y-position of the point to test\n     * @param {Number} w height of the rectangle to test\n     * @param {Number} h width of the rectangle to test\n     * @param {Number} rx x-position of the rectangle\n     * @param {Number} ry y-position of the rectangle\n     * @param {Number} rw width of the rectangle\n     * @param {Number} rh height of the rectangle\n     * @return {Boolean} true is the rectangle is fully within the other\n     */\n    containsRect: function (x, y, w, h, rx, ry, rw, rh)\n    {\n      if (!pc.Math.isPointInRect(x, y, rx, ry, rw, rh)) return false;\n      if (!pc.Math.isPointInRect(x + w, y, rx, ry, rw, rh)) return false;\n      if (!pc.Math.isPointInRect(x, y + h, rx, ry, rw, rh)) return false;\n      return pc.Math.isPointInRect(x + w, y + h, rx, ry, rw, rh);\n    },\n\n    /**\n     * Checks if a point is within the rectangle\n     * @param {pc.Point} p A pc.point (or any object with a .x and .y property\n     * @return {Boolean} true if the point is within the rectangle\n     */\n    containsPoint: function (p)\n    {\n      return p.x >= this.x && p.x <= (this.x + this.w) &&\n        p.y >= this.y && p.y <= (this.y + this.h);\n    },\n\n    /**\n     * Checks if this rectangle overlaps another (including rotation support)\n     * @param {Number} rx x-position of the rectangle\n     * @param {Number} ry y-position of the rectangle\n     * @param {Number} rw width of the rectangle\n     * @param {Number} rh height of the rectangle\n     * @param {Number} dir Direction to rotate the angle to\n     * @return {Boolean} true if the rectangle overlaps another\n     */\n    overlaps: function (rx, ry, rw, rh, dir)\n    {\n      var w = rw;\n      var h = rh;\n\n      if (pc.valid(dir) && dir != 0)\n      {\n        // calculate using a rotated rectangle\n        var s = Math.sin(pc.Math.degToRad(dir));\n        var c = Math.cos(pc.Math.degToRad(dir));\n        if (s < 0) s = -s;\n        if (c < 0) c = -c;\n        w = rh * s + rw * c; // width of AABB\n        h = rh * c + rw * s; // height of AABB\n      }\n      return !(this.y + this.h < ry || this.y > ry + h ||\n        this.x + this.w < rx || this.x > rx + w);\n    },\n\n    /**\n     * @return {String} A nice string representation of the rectangle\n     */\n    toString: function ()\n    {\n      return this.x + ' x ' + this.y + ' by ' + this.w + ' x ' + this.h;\n    }\n\n\n\n  });\n\n/**\n * @class pc.Point\n * @description\n * [Extends <a href='pc.Pooled'>pc.Pooled</a>]\n * <p>\n * Represents a 2D point.\n */\npc.Point = pc.Pooled('pc.Point',\n  /** @lends pc.Point */\n  {\n    /**\n     * Constructs a new point (from the pool)\n     * @param {Number} x x position\n     * @param {Number} y y position\n     * @return {pc.Point} A shiny new point\n     */\n    create: function (x, y)\n    {\n      var n = this._super();\n      n.x = x;\n      n.y = y;\n      return n;\n    }\n  },\n  /** @lends pc.Point.prototype */\n  {\n    /** x position of the point */\n    x: 0,\n    /** y position of the point */\n    y: 0,\n\n    init: function(x, y)\n    {\n      this._super();\n      this.x = x;\n      this.y = y;\n    },\n\n    /**\n     * Tests whether one point is equal to another\n     * @param {pc.Point} other Other point to test against\n     */\n    equals: function (other)\n    {\n      return (this.x == other.x && this.y == other.y);\n    },\n\n    /**\n     * Makes this point match another\n     * @param {pc.Point} p The other point to match\n     */\n    match: function (p)\n    {\n      this.x = p.x;\n      this.y = p.y;\n    },\n\n    /**\n     * Returns a new point with the same x, y as this one\n     * @returns {pc.Point} New point from the pool\n     */\n    clone: function()\n    {\n      return pc.Point.create(this.x, this.y);\n    },\n\n    /**\n     * Makes this point match another\n     * @param {pc.Point} p The other point to match\n     */\n    set: function (p)\n    {\n      this.match(p);\n    },\n\n    /**\n     * Sets the x and y of the point\n     * @param {Number} x x position to set\n     * @param {Number} y y position to set\n     * @return {pc.Point} This point\n     */\n    setXY: function (x, y)\n    {\n      this.x = x;\n      this.y = y;\n      return this;\n    },\n\n    /**\n     * Adds to the point\n     * @param {Number|pc.Point} xOrPoint Amount to add to x (or alternatively a pc.Point to add)\n     * @param {Number} y Amount to add to y\n     * @return {pc.Point} This point\n     */\n    add: function (xOrPoint, y)\n    {\n      if (arguments.length == 1)\n      {\n        this.x += xOrPoint.x;\n        this.y += xOrPoint.y;\n        return this;\n      }\n\n      this.x += x;\n      this.y += y;\n      return this;\n    },\n\n    /**\n     * Subtracts from the point\n     * @param {Number} x Amount to subtract from x\n     * @param {Number} y Amount to subtract from y\n     * @return {pc.Point} This point\n     */\n    subtract: function (x, y)\n    {\n      this.x -= x;\n      this.y -= y;\n      return this;\n    },\n\n    /**\n     * Gives you the angle from this point to another\n     * @param {pc.Point} p Another point\n     * @return {Number} Facing direction (in degrees) from this point to another\n     */\n    dirTo: function (p)\n    {\n      return Math.atan2(p.y - this.y, p.x - this.x) * 180 / Math.PI;\n    },\n\n    /**\n     * Modifies the point by moving along at a projected angle (dir) by the distance\n     * @param {Number} dir Direction to move, in degrees\n     * @param {Number} distance Distance to move\n     */\n    moveInDir: function (dir, distance)\n    {\n      this.x += distance * Math.cos(pc.Math.degToRad(dir));\n      this.y += distance * Math.sin(pc.Math.degToRad(dir));\n      return this;\n    },\n\n    /**\n     * Changes the from position by an amount of pixels in the direction of the to position\n     * ultimately reaching that point\n     * @param {pc.Point} to Ending position\n     * @param {Number} distance Amount to move\n     */\n    moveTowards: function (to, distance)\n    {\n      this.moveInDir(this.dirTo(to), distance);\n    },\n\n    /**\n     * Get the distance between this point and another\n     * @param {pc.Point} p Another point\n     * @return {Number} Distance between this point and another\n     */\n    distance: function (p)\n    {\n      return Math.sqrt((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y));\n    },\n\n    /**\n     * A nice string representing this point\n     * @return {String}\n     */\n    toString: function ()\n    {\n      return this.x + 'x' + this.y;\n    }\n\n\n  });\n\npc.Poly = pc.Pooled('pc.Poly',\n  /** @lends pc.Poly */\n  {\n    create: function (x, y, points)\n    {\n      var n = this._super();\n      n.init(x, y, points);\n      return n;\n    }\n  },\n  /** @lends pc.Poly.prototype */\n  {\n    /** x position of the polygon */\n    x: 0,\n    /** y position of the polygon */\n    y: 0,\n    /** array of points representing the polygon (relative to x, y) */\n    points: null,\n\n    _boundingRect: null,\n\n    init: function (x, y, points)\n    {\n      this.x = x;\n      this.y = y;\n      this.points = points;\n      this._boundingRect = pc.Rect.create(0, 0, 0, 0);\n      this.calcBoundingRect();\n    },\n\n    /**\n     * If you modify the points or position of this polygon,\n     * and you want to use getBoundingRect(), call this\n     * to update the cached bounding rectangle.\n     */\n    calcBoundingRect:function()\n    {\n      if(!pc.valid(this.points) || !this.points.length)\n        return;\n      var minX=this.points[0].x;\n      var maxX=minX;\n      var minY=this.points[0].y;\n      var maxY=minY;\n      for(var i=1; i < this.points.length; i++)\n      {\n        var px = this.points[i].x;\n        minX = Math.min(px, minX);\n        maxX = Math.max(px, maxX);\n        var py = this.points[i].y;\n        minY = Math.min(py, minY);\n        maxY = Math.max(py, maxY);\n      }\n      this._boundingRect.x = this.x+minX;\n      this._boundingRect.y = this.y+minY;\n      this._boundingRect.w = maxX-minX;\n      this._boundingRect.h = maxY-minY;\n    },\n\n    getBoundingRect: function ()\n    {\n      return this._boundingRect;\n    },\n\n    containsPoint: function (p)\n    {\n      for (var c = false, i = -1, l = this.points.length, j = l - 1; ++i < l; j = i)\n      {\n        ((this.points[i].y <= p.y && p.y < this.points[j].y) || (this.points[j].y <= p.y && p.y < this.points[i].y))\n          && (p.x < (this.points[j].x - this.points[i].x) * (p.y - this.points[i].y) / (this.points[j].y - this.points[i].y) + this.points[i].x)\n        && (c = !c);\n      }\n      return c;\n    }\n  });\n\n\n/**\n * @class pc.Dim\n * @description\n * [Extends <a href='pc.Point'>pc.Point</a>]\n * <p>\n * Synonym for a point\n */\npc.Dim = pc.Point;\n\n/**\n * @class pc.Vector\n * @description\n * [Extends <a href='pc.Point'>pc.Point</a>]\n * <p>\n * Synonym for a point\n */\npc.Vector = pc.Point;\n\n\n/**\n * @class pc.Easing\n * @description\n * <p>\n * A collection of useful easing functions - partially from https://github.com/sole/tween.js\n */\npc.Easing = {\n\n  LINEAR: 0,\n  QUADRATIC_IN: 1,\n  QUADRATIC_OUT: 2,\n  QUADRATIC_IN_OUT: 3,\n  CUBIC_IN: 4,\n  CUBIC_OUT: 5,\n  CUBIC_IN_OUT: 6,\n  EXPONENTIAL_IN: 7,\n  EXPONENTIAL_OUT: 8,\n  EXPONENTIAL_IN_OUT: 9,\n  CIRCULAR_IN: 10,\n  CIRCULAR_OUT: 11,\n  CIRCULAR_IN_OUT: 12,\n  ELASTIC_IN: 13,\n  ELASTIC_OUT: 14,\n  ELASTIC_IN_OUT: 15,\n  BOUNCE_IN: 16,\n  BOUNCE_OUT: 17,\n  BOUNCE_IN_OUT: 18,\n  BACK_IN: 19,\n  BACK_OUT: 20,\n  BACK_IN_OUT: 21,\n\n  ease: function(type, k)\n  {\n    switch (type)\n    {\n      case this.LINEAR: return this.linear(k);\n      case this.QUADRATIC_IN: return this.quadraticIn(k);\n      case this.QUADRATIC_OUT: return this.quadraticOut(k);\n      case this.QUADRATIC_IN_OUT: return this.quadraticInOut(k);\n      case this.CUBIC_IN: return this.cubicIn(k);\n      case this.CUBIC_OUT: return this.cubicOut(k);\n      case this.CUBIC_IN_OUT: return this.cubicInOut(k);\n      case this.EXPONENTIAL_IN: return this.exponentialIn(k);\n      case this.EXPONENTIAL_OUT: return this.exponentialOut(k);\n      case this.EXPONENTIAL_IN_OUT: return this.exponentialInOut(k);\n      case this.CIRCULAR_IN: return this.circularIn(k);\n      case this.CIRCULAR_OUT: return this.circularOut(k);\n      case this.CIRCULAR_IN_OUT: return this.circularInOut(k);\n      case this.ELASTIC_IN: return this.elasticIn(k);\n      case this.ELASTIC_OUT: return this.elasticOut(k);\n      case this.ELASTIC_IN_OUT: return this.elasticInOut(k);\n      case this.BOUNCE_IN: return this.bounceIn(k);\n      case this.BOUNCE_OUT: return this.bounceOut(k);\n      case this.BOUNCE_IN_OUT: return this.bounceInOut(k);\n      case this.BACK_IN: return this.backIn(k);\n      case this.BACK_OUT: return this.backOut(k);\n      case this.BACK_IN_OUT: return this.backInOut(k);\n    }\n\n    return this.linear(k);\n\n  },\n\n  linear: function (k)\n  {\n    return k;\n  },\n\n  quadraticIn: function (k)\n  {\n    return k * k;\n  },\n\n  quadraticOut: function (k)\n  {\n    return k * ( 2 - k );\n  },\n\n  quadraticInOut: function (k)\n  {\n    if (( k *= 2 ) < 1) return 0.5 * k * k;\n    return -0.5 * ( --k * ( k - 2 ) - 1 );\n  },\n\n  cubicIn: function (k)\n  {\n    return k * k * k;\n  },\n\n  cubicOut: function (k)\n  {\n    return --k * k * k + 1;\n  },\n\n  cubicInOut: function (k)\n  {\n    if (( k *= 2 ) < 1) return 0.5 * k * k * k;\n    return 0.5 * ( ( k -= 2 ) * k * k + 2 );\n  },\n\n  exponentialIn: function (k)\n  {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n\n  exponentialOut: function (k)\n  {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n\n  exponentialInOut: function (k)\n  {\n    if (k === 0) return 0;\n    if (k === 1) return 1;\n    if (( k *= 2 ) < 1) return 0.5 * Math.pow(1024, k - 1);\n    return 0.5 * ( -Math.pow(2, -10 * ( k - 1 )) + 2 );\n  },\n\n  circularIn: function ( k )\n  {\n    return 1 - Math.sqrt( 1 - k * k );\n  },\n\n  circularOut: function ( k )\n  {\n    return Math.sqrt( 1 - ( --k * k ) );\n  },\n\n  circularInOut: function (k)\n  {\n    if (( k *= 2 ) < 1) return -0.5 * ( Math.sqrt(1 - k * k) - 1);\n    return 0.5 * ( Math.sqrt(1 - ( k -= 2) * k) + 1);\n  },\n\n  elasticIn: function (k)\n  {\n\n    var s, a = 0.1, p = 0.4;\n    if (k === 0) return 0;\n    if (k === 1) return 1;\n    if (!a || a < 1)\n    {\n      a = 1;\n      s = p / 4;\n    }\n    else s = p * Math.asin(1 / a) / ( 2 * Math.PI );\n    return -( a * Math.pow(2, 10 * ( k -= 1 )) * Math.sin(( k - s ) * ( 2 * Math.PI ) / p) );\n\n  },\n\n  elasticOut: function (k)\n  {\n    var s, a = 0.1, p = 0.4;\n    if (k === 0) return 0;\n    if (k === 1) return 1;\n    if (!a || a < 1)\n    {\n      a = 1;\n      s = p / 4;\n    }\n    else s = p * Math.asin(1 / a) / ( 2 * Math.PI );\n    return ( a * Math.pow(2, -10 * k) * Math.sin(( k - s ) * ( 2 * Math.PI ) / p) + 1 );\n  },\n\n  elasticInOut: function (k)\n  {\n    var s, a = 0.1, p = 0.4;\n    if (k === 0) return 0;\n    if (k === 1) return 1;\n    if (!a || a < 1)\n    {\n      a = 1;\n      s = p / 4;\n    }\n    else s = p * Math.asin(1 / a) / ( 2 * Math.PI );\n    if (( k *= 2 ) < 1) return -0.5 * ( a * Math.pow(2, 10 * ( k -= 1 )) * Math.sin(( k - s ) * ( 2 * Math.PI ) / p) );\n    return a * Math.pow(2, -10 * ( k -= 1 )) * Math.sin(( k - s ) * ( 2 * Math.PI ) / p) * 0.5 + 1;\n  },\n\n  backIn: function (k)\n  {\n\n    var s = 1.70158;\n    return k * k * ( ( s + 1 ) * k - s );\n\n  },\n\n  backOut: function (k)\n  {\n    var s = 1.70158;\n    return --k * k * ( ( s + 1 ) * k + s ) + 1;\n  },\n\n  backInOut: function (k)\n  {\n    var s = 1.70158 * 1.525;\n    if (( k *= 2 ) < 1) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );\n    return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );\n  },\n\n  bounceIn: function (k)\n  {\n    return 1 - this.bounceOut(1 - k);\n  },\n\n  bounceOut: function (k)\n  {\n    if (k < ( 1 / 2.75 ))\n    {\n      return 7.5625 * k * k;\n    } else if (k < ( 2 / 2.75 ))\n    {\n      return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;\n    } else if (k < ( 2.5 / 2.75 ))\n    {\n      return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;\n    } else\n    {\n      return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;\n    }\n  },\n\n  bounceInOut: function (k)\n  {\n    if (k < 0.5) return this.bounceIn(k * 2) * 0.5;\n    return this.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n\n};\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n\npc.BaseImage = pc.Base.extend('pc.BaseImage',\n    {},\n    {\n      /** Width of the image; set upon loading, can be overridden after load */\n      width:0,\n      /** Height of the image; set upon loading, can be overridden after load */\n      height:0,\n      /** Source image element */\n      image:null,\n      /** x-scale to draw the image at */\n      scaleX:1,\n      /** y-scale to draw the image at */\n      scaleY:1,\n      /** alpha level to draw the image at (0.5=50% transparent) */\n      alpha:1,\n      /** Composite operation to draw the image with, e.g. 'lighter' */\n      compositeOperation:null,\n\n\n      /**\n       * Change the alpha level to draw the image at (0.5 = 50% transparent)\n       * @param {Number} a Alpha level\n       */\n      setAlpha:function (a)\n      {\n        this.alpha = a;\n      },\n\n      /**\n       * Change the x and/or y scale to draw the image at. If you want to scale an image to a particular size,\n       * just generate the scale by dividing one size by another, e.g. current image size 500, 500 and you want to\n       * scale to 750, 750, then do setScale( 750/500, 750/500 ).\n       * @param {Number} scaleX x-scale to draw at (2 = 200% wide, -1 = reversed normal on x)\n       * @param {Number} scaleY y-scale to draw at (2 = 200% high, -1 = reversed normal on y)\n       */\n      setScale:function (scaleX, scaleY)\n      {\n        this.scaleX = scaleX;\n        this.scaleY = scaleY;\n      },\n\n      /**\n       * Sets the componsite drawing operation for this image.\n       * @param {String} o Operation to use (e.g. 'lighter')\n       */\n      setCompositeOperation:function (o)\n      {\n        this.compositeOperation = o;\n      },\n\n      /**\n       * Draw the image onto a context\n       * @param {Context} ctx Context to draw the sprite image on\n       * @param {Number} sx Source position in the image (or detination x if only 3 params)\n       * @param {Number} sy Source position in the image (or destination y if only 3 params)\n       * @param {Number} x x-position destination x position to draw the image at\n       * @param {Number} y y-position destination y position to draw the image at\n       * @param {Number} width Width to draw (will clip the image edge)\n       * @param {Number} height Height to draw (will clip the image edge)\n       * @param {Number} rotationAngle Angle to draw the image at\n       */\n      draw:function (ctx, sx, sy, x, y, width, height, rotationAngle)\n      {\n        // scale testing\n        if (this.compositeOperation != null)\n          ctx.globalCompositeOperation = this.compositeOperation;\n\n        // simple version of draw, no source x, y, just draw the image at x, y\n        if (arguments.length == 3)\n        {\n          ctx.save();\n          if (this.alpha != 1)\n            ctx.globalAlpha = this.alpha;\n          ctx.translate(sx + (this.width / 2), sy + (this.height / 2));\n          ctx.scale(this.scaleX, this.scaleY);\n          ctx.drawImage(this.image, 0, 0, this.width, this.height, (-this.width / 2),\n              (-this.height / 2), this.width, this.height);\n          ctx.restore();\n        }\n        else\n        {\n          if (typeof(rotationAngle) == 'number' && rotationAngle != 0)\n          {\n            ctx.save();\n\n            if (this.alpha != 1)\n              ctx.globalAlpha = this.alpha;\n\n            ctx.translate(\n                x + (this.scaleX > 0 ? width/2 : 0),\n                y + (this.scaleY > 0 ? height/2 : 0)\n            );\n\n            ctx.rotate(rotationAngle * (Math.PI / 180));\n            ctx.scale(this.scaleX, this.scaleY);\n            ctx.drawImage(this.image, sx, sy, width, height, (-width / 2), (-height / 2), width, height);\n            ctx.restore();\n          }\n          else\n          {\n            ctx.save();\n\n            if (this.alpha != 1)\n              ctx.globalAlpha = this.alpha;\n\n            ctx.translate(\n                x + (this.scaleX < 0 ? width : 0),\n                y + (this.scaleY < 0 ? height : 0)\n            );\n\n            ctx.scale(this.scaleX, this.scaleY);\n            ctx.drawImage(this.image, sx, sy, width, height, 0, 0, width, height);\n            ctx.restore();\n          }\n        }\n\n        if (this.compositeOperation != null)\n          ctx.globalCompositeOperation = 'source-over';\n        pc.device.elementsDrawn++;\n\n      },\n\n\n    })\n/**\n * @class pc.Image\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * A basic image resource. You can use this class to acquire images (loaded from a URI) and then draw them on-screen\n * with effects such as scaling, rotation, compositing and alpha.<p>\n */\npc.Image = pc.BaseImage.extend('pc.Image',\n    /** @lends pc.Image */\n    {},\n    /** @lends pc.Image.prototype */\n    {\n        /** Source URI used to load the image */\n        src:null,\n        /** Resource name */\n        name:null,\n        /** Whether the image has been loaded yet */\n        loaded:false,\n        /** Optional function called after this image loads */\n        onLoadCallback:null,\n        /** Optional function called if this image fails to load */\n        onErrorCallback:null,\n\n        /**\n         * Constructs a new pc.Image. If the pc.device.loader has already started then the image will be\n         * immediately loaded, otherwise it will wait for the resource loader to handle the loading.\n         *\n         * Width and height will be set automatically on load.\n         *\n         * @param {String} name Name to give the image resource\n         * @param {String} src URI for the image\n         * @param {Function} onLoadCallback Function to be called once the image has been loaded\n         * @param {Function} onErrorCallback Function to be called if the image fails to load\n         */\n        init:function (name, src, onLoadCallback, onErrorCallback)\n        {\n            this._super();\n\n            this.name = name;\n            this.src = pc.device.loader.makeUrl(src);\n            this.image = new Image();\n\n            this.onLoadCallback = onLoadCallback;\n            this.onErrorCallback = onErrorCallback;\n\n            // setup our own handlers\n            this.image.onload = this._onLoad.bind(this);\n            this.image.onerror = this._onError.bind(this);\n            this.scaleX = 1;\n            this.scaleY = 1;\n            this.alpha = 1;\n\n            if (pc.device.loader.started) // load now if the loader has already been started\n                this.load();\n        },\n\n        /**\n         * Load an image directly\n         * @param {Function} onLoadCallback Function to be called once the image has been loaded\n         * @param {Function} onErrorCallback Function to be called if the image fails to load\n         */\n        load:function (onLoadCallback, onErrorCallback)\n        {\n            this.onLoadCallback = onLoadCallback;\n            this.onErrorCallback = onErrorCallback;\n\n            if (this.loaded && onLoadCallback) this.onLoadCallback(this);\n\n            this.image.onload = this._onLoad.bind(this);\n            this.image.onerror = this._onError.bind(this);\n            this.image.src = this.src;\n        },\n\n        /**\n         * Force this image to be reloaded\n         */\n        reload:function ()\n        {\n            this.loaded = false;\n            this.load();\n        },\n\n        _onLoad:function ()\n        {\n            this.loaded = true;\n\n            this.width = this.image.width;\n            this.height = this.image.height;\n\n            if (this.onLoadCallback)\n                this.onLoadCallback(this);\n        },\n\n        _onError:function ()\n        {\n            if (this.onErrorCallback)\n                this.onErrorCallback(this);\n        },\n\n        /**\n         * Expands the image by adding blank pixels to the bottom and side\n         * @param {Number} extraWidth Amount of width to add\n         * @param {Number} extraHeight Amount of height to add\n         */\n        expand:function (extraWidth, extraHeight)\n        {\n            this.image.width = this.width + extraWidth;\n            this.image.height = this.height + extraHeight;\n            this.width = this.image.width;\n            this.height = this.image.height;\n        },\n\n        /**\n         * Resizes an image using a given scale. This will create a new image internally, which can be\n         * expensive. Generally you should use setScale on the image to change it's size, which will let\n         * the hardware take care of it. If this is slow, or the results are not what you want, then you\n         * can use this method to do a nicer resize (but keep in mind it's slow and memory expensive)\n         * @param {Number} scaleX Scale to increase X by (can be negative)\n         * @param {Number} scaleY Scale to increase Y by (can be negative)\n         * @return {pc.Image} This image object\n         */\n        resize:function (scaleX, scaleY)\n        {\n            var sw = this.width * scaleX;\n            var sh = this.height * scaleY;\n\n            var startingImage = document.createElement('canvas');\n            startingImage.width = this.width;\n            startingImage.height = this.height;\n\n            var result = document.createElement('canvas');\n            result.width = sw;\n            result.height = sh;\n\n            var ctx = result.getContext('2d');\n            var resultPixels = ctx.getImageData(0, 0, sw, sh);\n\n            var startingCtx = startingImage.getContext('2d');\n            startingCtx.drawImage(this.image, 0, 0, this.width, this.height, 0, 0, this.width, this.height);\n            var startingPixels = startingCtx.getImageData(0, 0, this.width, this.height);\n\n            for (var y = 0; y < sh; y++)\n            {\n                for (var x = 0; x < sw; x++)\n                {\n                    var i = (Math.floor(y / scaleY) * this.width + Math.floor(x / scaleX)) * 4;\n                    var is = (y * sw + x) * 4;\n                    for (var j = 0; j < 4; j++)\n                        resultPixels.data[is + j] = startingPixels.data[i + j];\n                }\n            }\n\n            ctx.putImageData(resultPixels, 0, 0);\n            this.image = result;\n            return this;\n        }\n\n\n    });\n\n/**\n * A wrapper around a Canvas element supporting the same API as pc.Image.  It can\n * be used to render or pre-render graphics that can be used in APIs that expect an\n * Image object.\n */\npc.CanvasImage = pc.BaseImage.extend('pc.CanvasImage', {},\n    {\n\n        canvas:null,\n        loaded:true,\n\n        init:function (canvas)\n        {\n            this.canvas = this.image = canvas;\n            this.width = canvas.width;\n            this.height = canvas.height;\n            this.loaded = true;\n        },\n\n        draw:function (ctx, sx, sy, x, y, width, height, rotationAngle)\n        {\n            if (width == undefined || height == undefined || width == 0 || height == 0)\n                ctx.drawImage(this.canvas, sx, sy);\n            else {\n              if (pc.valid(rotationAngle))\n              {\n                ctx.save();\n\n                if (this.alpha != 1)\n                  ctx.globalAlpha = this.alpha;\n                if (this.scaleX < 0 || this.scaleY < 0)\n                {\n                  var yf = this.scaleY == 1 ? 0 : this.scaleY;\n                  var xf = this.scaleX == 1 ? 0 : this.scaleX;\n\n                  ctx.translate((x + (width / 2) * xf), (y + (height / 2) * yf));\n                } else\n                  ctx.translate(x + (width / 2), y + (height / 2));\n\n                ctx.rotate(rotationAngle * (Math.PI / 180));\n                ctx.scale(this.scaleX, this.scaleY);\n                ctx.drawImage(this.canvas, sx, sy, width, height, (-width / 2), (-height / 2), width, height);\n                ctx.restore();\n              }\n              else\n              {\n                ctx.save();\n\n                if (this.alpha != 1)\n                  ctx.globalAlpha = this.alpha;\n                if (this.scaleX < 0 || this.scaleY < 0)\n                {\n                  var yf2 = this.scaleY == 1 ? 0 : this.scaleY;\n                  var xf2 = this.scaleX == 1 ? 0 : this.scaleX;\n\n                  ctx.translate(x + (-(width / 2) * xf2), y + (-(height / 2) * yf2));\n                } else\n                  ctx.translate(x, y);\n\n                ctx.scale(this.scaleX, this.scaleY);\n                ctx.drawImage(this.canvas, sx, sy, width, height, 0, 0, width, height);\n                ctx.restore();\n              }\n            }\n        },\n\n        setScale:function (scaleX, scaleY)\n        {\n            this.scaleX = scaleX;\n            this.scaleY = scaleY;\n        }\n\n    });\n\n\npc.ImageTools = pc.Base.extend('pc.ImageTools',\n    {\n        /**\n         * Rotates an image by the given number of directions\n         * @param image Source image\n         * @param w Width of the image\n         * @param h Height of the image\n         * @param directions Number of directions you want back\n         * @return {pc.CanvasImage} A new pc.CanvasImage with the rotations\n         */\n        rotate:function (image, w, h, directions)\n        {\n            // create an destination canvas big enough\n            var resultCanvas = document.createElement('canvas');\n            resultCanvas.width = w * directions;\n            resultCanvas.height = h;\n\n            var ctx = resultCanvas.getContext('2d');\n\n            // find center of the source image\n            var cx = w / 2;\n            var cy = h / 2;\n\n            for (var d = 0; d < directions; d++)\n            {\n                ctx.save();\n                ctx.translate(d * w + (w / 2), h / 2);\n                ctx.rotate(((360 / directions) * d) * (Math.PI / 180));\n                ctx.drawImage(image, -(w / 2), -(h / 2));\n                ctx.restore();\n            }\n\n            return new pc.CanvasImage(resultCanvas);\n        }\n\n\n    },\n    {});\n\npc.Subimage = pc.BaseImage.extend('pc.Subimage', {},\n    {\n      /** X offset into the base image */\n      sourceX:0,\n      /** Y offset into the base image */\n      sourceY:0,\n\n      /** Base image */\n      baseImage:null,\n\n      init:function(baseImage, config) {\n        this.baseImage = baseImage;\n        this.loaded = true;\n        if(!pc.valid(baseImage)) throw new Error('Subimage without base image!');\n        this.sourceX = pc.checked(config.x, 0);\n        this.sourceY = pc.checked(config.y, 0);\n        this.width = pc.checked(config.w, 0);\n        this.height = pc.checked(config.h, 0);\n        this.scaleX = pc.checked(config.scaleX, 1.0);\n        this.scaleY = pc.checked(config.scaleY, 1.0);\n        this.alpha = pc.checked(config.alpha, 1.0);\n        if(!baseImage.loaded) console.log(\"Warning: Subimage of not-loaded image\");\n        this.compositeOperation = pc.checked(config.compositeOperation, null);\n      },\n\n      /**\n       * Change the alpha level to draw the image at (0.5 = 50% transparent)\n       * @param {Number} a Alpha level\n       */\n      setAlpha:function (a)\n      {\n        this.alpha = a;\n      },\n\n      /**\n       * Change the x and/or y scale to draw the image at. If you want to scale an image to a particular size,\n       * just generate the scale by dividing one size by another, e.g. current image size 500, 500 and you want to\n       * scale to 750, 750, then do setScale( 750/500, 750/500 ).\n       * @param {Number} scaleX x-scale to draw at (2 = 200% wide, -1 = reversed normal on x)\n       * @param {Number} scaleY y-scale to draw at (2 = 200% high, -1 = reversed normal on y)\n       */\n      setScale:function (scaleX, scaleY)\n      {\n        this.scaleX = scaleX;\n        this.scaleY = scaleY;\n      },\n\n      /**\n       * Sets the componsite drawing operation for this image.\n       * @param {String} o Operation to use (e.g. 'lighter')\n       */\n      setCompositeOperation:function (o)\n      {\n        this.compositeOperation = o;\n      },\n\n      /**\n       * Draw the image onto a context\n       * @param {Context} ctx Context to draw the sprite image on\n       * @param {Number} sx Source position in the image (or detination x if only 3 params)\n       * @param {Number} sy Source position in the image (or destination y if only 3 params)\n       * @param {Number} x x-position destination x position to draw the image at\n       * @param {Number} y y-position destination y position to draw the image at\n       * @param {Number} width Width to draw (will clip the image edge)\n       * @param {Number} height Height to draw (will clip the image edge)\n       * @param {Number} rotationAngle Angle to draw the image at\n       */\n      draw:function (ctx, sx, sy, x, y, width, height, rotationAngle)\n      {\n        if (!this.baseImage.loaded) return;\n\n        if (this.scaleX != 1 || this.scaleY != 1)\n          this.baseImage.setScale(this.scaleX, this.scaleY);\n\n        if (this.alpha != 1)\n          this.baseImage.setAlpha(this.alpha);\n\n        if (this.compositeOperation != null)\n          this.baseImage.setCompositeOperation(this.compositeOperation);\n\n        if(arguments.length == 3) {\n          this.baseImage.draw(ctx, this.sourceX, this.sourceY, sx, sy, this.width, this.height, rotationAngle);\n        } else {\n          this.baseImage.draw(ctx, this.sourceX+sx, this.sourceY+sy, x, y,\n              Math.min(width, this.width-sx),\n              Math.min(height, this.height-sy),\n              rotationAngle);\n        }\n\n        // restore scaling (as images can be used amongst spritesheets, we need to be nice)\n        if (this.scaleX != 1 || this.scaleY != 1)\n          this.baseImage.setScale(1, 1);\n\n        // set the alpha back to normal\n        if (this.alpha != 1)\n          this.baseImage.setAlpha(1);\n\n        if (this.compositeOperation != null)\n          this.baseImage.setCompositeOperation('source-over');\n      }\n});",
    "/**\n * Playcraft Engine - (c) 2011 Playcraft Labs, inc.\n */\n\n/**\n * @class pc.Scene\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * A game is primarily a container for various \"scenes\", with each scene containing one or more layers. You can\n * construct a scene, and use addScene to add it to the game. This is typically done once all the queued resources\n * have been loaded:\n * <pre><code>\n * onLoaded:function ()\n * {\n *    // construct the game scene\n *    this.gameScene = new GameScene();\n *\n *    // add it to the game\n *    this.addScene(this.gameScene);\n * }\n * </code></pre>\n * Active scenes will be updated and drawn by the system, inactive ones will not. Adding a scene makes it active by\n * default.\n * <p>\n * To activate a scene (such as displaying a menu scene):\n * <pre><code>\n * myGame.activateScene(myMenuScene);\n * </code></pre>\n * You can likewise deactivate a scene (it will no longer be rendered or processed):\n * <pre><code>\n * myGame.deactivateScene(myMenuScene);\n * </code></pre>\n * Upon activating a scene, the game's onSceneActivated is called passing in the scene that became active. Likewise\n * onSceneDeactivated will be called when a scene is deactivated.\n * <p>\n * You can access scenes by calling getFirstScene or getFirstActiveScene which will return a pc.LinkedListNode you can\n * use to loop through the list of scenes:\n * <pre><code>\n * var sceneNode = myGame.getFirstScene();\n * while (sceneNode)\n * {\n *    var scene = sceneNode.object();\n *    // scene.doSomething();\n *\n *    // move to the next one (will be null if done)\n *    sceneNode = sceneNode.next();\n * }\n * </code></pre>\n */\npc.Scene = pc.Base.extend('pc.Scene',\n    /** @lends pc.Scene */\n    {},\n    /** @lends pc.Scene.prototype */\n    {\n        /** Name of the scene */\n        name:null,\n        /** An index of layers by name */\n        layersByName:null,\n        /** Linked list of all layers in the scene */\n        layers:null,\n        /** Linked list of all active layers */\n        activeLayers:null,\n        /** Whether the scene is currently paused (read-only) */\n        paused:false,\n        /** Whether the scene is active (read-only) */\n        active:false,\n        /** pc.Rect of the current viewport */\n        viewPort: null,\n\n        viewPortCenter: null, // readonly, changes when you call setViewPort\n\n        /**\n         * Constructs a new scene with the given name\n         * @param {String} name Name of the scene, i.e. 'menu'\n         */\n        init:function (name)\n        {\n            this._super();\n            this.active = false;\n            this.name = name;\n            this.layersByName = new pc.Hashtable();\n            this.layers = new pc.LinkedList();\n            this.activeLayers = new pc.LinkedList();\n\n            this.viewPort = pc.Rect.create(0, 0, 0, 0); // set by setViewPort below\n            this.viewPortCenter = pc.Point.create(0, 0);\n\n            // set the view port to be the default size of the system canvas\n            this.setViewPort(0, 0, pc.device.canvasWidth, pc.device.canvasHeight);\n\n            // if the system has already started, then automatically call the onReady\n            if (pc.device.started)\n                this.onReady();\n        },\n\n        /**\n         * Called when the device is ready\n         */\n        onReady:function ()\n        {\n            // signal all the layers that we're ready\n            var next = this.layers.first;\n            while (next)\n            {\n                next.obj.onReady();\n                next = next.next();\n            }\n        },\n\n        /**\n         * Called when this scene is being activated\n         */\n        onActivated:function ()\n        {\n        },\n\n        /**\n         * Called when this scene has been deactivated\n         */\n        onDeactivated:function ()\n        {\n        },\n\n        /**\n         * Event notifier when the underlying game canvas is being resized\n         * @param {Number} width New width of the game canvas\n         * @param {Number} height New height of the game canvas\n         */\n        onResize:function (width, height)\n        {\n            this.setViewPort(this.viewPort.x, this.viewPort.y, width, height);\n\n            var next = this.layers.first;\n            while (next)\n            {\n                next.obj.onResize(width, height);\n                next = next.next();\n            }\n        },\n\n        /**\n         * Sets the view port to the given top left postion (x, y) and dimensions (width and height)\n         * The view port represents the on-screen pixels dimensions of the game relative to the\n         * associated canvas. Use the view port dimensions to render different scenes at different\n         * positions on screen. e.g. a game layer would typically be 0, 0, canvas.width, canvas.height\n         * whereas a mini map may just be in the top left corner of the screen (0, 0, 100, 100).\n         * @param {Number} x X position to render the scene within the canvas (in screen pixels)\n         * @param {Number} y Y position to render the scene within the canvas (in screen pixels)\n         * @param {Number} width The maximum width to render (in screen pixels)\n         * @param {Number} height The maximum height to render (in screen pixels)\n         */\n        setViewPort:function (x, y, width, height)\n        {\n            this.viewPort.x = x;\n            this.viewPort.y = y;\n            this.viewPort.w = width;\n            this.viewPort.h = height;\n            this.viewPortCenter.x = this.viewPort.w / 2;\n            this.viewPortCenter.y = this.viewPort.h / 2;\n        },\n\n        /**\n         * Gets the current viewport (essentially an alias for viewPort used by abstract interfaces (such as\n         * the input system). You can use it to if you want to write generic code that again layers, scenes and\n         * entities, since this method is the same across all. Otherwise you can just read the viewport member\n         * directly.\n         */\n        getScreenRect:function ()\n        {\n            return this.viewPort;\n        },\n\n        /**\n         * Resorts layer processing/drawing order based on each layers zIndex value\n         */\n        sortLayers: function()\n        {\n            this.activeLayers.sort(\n                function(a, b)\n                {\n                    return a.zIndex - b.zIndex;\n                });\n        },\n\n        /**\n         * Fired when a bound event/action is triggered in the input system. Use bindAction\n         * to set one up. Override this in your subclass to do something about it.\n         * @param {String} actionName The name of the action that happened\n         * @param {Event} event Raw event object\n         * @param {pc.Point} pos Position, such as a touch input or mouse position\n         */\n        onAction:function (actionName, event, pos)\n        {\n        },\n\n        /**\n         * Gets whether the scene is active or not\n         * @return {Boolean} True if active\n         */\n        isActive:function ()\n        {\n            return this.active;\n        },\n\n        /**\n         * Gets a layer using a name\n         * @param {String} name Name of the layer you want\n         * @return {pc.Layer} The layer\n         */\n        get:function (name)\n        {\n            return this.layersByName.get(name);\n        },\n\n        /**\n         * Adds a layer to the scene. The added layer will automatically be made active.\n         * @param {pc.Layer} layer Layer you want to add\n         * @return {pc.Layer} The layer you added, for convenience.\n         */\n        addLayer:function (layer)\n        {\n            if (!pc.valid(layer))\n                throw \"Error: invalid layer\";\n            if (!pc.valid(layer.name))\n                throw \"Error: trying to add a layer that has no name (forget to call this._super in your layer init?)\";\n\n            this.layersByName.put(layer.name, layer);\n            this.layers.add(layer);\n            this.activeLayers.add(layer);\n            layer.active = true;\n            layer.scene = this;\n            layer.onAddedToScene();\n            this.sortLayers();\n\n            return layer;\n        },\n\n        /**\n         * Remove a layer\n         * @param {pc.Layer} layer The layer you want to remove\n         */\n        removeLayer:function (layer)\n        {\n            this.layersByName.remove(layer.name);\n            this.layers.remove(layer);\n            this.activeLayers.remove(layer);\n            layer.active = false;\n            layer.scene = null;\n            layer.onRemovedFromScene();\n        },\n\n        /**\n         * Sets the layer to active\n         * @param {pc.Layer} layer Layer you want to make active\n         */\n        setLayerActive:function (layer)\n        {\n            this.activeLayers.add(layer);\n            this.sortLayers();\n            layer.active = true;\n        },\n\n        /**\n         * Sets the layer to inactive\n         * @param {pc.Layer} layer Layer you want to make inactive\n         */\n        setLayerInactive:function (layer)\n        {\n            this.activeLayers.remove(layer);\n            layer.active = false;\n        },\n\n        /**\n         * Toggles a layer to active or inactive\n         * @param {pc.Layer} layer Layer you want to toggle\n         */\n        toggleLayerActive: function(layer)\n        {\n            if (layer.active)\n                this.setLayerInactive(layer);\n            else\n                this.setLayerActive(layer);\n        },\n\n        /**\n         * Gets the linked list node of the first active layer\n         * @return {pc.LinkedListNode} Node pointing to the first layer\n         */\n        getFirstActiveLayer:function ()\n        {\n            return this.activeLayers.first;\n        },\n\n        /**\n         * Gets the linked list node of the first layer\n         * @return {pc.LinkedListNode} Node pointing to the first layer\n         */\n        getFirstLayer:function ()\n        {\n            return this.layers.first;\n        },\n\n        //\n        // LIFECYCLE\n        //\n        startTime: 0,\n\n        process:function ()\n        {\n            // draw all the layers\n            var next = this.activeLayers.first;\n            while (next)\n            {\n                if (!next.obj.paused)\n                {\n                    next.obj.process();\n\n                    this.startTime = Date.now();\n                    next.obj.draw();\n                    pc.device.lastDrawMS += (Date.now() - this.startTime);\n                }\n                next = next.next();\n            }\n        },\n\n        /**\n         * Pauses all active layers\n         */\n        pause:function ()\n        {\n            this.paused = true;\n            var next = this.activeLayers.first;\n            while (next)\n            {\n                next.obj.pause();\n                next = next.next();\n            }\n        },\n\n        /**\n         * Resumes all active layers\n         */\n        resume:function ()\n        {\n            this.paused = false;\n            var next = this.activeLayers.first;\n            while (next)\n            {\n                next.obj.resume();\n                next = next.next();\n            }\n        },\n\n        /**\n         * Resets all layers\n         */\n        reset:function ()\n        {\n            var next = this.layers.first;\n            while (next)\n            {\n                next.obj.reset();\n                next = next.next();\n            }\n\n            this.layers.clear();\n            this.activeLayers.clear();\n        },\n\n        /**\n         * Ask all the layers etc for any entities under the x, y position\n         * @param {Number} x the screen x position\n         * @param {Number} y the screen y position\n         */\n        entitiesUnderXY:function (x, y)\n        {\n            var found = [];\n            var next = this.layers.first;\n            while (next)\n            {\n                found.push(next.obj.entitiesUnderXY(x, y));\n                next = next.next();\n            }\n        },\n\n\n        /**\n         * Loads all of the layers from a Tiled (TMX) map file. Tile layers will become instances of\n         * TileLayer, objectgroups will become EntityLayers. Tile sets must have a name that matches an\n         * available spritesheet image resource. Note that only a single tilesheet is currently supported.\n         * @param {String} levelData XML formatted TMX data\n         */\n        loadFromTMX:function (levelData, entityFactory)\n        {\n            var xmlDoc = pc.device.parseXML(levelData.data);\n            var mapXML = xmlDoc.getElementsByTagName('map')[0];\n\n            var tileWidth = parseInt(mapXML.getAttribute('tilewidth'));\n            var tileHeight = parseInt(mapXML.getAttribute('tileheight'));\n\n            //\n            // TILESETS\n            //\n            var tileSets = [];\n            var tileSetNodes = xmlDoc.getElementsByTagName('tileset');\n            for(var i=0; i < tileSetNodes.length; i++) {\n              var tileSetXML = tileSetNodes[i];\n              var tsName = tileSetXML.getAttribute('name');\n              var tsImageWidth = tileSetXML.getAttribute('width');\n              var tsImageHeight = tileSetXML.getAttribute('height');\n              var tsTileWidth = pc.checked(tileSetXML.getAttribute('tilewidth'), tileWidth);\n              var tsTileHeight = pc.checked(tileSetXML.getAttribute('tileheight'), tileHeight);\n              var tsIdOffset = parseInt(pc.checked(tileSetXML.getAttribute('firstgid'), '1'))-1;\n              var tileSheetLoaderItem = pc.device.loader.get(tsName);\n              pc.assert(tileSheetLoaderItem, 'Unable to locate tile image resource: ' + tsName + '. It must match the tileset name in tiled.');\n\n              var tsImageResource = tileSheetLoaderItem.resource;\n              var tsSpriteSheet = new pc.SpriteSheet({ image:tsImageResource, frameWidth:tsTileWidth, frameHeight:tsTileHeight });\n\n\n              // create a tileset object which marries (one or more spritesheet's) and contains tileproperty data\n              // pulled from tiled\n\n              var tileSet = new pc.TileSet(tsSpriteSheet, 0,0, tsIdOffset);\n              tileSets.push(tileSet);\n\n              // load all the tile properties\n              var tiles = tileSetXML.getElementsByTagName('tile');\n              for (var p = 0; p < tiles.length; p++)\n              {\n                var tile = tiles[p];\n                var tileId = parseInt(tile.getAttribute('id'));\n\n                var pr = tile.getElementsByTagName('properties')[0];\n                if(pr)\n                {\n                  var props = pr.getElementsByTagName('property');\n\n                  for (var b = 0; b < props.length; b++)\n                  {\n                    var prop = props[b];\n                    var name = prop.getAttribute('name');\n                    var value = prop.getAttribute('value');\n                    tileSet.addProperty(tileId + tsIdOffset, name, value);\n                  }\n                }\n              }\n            }\n\n\n            //\n            // LAYERS\n            //\n            var layers = xmlDoc.getElementsByTagName('layer');\n            for (var m = 0; m < layers.length; m++)\n            {\n                switch(mapXML.getAttribute('orientation')) {\n                    case 'isometric':\n                        pc.IsoTileLayer.loadFromTMX(this, layers[m], tileWidth, tileHeight, tileSets);\n                    break;\n\n                    default:\n                        pc.TileLayer.loadFromTMX(this, layers[m], tileWidth, tileHeight, tileSets);\n                    break;\n                }\n            }\n\n            // load entity layers\n            var objectGroups = xmlDoc.getElementsByTagName('objectgroup');\n            for (var i = 0; i < objectGroups.length; i++)\n            {\n                // partial construction\n\n                // fill in the rest using the data from the TMX file\n                var group = objectGroups[i];\n                var tilesWide = parseInt(group.getAttribute('width'));\n                var tilesHigh = parseInt(group.getAttribute('height'));\n                pc.EntityLayer.loadFromTMX(this, group, entityFactory, tilesWide*tileWidth, tilesHigh*tileHeight);\n            }\n\n            for(var next = this.layers.first; next; next = next.next())\n            {\n                var layer = next.obj;\n                if(layer.originTrackName) {\n                    layer.originTrack = this.get(layer.originTrackName);\n                    layer.originTrackName = null;\n                }\n            }\n        },\n\n        /**\n         * Load tilemap and tilesets from a Javascript object as\n         * exported by the Tiled map editor when you export to\n         * JSON or JSONP.\n         */\n        loadFromJson: function(info, entityFactory)\n        {\n          var tileWidth = info.tileheight;\n          var tileHeight = info.tilewidth;\n\n          var tileSets = []\n          info.tilesets.forEach(function(ts) {\n            var tsName = (ts.properties.resourceName || ts.name);\n            var tsImageWidth = ts.imagewidth;\n            var tsImageHeight = ts.imageheight;\n            var tsTileWidth = ts.tilewidth;\n            var tsTileHeight = ts.tileheight;\n            var tsIdOffset = ts.firstgid-1;\n            tileSheetLoaderItem = pc.device.loader.get(tsName);\n            pc.assert(tileSheetLoaderItem, 'Unable to locate tile image resource: ' + tsName + '. It must match the tileset name in tiled.');\n\n            var tsImageResource = tileSheetLoaderItem.resource;\n            var tsSpriteSheet = new pc.SpriteSheet({ image:tsImageResource, frameWidth:tsTileWidth, frameHeight:tsTileHeight });\n\n\n            // create a tileset object which marries (one or more spritesheet's) and contains tileproperty data\n            // pulled from tiled\n            var tileSet = new pc.TileSet(tsSpriteSheet, 0,0, tsIdOffset);\n            tileSets.push(tileSet);\n\n            if('tileproperties' in tileSet) {\n              var props = tileSet.tileproperties;\n              for(var idStr in  props) {\n                if(!props.hasOwnProperty(idStr)) continue;\n                var tileId = parseInt(idStr);\n                tileProperties = props[idStr];\n                for(var name in tileProperties) {\n                  if(!tileProperties.hasOwnProperty(name)) continue;\n                  tileSet.addProperty(tileId + tsIdOffset, name, tileProperties[name]);\n                }\n              }\n            }\n          }, this);\n\n          info.layers.forEach(function(lyr) {\n            switch(lyr.type) {\n              case 'tilelayer':\n                switch(info.orientation) {\n                  case 'isometric':\n                    pc.IsoTileLayer.loadFromJson(this, lyr, tileWidth, tileHeight, tileSets);\n                    break;\n\n                  default:\n                    pc.TileLayer.loadFromJson(this, lyr, tileWidth, tileHeight, tileSets);\n                    break;\n                }\n                break;\n\n              case 'imagelayer':\n                pc.ImageLayer.loadFromJson(this, lyr)\n                break;\n\n              case 'objectgroup':\n                pc.EntityLayer.loadFromJson(this, lyr, entityFactory, lyr.width*tileWidth, lyr.height*tileHeight);\n                break;\n\n              default:\n                console.log('Warning: fould tiled map layer of unsupported type: '+lyr.type);\n                break;\n\n            }\n          }, this);\n\n          for(var next = this.layers.first; next; next = next.next())\n          {\n            var layer = next.obj;\n            if(layer.originTrackName)\n            {\n              layer.originTrack = this.get(layer.originTrackName);\n              layer.originTrackName = null;\n            }\n          }\n        }\n    });\n",
    "/**\n * Playcraft Engine\n * game.js - Copyright 2012 Playcraft Labs, Inc. (see licence.txt)\n */\n\n/**\n * @class pc.Game\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * pc.Game is the primary base class for creating a game and drives resources, core processing (cycling) your\n * game, and serves as a placeholder for scenes.\n * <h5>Basic Usage</h5>\n * <p>\n * Typically a pc.Game is constructed by the pc.start method call made from within your games index.html:\n * <pre><code>\n * &ltscript&gt\n *    // pc.start will construct an instance of TheGame once the device (browser) is ready\n *    pc.start('pcGameCanvas', 'TheGame', '/mygame/js/', ['mygame.js']);\n * &lt/script&gt\n * </code></pre>\n * When the pc.start system has finished preparing everything, it will dynamically construct an instance of\n * the class parameter (in the above example 'TheGame'). You can always gain access to the game from the global\n * pc.device:\n * <pre><code>\n * var myGame = pc.device.game;\n * </code></pre>\n * <p>\n * To create a pc.Game, extend it and override what you need:\n * <pre><code>\n * TheGame = pc.Game.extend('TheGame',\n * {},\n * {\n *     // onReady is called when the browser DOM is ready\n *     onReady:function ()\n *     {\n *         this._super();\n *\n *         // load resources\n *         // declare a base URL; saves you typing\n *         pc.device.loader.setBaseUrl('images/');\n *\n *         // add an image to the resource loader's queue\n *         pc.device.loader.add(new pc.Image('player-ship', 'ship1.png'));\n *\n *         // start the resource loader\n *         pc.device.loader.start(this.onLoading.bind(this), this.onLoaded.bind(this));\n *     },\n *\n *     onLoading:function (percentageComplete)\n *     {\n *         // draw title screen -- with loading bar\n *     }\n *\n * });\n * </code></pre>\n * See the pc.Loader for more information on using the resource loader and the onLoading/onLoaded callbacks.\n * <p>\n\n * <h5>Pause/Resume</h5>\n * <p>\n * You can pause/resume individual scenes, or you can pause/resume all scenes by calling pause on the game:\n * <pre><code>\n * myGame.pause();\n * myGame.resume();\n * myGame.togglePauseResume();\n * </code></pre>\n *\n * <h5>Debugging</h5>\n * pc.Game sets up the following default input keys for debugging:\n * <ul>\n *     <li>F9 to enable/disable physics debugging across all layers.</li>\n *     <li>F10 to dump stats on the object pools.</li>\n *     <li>F11 toggle sound.</li>\n * </ul>\n */\n\npc.Game = pc.Base.extend('pc.Game', {},\n    /** @lends pc.Game.prototype */\n    {\n        /** (pc.LinkedList) List of all scenes in the game */\n        scenes:null,\n        /** (pc.LinkedList) List of scenes current active */\n        activeScenes:null,\n        /** (Boolean) Whether the game is currently paused. You can theGame.paused=true; to suspend all scenes **/\n        paused:false,\n\n        /**\n         * Constructs a new game object\n         */\n        init:function ()\n        {\n            this._super();\n\n            this.scenes = new pc.LinkedList();\n            this.activeScenes = new pc.LinkedList();\n\n            if (pc.device.devMode)\n            {\n                // bind some special keys for general debugging use\n                pc.device.input.bindAction(this, 'physics debug', 'F9');\n                pc.device.input.bindAction(this, 'pool dump', 'F10');\n                pc.device.input.bindAction(this, 'toggle sound', 'F11');\n            }\n        },\n\n        /**\n         * Processes all active scenes (called automatically by pc.Device.cycle)\n         * @return {Boolean} false indicates the device should stop running the game loop\n         */\n        process:function ()\n        {\n            if (this.paused) return true;\n\n            var scene = this.getFirstActiveScene();\n            while (scene)\n            {\n                scene.object().process();\n                scene = scene.next();\n            }\n\n            return true; // return false to quit the update loop\n        },\n\n        stopAllSounds: function()\n        {\n            // stop any current sounds from playing\n            var sounds = pc.device.loader.getAllSounds();\n            for (var i = 0; i < sounds.length; i++)\n            {\n                if (pc.device.soundEnabled)\n                    sounds[i].stop();\n            }\n        },\n\n        /**\n         * Base handler for input actions. This gives the game a chance to intercept and act on actions like\n         * F9 and F10 for debugging. See pc.Input for more information on input handlers\n         * @param {String} actionName Name of the action to be handled\n         */\n        onAction:function (actionName)\n        {\n            if (actionName === 'toggle sound')\n            {\n                this.stopAllSounds();\n                // toggle the sound\n                pc.device.soundEnabled = !pc.device.soundEnabled;\n            }\n\n            if (actionName === 'pool dump')\n            {\n                console.log(pc.Pool.getStats());\n            }\n\n            if (actionName === 'physics debug')\n            {\n                // find all physics systems, and toggle debug\n                var sceneNode = this.getFirstScene();\n                while (sceneNode)\n                {\n                    var layerNode = sceneNode.object().getFirstActiveLayer();\n                    while (layerNode)\n                    {\n                        var layer = layerNode.object();\n                        if (layer.Class.isA('pc.EntityLayer'))\n                        {\n                            var systemNode = layer.systemManager.systems.first;\n                            while (systemNode)\n                            {\n                                var system = systemNode.object();\n                                if (system.Class.isA('pc.systems.Physics'))\n                                    system.setDebug(!system.debug);\n                                systemNode = systemNode.next();\n                            }\n                        }\n                        layerNode = layerNode.next();\n                    }\n                    sceneNode = sceneNode.next();\n                }\n\n            }\n        },\n\n        //\n        // SCENES\n        //\n        /**\n         * Add a scene to the game. Automatically makes the scene active. Once added, the game's onSceneAdded method\n         * will be called.\n         * @param {pc.Scene} scene Scene to add\n         * @param {boolean} [activate=true] Make the scene active on adding it\n         */\n        addScene:function (scene, activate)\n        {\n            this.scenes.add(scene);\n            this.onSceneAdded(scene);\n            if (pc.checked(activate, true))\n                this.activateScene(scene);\n        },\n\n        /**\n         * Called whenever a scene is added to the game. Useful for handling setup or detecting when new scenes are\n         * being added.\n         * @param {pc.Scene} scene Scene that was added\n         */\n        onSceneAdded:function (scene)\n        {\n        },\n\n        /**\n         * Removes a scene from the game. Will trigger a notifier call to onSceneRemoved\n         * @param {pc.Scene} scene Scene to remove\n         */\n        removeScene:function (scene)\n        {\n            this.scenes.remove(scene);\n            this.activeScenes.remove(scene);\n            this.onSceneRemoved(scene);\n        },\n\n        /**\n         * Notifier callback when a scene is removed from this game\n         * @param {pc.Scene} scene Scene being removed\n         */\n        onSceneRemoved:function (scene)\n        {\n        },\n\n        /**\n         * Activates a scene (it will be rendered and processed)\n         * @param {pc.Scene} scene Scene you want to make active\n         */\n        activateScene:function (scene)\n        {\n            if (scene.active) return;\n\n            this.activeScenes.add(scene);\n            scene.active = true;\n            this.onSceneActivated(scene);\n            scene.onActivated();\n        },\n\n        /**\n         * Called when a scene has been activated.\n         * @param {pc.Scene} scene Scene that has been activated.\n         */\n        onSceneActivated:function (scene)\n        {\n        },\n\n        /**\n         * Deactivate a given scene\n         * @param {pc.Scene} scene Scene to deactivate\n         */\n        deactivateScene:function (scene)\n        {\n            if (!scene.active) return;\n\n            this.activeScenes.remove(scene);\n            scene.active = false;\n            this.onSceneDeactivated(scene);\n            scene.onDeactivated();\n        },\n\n        /**\n         * Called when a scene has been deactviated\n         * @param {pc.Scene} scene Scene that was deactivated\n         */\n        onSceneDeactivated:function (scene)\n        {\n        },\n\n        /**\n         * Get the first active scene from the active scenes linked list\n         * @return {pc.LinkedNode} Linked list node pointing to the first active scene (use getFirstActiveScene().object())\n         * to get the scene.\n         */\n        getFirstActiveScene:function ()\n        {\n            return this.activeScenes.first;\n        },\n\n        /**\n         * Get the first scene from the scene linkedlist\n         * @return {pc.LinkedNode} Linked node pointing to the first scene\n         */\n        getFirstScene:function ()\n        {\n            return this.scenes.first;\n        },\n\n        //\n        // lifecycle\n        //\n\n        /**\n         * Pauses all scenes, which means no drawing or updates will occur. If you wish to pause game play and leave a menu\n         * still running, then just pause the scene associated with game play, and not the menu scenes.\n         */\n        pause:function ()\n        {\n            this.paused = true;\n\n            var nextScene = this.getFirstScene();\n            while (nextScene)\n            {\n                nextScene.object().pause();\n                nextScene = nextScene.next();\n            }\n        },\n\n        /**\n         * @return {Boolean} True is the game is active (not paused)\n         */\n        isActive:function ()\n        {\n            return !this.paused;\n        },\n\n        /**\n         * Resumes all scenes (after being paused)\n         */\n        resume:function ()\n        {\n            this.paused = false;\n\n            var nextScene = this.getFirstScene();\n            while (nextScene)\n            {\n                nextScene.object().resume();\n                nextScene = nextScene.next();\n            }\n        },\n\n        /**\n         * Toggles pause/resume of the game\n         */\n        togglePauseResume:function ()\n        {\n            if (pc.device.game.paused)\n                pc.device.game.resume();\n            else\n                pc.device.game.pause();\n        },\n\n        /**\n         * Resets all scenes back to their starting state (by calling reset() on all scenes), then calling\n         * clear() on all scenes, before finally calling the game class onReady\n         */\n        reset:function ()\n        {\n            // clear all scenes, layers, entities\n            var nextScene = this.getFirstScene();\n            while (nextScene)\n            {\n                nextScene.obj.reset();\n                nextScene = nextScene.next();\n            }\n\n            this.scenes.clear();\n            this.activeScenes.clear();\n\n            // then restart the game\n            this.onReady();\n        },\n\n        /**\n         * Called by the pc.Device when the game is ready to be started (also called when a reset() is done)\n         */\n        onReady:function ()\n        {\n        },\n\n        /**\n         * Called when the device canvas changes size (such as when a browser is resized)\n         * @param width Width of the canvas\n         * @param height Height of the canvas\n         */\n        onResize:function (width, height)\n        {\n            var nextScene = this.getFirstActiveScene();\n            while (nextScene)\n            {\n                nextScene.obj.onResize(width, height);\n                nextScene = nextScene.next();\n            }\n        },\n\n        /**\n         * Convenience fucntion to grab the size of the associated device screen\n         * @return {pc.Rect} Rectangle of the current canvas\n         */\n        getScreenRect:function ()\n        {\n            return pc.Rect.create(0, 0, pc.device.canvasWidth, pc.device.canvasHeight);\n        }\n\n\n    });\n\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.Loader\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * The Loader takes care of loading resources (downloading) and then notifying you when everything\n * is ready. The loader is a static class that will always be constructed by the engine and accessible through th\n * pc.device.loader member.\n * <p>\n * Using the loader you can load <a href='pc.Image'>pc.Image</a>'s, <a href='pc.DataResource'>pc.DataResources</a>'s,\n * and <a href='pc.Sound'>pc.Sound</a>'s.\n * <p>\n * Typically you use the loader from within your game class onReady method (called automatically by the engine).\n * <pre><code>\n * TheGame = pc.Game.extend('TheGame',\n * {},\n * {\n *     onReady:function ()\n *     {\n *         this._super(); // call the base class' onReady\n *\n *         // disable caching when developing\n *         if (pc.device.devMode)\n *             pc.device.loader.setDisableCache();\n *\n *         // load up resources\n *         pc.device.loader.add(new pc.Image('spaceship', 'images/spaceship.png'));\n *\n *         // fire up the loader (with a callback once done)\n *         pc.device.loader.start(this.onLoading.bind(this), this.onLoaded.bind(this));\n *     },\n *\n *     onLoading:function (percentageComplete)\n *     {\n *         // display progress, such as a loading bar\n *     },\n *\n *     onLoaded:function ()\n *     {\n *         // we're ready; make the magic happen\n *     }\n * });\n * </code></pre>\n * You can disable caching using setDisableCache. This is the default when in devMode (when the engine has not been\n * packed/minified.\n */\n\npc.Loader = pc.Base.extend('pc.Loader',\n    {},\n    /** @lends pc.Loader.prototype */\n    {\n        State:{ QUEUED:0, LOADING:1, READY:2, FAILED:3 },\n\n        /** A hashtable of all the resources, keyed by the resource name */\n        resources:new pc.Hashtable(),\n        /** Function called after each new resource has been loaded */\n        loadingListener:null,\n        /** Function called after all resources have been loaded or errored */\n        loadedListener:null,\n        /** Progress of the loader (number of items loaded so far) */\n        progress:0,\n        /** Total number of resources to be loaded */\n        totalBeingLoaded:0,\n        /** Number of resources that had a problem */\n        errored:0,\n        /** Optional baseURI prepended to resource URI's */\n        baseUrl:'',\n\n        /**\n         * True if loader.start() has been called. Typically resources use this to check\n         * if they should just load immediately (after game start) or hold on loading until the loader calls (triggered\n         * by loader.start()\n         */\n        started:false,\n        /** True if the resource loader has finished loading everything */\n        finished:false,\n\n        _noCacheString:'',\n\n        /**\n         * Constructor -- typically called by the engine to automatically construct pc.device.loader.\n         */\n        init:function ()\n        {\n            this._super();\n        },\n\n        /**\n         * Tells the resource loader to disable caching in the browser by modifying the resource src\n         * by appending the current date/time\n         */\n        setDisableCache:function ()\n        {\n            this._noCacheString = '?nocache=' + Date.now();\n        },\n\n        /**\n         * Sets a base URI to save you type. Applies to all resources added until the next setBaseURL is called.\n         * @param {String} url URI to prepend\n         */\n        setBaseUrl:function (url)\n        {\n            this.baseUrl = url;\n        },\n\n        /**\n         * Sets an optional listener\n         * @param {Function} loadingListener Function to call when each resource is loaded\n         * @param {Function} loadedListener Function to call when all resources have been loaded\n         */\n        setListener:function (loadingListener, loadedListener)\n        {\n            this.loadingListener = loadingListener;\n            this.loadedListener = loadedListener;\n        },\n\n        /**\n         * Add a resource to the loader queue\n         * @param {pc.Image|pc.Sound|pc.DataResource} resource Resource to load\n         */\n        add:function (resource)\n        {\n            // resource.src already has the baseUrl set by the resource class (i.e. pc.Image)\n            // so no need to add it here\n            resource.name = resource.name.toLowerCase();\n            this.resources.put(resource.name.toLowerCase(), { resource:resource, state:this.State.QUEUED });\n            this.info('Adding resource ' + resource.src + ' to the queue.');\n        },\n\n        /**\n         * Retrieve a resource from the loader\n         * @param {String} name Name of the resource\n         * @return {pc.Image|pc.Sound|pc.DataResource} Resource\n         */\n        get:function (name)\n        {\n            var res = this.resources.get(name.toLowerCase());\n            if (!res)\n                throw \"Attempting to get a resource that hasn't been added: \" + name;\n            if (res.state < this.State.READY)\n                throw \"Attempting to get a resource that hasn't been loaded yet (calling before onLoaded?)\";\n            return res;\n        },\n\n        /**\n         * Get all the sound resources\n         * @return {Array} An array of all the sounds\n         */\n        getAllSounds:function ()\n        {\n            var sounds = [];\n            var keys = this.resources.keys();\n\n            for (var i = 0; i < keys.length; i++)\n            {\n                var res = this.resources.get(keys[i]).resource;\n                if (res.Class.isA('pc.Sound'))\n                    sounds.push(res);\n            }\n            return sounds;\n        },\n\n        /**\n         * Get all the image resources\n         * @return {Array} An array of all the images\n         */\n        getAllImages:function ()\n        {\n            var images = [];\n            var keys = this.resources.keys();\n\n            for (var i = 0; i < keys.length; i++)\n            {\n                var res = this.resources.get(keys[i]);\n                if (res.isA('pc.Image'))\n                    images.push(res);\n            }\n\n            return images;\n        },\n\n        /**\n         * Starts the resource loader\n         * @param {Function} loadingListener Function to call after each resource is loaded\n         * @param {Function} loadedListener Function to call after all resources have been loaded or errored.\n         */\n        start:function (loadingListener, loadedListener)\n        {\n            this.setListener(loadingListener, loadedListener);\n\n            this.progress = 0;\n            this.errored = 0;\n\n            // ask all of the resources to get busy loading\n            var keys = this.resources.keys();\n\n            for (var i = 0; i < keys.length; i++)\n            {\n                var res = this.resources.get(keys[i]);\n                if (res.state == this.State.QUEUED)\n                {\n                    res.resource.load(this._onLoad.bind(this), this._onError.bind(this));\n                    res.state = this.State.LOADING;\n                    this.totalBeingLoaded++;\n                }\n            }\n            this.info('Started loading ' + this.totalBeingLoaded + ' resource(s).');\n            this._checkAllDone();\n        },\n\n        /**\n         * Generates a URL using a src string (by prepending the baseURL and appending the optional no-cache string\n         * @param {String} src Source URI\n         * @return {String} A full resource URI\n         */\n        makeUrl:function (src)\n        {\n            return this.baseUrl + src + this._noCacheString;\n        },\n\n        /**\n        * Andrew: \n        *    fixed minor bug where if you used uppercase characters in key name res would return null\n        *    because it did not fins the key in the hashtable. Just displayed and error notice to console.\n        */\n        _onLoad:function (resource)\n        {\n            if(this.finished) return; // Ignore late/repeated notifications from looping sounds\n            var res = this.resources.get(resource.name);\n            if (res == null) {\n                this.error('Unable to get resource ['+resource.name+'] - Please make sure you are using all lowercase.');\n            } else { \n                res.state = this.State.READY;\n                this.progress++;\n\n                if (this.loadingListener != null)\n                    this.loadingListener(Math.round((this.progress / this.totalBeingLoaded) * 100));\n\n                this.info(resource.name + ' loaded (' + Math.round((this.progress / this.totalBeingLoaded) * 100) + '% done)');\n            }\n            this._checkAllDone();\n        },\n\n        _onError:function (resource)\n        {\n            if(this.finished) return; // Ignore late/repeated notifications from looping sounds\n            var res = this.resources.get(resource.name);\n            res.state = this.State.FAILED;\n            this.progress++;\n            this.errored++;\n\n            if (this.loadingListener != null)\n                this.loadingListener(this.progress / this.totalBeingLoaded);\n            this.warn(resource.name + ' (' + resource.src + ') failed.');\n\n            this._checkAllDone();\n        },\n\n        _checkAllDone:function ()\n        {\n            if (this.progress >= this.totalBeingLoaded)\n            {\n                this.finished = true;\n                this.loadedListener(this.progress, this.errored);\n                this.progress = 0;\n                this.errored = 0;\n                this.totalBeingLoaded = 0;\n            }\n\n        }\n\n    });\n\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.DataResource\n * @augments pc.Base\n * @description\n * A generic resource you can load data, such as JSON, XML or config files from a URL, just like an image or sound file.\n * <p>\n * To load a resource, use the pc.Loader to add a resource:\n * <pre><code>\n * pc.device.loader.add(new pc.DataResource('level1', 'data/level1.tmx'));\n * </code></pre>\n * <p>\n * Once you have the resource loaded you can access the contents of the resource using the data member:\n * <pre><code>\n * var xmlData = pc.device.loader.get('level1').resource.data;\n * </code></pre>\n * <p>\n * You can optionally provide a function to be called when the resource has finished loading or has an error.\n * <pre><code>\n * function onLevelDataLoaded(dataResource)\n * {\n *    // dataResource.data\n * }\n * pc.device.loader.add(new pc.DataResource('level1', 'data/level1.tmx', onLevelDataLoaded));\n * </code></pre>\n * <p>\n * The Scrollia demo game has an example using that loads the level.tmx file from the editor as a data resource which\n * is passed to pc.Scene to construct entities and layers.\n */\npc.DataResource = pc.Base.extend('pc.DataResource',\n    {},\n    /** @lends pc.DataResource.prototype */\n    {\n        /** Data resource that has been loaded */\n        data:null,\n        /** HTTP request object used to load the data */\n        request:null,\n        /** src URL */\n        src:null,\n        /** Short name for this resource */\n        name: null,\n        /** boolean indicating whether the resource has been loaded yet */\n        loaded:false,\n        /** current callback when the resource has been loaded */\n        onLoadCallback:null,\n        /** current callback if an error occurs whilst loading the resource */\n        onErrorCallback:null,\n\n        /**\n         * Loads data from a remote (URI) resource.\n         * @param {String} name Name to give the resource\n         * @param {String} src URI for the data\n         * @param {function} [onLoadCallback] Function to be called once the image has been loaded\n         * @param {function} [onErrorCallback] Function to be called if the image fails to load\n         */\n        init:function (name, src, onLoadCallback, onErrorCallback)\n        {\n            this._super();\n            this.src = pc.device.loader.makeUrl(src);\n            this.name = name;\n            this.onLoadCallback = onLoadCallback;\n            this.onErrorCallback = onErrorCallback;\n            this.request = new XMLHttpRequest();\n            this.request.onreadystatechange = this.onReadyStateChange.bind(this);\n            this.request.onload = this.onReadyStateChange.bind(this);\n            this.request.onloadend = this.onReadyStateChange.bind(this);\n            this.load();\n        },\n\n        /**\n         * Triggers an immediate load of the resource. Use only if you're manually loading a resource, otherwise\n         * the pc.Loader will automatically call load when it starts.\n         * @param {function} [onLoadCallback] Optional function called when the resource has finished loading\n         * @param {function} [onErrorCallback] Optional function called if the resource fails to load\n         */\n        load:function (onLoadCallback, onErrorCallback)\n        {\n            this.onLoadCallback = onLoadCallback;\n            this.onErrorCallback = onErrorCallback;\n\n            this.request.open('get', this.src);\n            this.request.send(null);\n        },\n\n        /**\n         * Force the reloading of a resource (by marking it not loaded and calling load\n         */\n        reload:function ()\n        {\n            this.loaded = false;\n            this.load();\n        },\n\n        /**\n         * Called when the resource is loaded/ready. Generally this is used internally, and you should use the\n         * onLoadCallback function optionally pass to the load method or constructor\n         */\n        onReadyStateChange:function()\n        {\n            if (this.loaded) return;\n\n            if (this.request.readyState == 4)\n            {\n                if (this.request.status == 200)\n                {\n                    this.loaded = true;\n\n                    this.data = this.request.responseText;\n\n                    if (this.onLoadCallback)\n                        this.onLoadCallback(this);\n                } else\n                if (this.request.status == 404)\n                {\n                    this.warn('resource ' + this.src + ' error ' + this.request.status);\n                    if (this.onErrorCallback)\n                        this.onErrorCallback(this);\n                }\n            }\n        }\n\n\n    });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\npc.components = {};\n\n/**\n * @class pc.components.Component\n * @description\n * [Extends <a href='pc.Pooled'>pc.Pooled</a>]\n * <p>\n * The base class for components you want to create.\n */\npc.components.Component = pc.Pooled.extend('pc.components.Component',\n    /** @lends pc.components.Component */\n    {\n        /**\n         * Constructor that acquires the component from an object pool.\n         * @return {pc.components.Component} A component object\n         */\n        create:function ()\n        {\n          var c = this._super();\n          c.active = true;\n          return  c;\n        }\n    },\n    /** @lends pc.components.Component.prototype */\n    {\n        /** entity I am on, or null if I'm not on an entity */\n        _entity: null,\n\n        _type:null,\n\n        /** whether the component is currently active */\n        active: true,\n\n        /**\n         * Constructs a new component using the given type string\n         * @param {String} type The type to assign the component\n         */\n        init:function (type)\n        {\n            this._super();\n            this._type = type;\n            this.active = true;\n        },\n\n        /**\n         * Get the component type\n         * @return {String} The type\n         */\n        getType:function ()\n        {\n            return this._type.toLowerCase();\n        },\n\n        /**\n         * Get the entity this component is currently in; null if not in an entity\n         * @return {pc.Entity} Entity\n         */\n        getEntity: function()\n        {\n            return this._entity;\n        },\n\n        /**\n         * Called when the system is about to remove this component, which gives you a chance\n         * to override and do something about it\n         */\n        onBeforeRemoved:function ()\n        {\n        }\n\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Circle\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Render'>pc.systems.Render</a>]\n * <p>\n * Draw a circle. The size is based on the width and height of the associated spatial.\n */\npc.components.Circle = pc.components.Component.extend('pc.components.Circle',\n    /** @lends pc.components.Circle */\n    {\n        /**\n         * Constructs (or acquires from the pool) a rectangle component.\n         * @param {String} options.color Fill color in the form of #RRGGBB.\n         * @param {String} options.lineColor Line color in the form of #RRGGBB\n         * @param {Number} options.lineWidth Stroke width\n         * @return {pc.components.Circle} The new component\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Circle.prototype */\n    {\n        /** pc.Color representing fill color */\n        color:null,\n        /** pc.Color representing stroke color */\n        lineColor:null,\n        /** Stroke width */\n        lineWidth:0,\n\n        /**\n         * Constructs a new component. See create method for options\n         */\n        init:function ()\n        {\n            this._super('circle');\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            if (options.color)\n            {\n                if (this.color == null)\n                    this.color = pc.Color.create(options.color);\n                else\n                    this.color.set(options.color);\n            } else\n                this.color = null;\n\n            if (options.lineColor)\n            {\n                if (this.lineColor == null)\n                    this.lineColor = pc.Color.create(options.lineColor);\n                else\n                    this.lineColor.set(options.lineColor);\n            } else\n                this.lineColor = null;\n\n            this.lineWidth = pc.checked(options.lineWidth, 0);\n        }\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Poly\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Render'>pc.systems.Render</a>]\n * <p>\n * Draw a polygon\n */\npc.components.Poly = pc.components.Component.extend('pc.components.Poly',\n    /** @lends pc.components.Poly */\n    {\n        /**\n         * Constructs (or acquires from the pool) a rectangle component.\n         * @param {String} options.color Fill color in the form of #RRGGBB.\n         * @param {String} options.lineColor Line color in the form of #RRGGBB\n         * @param {Number} options.lineWidth Stroke width\n         * @param {Number} options.points Array of points to draw\n         * @return {pc.components.Poly} The new component\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Poly.prototype */\n    {\n        /** pc.Color representing fill color */\n        color:null,\n        /** pc.Color representing stroke color */\n        lineColor:null,\n        /** Stroke width */\n        lineWidth:0,\n        /** array of points to draw */\n        points:[],\n\n        /**\n         * Constructs a new component. See create method for options\n         * @param {Object} options Options\n         */\n        init:function (options)\n        {\n            this._super('poly');\n            this.color = pc.Color.create('#ffffff');\n            this.lineColor = null;\n            if (pc.valid(options))\n                this.config(options);\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            if (!options.color)\n                this.color.set('#ffffff');\n            else\n                this.color.set(pc.checked(options.color, '#ffffff'));\n\n            if (pc.valid(options.lineColor))\n            {\n                if (this.lineColor == null)\n                    this.lineColor = pc.Color.create(options.lineColor);\n                else\n                    this.lineColor.set(pc.checked(options.lineColor, '#888888'));\n            }\n            this.lineWidth = pc.checked(options.lineWidth, 0);\n            if (options.points.length < 3)\n                throw 'Invalid polygon, requires at least 3 points';\n            this.points = options.points;\n        }\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Scale\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Effects'>pc.systems.Effects</a>]\n * <p>\n * Change the draw scale of an entity\n * <pre><code>\n * entity.addComponent(\n *      pc.components.Scale.create( { x: 0.1, y: 0.1, growX: 4, growY: 4, maxX: 8, maxY: 8 } ) );\n * </code></pre>\n */\npc.components.Scale = pc.components.Component.extend('pc.components.Scale',\n    /** @lends pc.components.Scale */\n    {\n        /**\n         * Constructs (or acquires from the pool) a scale component\n         * @param {Number} options.x initial x-axis scale\n         * @param {Number} options.y initial y-axis scale\n         * @param {Number} options.growX amount to grow x-axis per second (can be negative)\n         * @param {Number} options.growY amount to grow y-axis per second (can be negative)\n         * @param {Number} options.maxX maximum x-axis scale change\n         * @param {Number} options.maxY maximum y-axis scale change\n         * @return {pc.components.Scale} A configured component\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Scale.prototype */\n    {\n        /** original scale applied to the spatial (only done once when binding the component) */\n        x:1,\n        /** original scale applied to the spatial (only done once when binding the component) */\n        y:1,\n        /** rate to grow the x-axis scale (can be negative) */\n        growX:0,\n        /** rate to grow the y-axis scale (can be negative) */\n        growY:0,\n        /** maximum x-axis scale change (positive or negative) */\n        maxX:0,\n        /** maximum y-axis scale change (positive or negative) */\n        maxY:0,\n        /** amount we have scaled so far (read-only) */\n        scaledXSoFar:0,\n        /** amount we have scaled so far (read-only) */\n        scaledYSoFar:0,\n        /** still scaling or not */\n        scaling: true,\n\n        _bound:false,\n\n        /**\n         * Constructs a new component. See create method for options\n         * @param {Object} options Options\n         */\n        init:function (options)\n        {\n            this._super('scale');\n            if (pc.valid(options))\n                this.config(options);\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            this.x = pc.checked(options.x, 1);\n            this.y = pc.checked(options.y, 1);\n            this.growX = pc.checked(options.growX, 0);\n            this.growY = pc.checked(options.growY, 0);\n            this.maxX = pc.checked(options.maxX, 0);\n            this.maxY = pc.checked(options.maxY, 0);\n            this.scaledXSoFar = 0;\n            this.scaledYSoFar = 0;\n        }\n    });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Spin\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Effects'>pc.systems.Effects</a>]\n * <p>\n * Makes an entity spin\n * <pre><code>\n * entity.addComponent(\n *      pc.components.Spin.create( { rate: 15 } ) );\n * </code></pre>\n */\npc.components.Spin = pc.components.Component.extend('pc.components.Spin',\n    /** @lends pc.components.Spin */\n    {\n        /**\n         * Constructs (or acquires from the pool) a fade component\n         * @param {Number} options.rate rate of spin in degrees per second (default is 15)\n         * @param {Number} options.max Amount to spin (optional, default is 0 - unlimited)\n         * @param {Boolean} options.clockwise Whether to spin in a clockwise direction (default is true)\n         * @return {pc.components.Spin} A configured component\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Spin.prototype */\n    {\n        /** rate of spin in degrees per second */\n        rate:0,\n        /** number of degrees to spin */\n        max:0,\n        /** spin clockwise or counter clockwise */\n        clockwise: true,\n        /** degrees spun so far */\n        spinSoFar: 0,\n        /** still spinning */\n        spinning: true,\n\n        /**\n         * Constructs a new component. See create method for options\n         * @param {Object} options Options\n         */\n        init:function (options)\n        {\n            this._super('spin');\n            if (pc.valid(options))\n                this.config(options);\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            this.rate = pc.checked(options.rate, 15);\n            this.max = pc.checked(options.max, 0);\n            this.clockwise = pc.checked(options.clockwise, true);\n            this.spinSoFar = 0;\n            this.spinning = true;\n        }\n    });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Physics\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Physics'>pc.systems.Physics</a>]\n * <p>\n * Adds 2D physics to an entity. See the <a href='/develop/guides/physics'>physics</a> and\n * <a href='/develop/guides/collisions'>collision</a> guides for more information.\n *\n * <h5>Shapes</h5>\n * You can define physics shapes by providing an array of settings, one for each shape. The available options for\n * each shape are:\n * - shape: shape type (pc.CollisionShape.RECT | pc.CollisionShape.CIRCLE | pc.CollisionShape.POLY)\n * - offset: (x, y, w, h) of the shape to the entity's spatial (all default to 0)\n * - type: user-set type which will be passed on in collisions\n * - sensorOnly: boolean, use true to not react to collisions, just report them\n * - collisionGroup: same as component collision group, but applies to only this fixture shape.\n * - collisionMask: same as component collision mask, but applies to only this fixture shape.\n * - collisionCategory: same as component collision category, but applies to only this fixture shape.\n *\n * Here's an example of a complex configuration of shapes (from the Scrollia player entity):\n * <pre><code>\n * e.addComponent(pc.components.Physics.create(\n * {\n *   ...\n *\n *     shapes:[\n *         // upper torso/head\n *         { type:0, offset:{y:-20, w:-60}, shape:pc.CollisionShape.CIRCLE },\n *         // middle torso\n *         { type:0, offset:{y:-3, w:-60}, shape:pc.CollisionShape.CIRCLE },\n *         // leg area\n *         { type:0, offset:{y:12, w:-60}, shape:pc.CollisionShape.CIRCLE },\n *         // feet\n *         { type:1, sensorOnly:true, shape:pc.CollisionShape.CIRCLE, offset:{y:20, w:-68} }\n *     ],\n *\n *     ...\n * }));\n * </code></pre>\n */\n\npc.components.Physics = pc.components.Component.extend('pc.components.Physics',\n    /** @lends pc.components.Physics */\n    {\n        /**\n         * Creates (or acquires) a new physics component using the provided options\n         * @param {Number} [options.collisionGroup] Collision group to assign (default: 0)\n         * @param {Number} [options.collisionCategory] Collision category to assign (default: 0)\n         * @param {Number} [options.collisionMask] Collision mask to assign (default: 0)\n         * @param {Boolean} [options.sensorOnly] Don't react to collisions, just sense them (default: false)\n         * @param {Boolean} [options.centered] Causes box2d body to be aligned to center (rather than top left shifted) (default: true)\n         * @param {Array} [options.shapes] An array of shapes representing the fixtures (default: entity's spatial rectangle)\n         * @param {pc.Dim} [options.maxSpeed] Maxium velocity to allow the entity to go (as an x, y vector)\n         * @param {pc.Dim} [options.gravity] Gravity override for the entity only (x, y vector)\n         * @param {Number} [options.mass] Amount of relative mass to assign to the entity\n         * @param {Boolean} [options.fixedRotation] True if the object is not allow to turn (default: false)\n         * @param {Number} [options.thrust] Initial thrust to apply\n         * @param {Number} [options.bounce] Amount of bounciness (2=200% reverse velocity on impact)\n         * @param {Boolean} [options.faceVel] Use true to have the entity always face the direction it's heading\n         * @param {pc.CollisionShape} [options.shape] Collision shape default (if shapes array not set)\n         * @param {Boolean} [options.immovable] Makes the object immovable (by any force)\n         * @param {Number} [options.density] How dense the entity is\n         * @param {Number} [options.friction] Amount of friction to apply\n         * @param {Number} [options.linearDamping] How fast to slow down velocity (less = more slide)\n         * @param {Number} [options.angularDamping] How fast to slow down spin (less = better bearings)\n         * @param {Boolean} [options.bullet] Special case handling of high-speed objects (enabled CCD)\n         * @param {Number} [options.torque] Amount of torque to apply (generate spin)\n         * @param {Number} [options.impulse] Amount of impulse force to apply initially\n         * @param {Number} [options.turn] Amount of initial spin to apply\n         * @param {pc.Dim} [options.centerOfMass] Where to position the entities centerOfMass (x, y)\n         * @param {pc.Dim} [options.linearVelocity] Initial linear velocity (x, y)\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Physics.prototype */\n    {\n        /** maximum speed the entity can move at (pc.Dim|pc.Point) */\n        maxSpeed:null,\n        /** bounciness (2 = bounce back at twice the impact speed) */\n        bounce:0.5,\n        /** causes the entity's direction to always match the velocity angle */\n        faceVel:false,\n        /** the density of the object */\n        density:0,\n        /** mass */\n        mass:-1,\n        /** level of friction (rubbing) of the surface */\n        friction:0,\n        /** rate at which an object will slow down movement */\n        linearDamping:0,\n        /** initial linear velocity */\n        linearVelocity: null,\n        /** rate at which ab object will slow down its rate of spin */\n        angularDamping:0,\n        /** stop the entity from rotating */\n        fixedRotation:false,\n        /** tell the physics engine to expect this object to move fast (slows things down */\n        bullet:false,\n        /**\n         * A designated collision index, anything in the same index won't collide\n         * a negative value will cause collisions with other objects, but not others of the same index\n         * a positive number will cause collisions between objects of this group as well\n         */\n        collisionGroup:0,\n        /** Advanced collisions using a bit mask. Use this to set bits on/off. */\n        collisionCategory:0,\n        /** Collision mask to apply to the entities */\n        collisionMask:0,\n        /** Senses collisions only; there will be no reaction to the collision (like pushing back) */\n        sensorOnly:false,\n        /** Whether the object can move in space (true gives it infinite mass) */\n        immovable:false,\n        /** Changes the center of mass from the default center (pc.Dim) */\n        centerOfMass:null,\n        /** causes box2d body to be aligned to center (rather than top left shifted) (default: true) */\n        centered:true,\n\n        /**\n         * Custom gravity (x an y properties)\n         */\n        gravity:null,\n\n        /** Shapes - an array of shapes that make up this physics body */\n        shapes:null,\n\n        /** force to apply on adding the component */\n        force:0,\n        /** turn (spin) to apply on adding the component */\n        turn:0,\n        /** torque energy to apply on adding the component */\n        torque:0, // torque to apply\n\n        _body:null, // set by the physics system, if this is attached to a physics body\n        _fixtures:null, // array of fixtures attached to the body\n\n        // internal tracking of the associated spatial to detect changes. initialized by the physics\n        // component when bound\n        _lastSpatialPos:null,\n        _lastSpatialDim:null,\n        _lastSpatialDir:0,\n\n        /**\n         * Constructs and configures a new physics component (see create for details of options)\n         */\n        init:function (options)\n        {\n            this._super('physics');\n            this.centerOfMass = pc.Point.create(0, 0);\n            this.margin = { x:0, y:0 };\n            this.linearVelocity = pc.Dim.create(0,0);\n            if (pc.valid(options))\n                this.config(options);\n            this._velReturn = pc.Dim.create(0, 0);\n            this.gravity = {};\n        },\n\n        /**\n         * Configures the physics component (see create for details of options)\n         */\n        config:function (options)\n        {\n            this._body = null;\n            if (this._fixtures)\n                this._fixtures.length = 0;\n            else\n                this._fixtures = [];\n\n            this.collisionGroup = pc.checked(options.collisionGroup, 0);\n            this.collisionCategory = pc.checked(options.collisionCategory, 0);\n            this.collisionMask = pc.checked(options.collisionMask, 0);\n            this.sensorOnly = pc.checked(options.sensorOnly, false);\n            this.centered = pc.checked(options.centered, true);\n\n            // no shape supplied, create a default one\n            if (!pc.valid(options.shapes) && !Array.isArray(options.shapes))\n            {\n                options.shapes = [\n                    {}\n                ];\n                options.shapes[0].shape = pc.CollisionShape.RECT;\n            }\n\n            for (var i = 0; i < options.shapes.length; i++)\n            {\n                var shape = options.shapes[i];\n\n                // take the spatial, then offset\n                if (!shape.offset)\n                    shape.offset = {};\n\n                shape.offset.x = pc.checked(shape.offset.x, 0);\n                shape.offset.y = pc.checked(shape.offset.y, 0);\n                shape.offset.w = pc.checked(shape.offset.w, 0);\n                shape.offset.h = pc.checked(shape.offset.h, 0);\n\n                shape.type = pc.checked(shape.type, 0);\n                shape.shape = pc.checked(shape.shape, pc.CollisionShape.RECT);\n                shape.sensorOnly = pc.checked(shape.sensorOnly, this.sensorOnly);\n                shape.collisionGroup = pc.checked(shape.collisionGroup, this.collisionGroup);\n                shape.collisionCategory = pc.checked(shape.collisionCategory, this.collisionCategory);\n                shape.collisionMask = pc.checked(shape.collisionMask, this.collisionMask);\n            }\n\n            this.shapes = options.shapes;\n\n            if (options.linearVelocity)\n            {\n                this.linearVelocity.x = pc.checked(options.linearVelocity.x, 0);\n                this.linearVelocity.y = pc.checked(options.linearVelocity.y, 0);\n            } else\n            {\n                this.linearVelocity.x = 0;\n                this.linearVelocity.y = 0;\n            }\n\n            if (!this.maxSpeed) this.maxSpeed = {};\n            if (options.maxSpeed)\n            {\n                this.maxSpeed.x = pc.checked(options.maxSpeed.x, 0);\n                this.maxSpeed.y = pc.checked(options.maxSpeed.y, 0);\n            } else\n            {\n                this.maxSpeed.x = 0;\n                this.maxSpeed.y = 0;\n            }\n\n            if (options.gravity)\n            {\n                this.gravity.x = options.gravity.x;\n                this.gravity.y = options.gravity.y;\n            } else\n            {\n                this.gravity.x = undefined;\n                this.gravity.y = undefined;\n            }\n\n            this.mass = pc.checked(options.mass, -1);\n\n            this.fixedRotation = pc.checked(options.fixedRotation, false);\n            this.thrust = pc.checked(options.thrust, 0);\n            this.bounce = pc.checked(options.bounce, 0.5);\n            this.faceVel = pc.checked(options.faceVel, 0);\n            this.shape = pc.checked(options.shape, pc.CollisionShape.RECT);\n\n            this.immovable = pc.checked(options.immovable, false);\n\n            this.density = pc.checked(options.density, 1);\n            this.friction = pc.checked(options.friction, 0.2);\n            this.linearDamping = pc.checked(options.linearDamping, 0);\n            this.angularDamping = pc.checked(options.angularDamping, 0);\n            this.bullet = pc.checked(options.bullet, false);\n            this.torque = pc.checked(options.torque, 0);\n            this.impulse = pc.checked(options.impulse, 0);\n            this.turn = pc.checked(options.turn, 0);\n            this.force = pc.checked(options.force, 0);\n\n            if (pc.valid(options.centerOfMass))\n            {\n                this.centerOfMass.x = pc.checked(options.centerOfMass.x);\n                this.centerOfMass.y = pc.checked(options.centerOfMass.y);\n            }\n        },\n\n        /**\n         * Applies angular velocity (turn) to the physics body\n         * @param {Number} d Degrees of turn to apply\n         */\n        applyTurn:function (d)\n        {\n            if (this._body)\n            {\n                this._body.SetAngularVelocity(pc.Math.degToRad(d));\n                this._body.SetAwake(true);\n            } else\n                this._pendingDir = d;\n        },\n\n        /**\n         * Clears any custom gravity\n         */\n        clearGravity:function ()\n        {\n            this.setGravity();\n        },\n\n        /**\n         * Changes gravity for this entity only: useful for swimming through water, climbing ladder or\n         * balloons.\n         * @param gravityX Gravity value (0 for no gravity)\n         * @param gravityY Gravity value (0 for no gravity)\n         */\n        setGravity:function (gravityX, gravityY)\n        {\n            this.gravity.x = gravityX;\n            this.gravity.y = gravityY;\n            if (this._body)\n            {\n                if (this.gravity.x != undefined || this._body._pc_gravityX != undefined)\n                    this._body._pc_gravityX = this.gravity.x;\n                if (this.gravity.y != undefined || this._body._pc_gravityY != undefined)\n                    this._body._pc_gravityY = this.gravity.y;\n            }\n        },\n\n        /**\n         * Force a direction change\n         * @param {Number} d Direction to change to\n         */\n        setDir:function (d)\n        {\n            if (this._body)\n            {\n                this._body.SetAngle(pc.Math.degToRad(d));\n                this._body.SetAwake(true);\n            } else\n                this.dir = d;\n        },\n\n        /**\n         * Retrieves the current direction\n         * @return {Number} Current direction\n         */\n        getDir:function ()\n        {\n            if (this._body)\n            {\n                return pc.Math.radToDeg(this._body.GetAngle());\n            }\n            return 0;\n        },\n\n        /**\n         * Applies force to the entity at a given angle\n         * @param {Number} f Amount of force to apply\n         * @param {Number} a Angle to apply the force at\n         */\n        applyForce:function (f, a)\n        {\n            if (this._body)\n            {\n                var angle = this._body.GetAngle();\n                if (pc.valid(a))\n                    angle = pc.Math.degToRad(a);\n\n                this._body.ApplyForce(\n                    Box2D.Common.Math.b2Vec2.Get(Math.cos(angle) * f, Math.sin(angle) * f),\n                    this._body.GetWorldCenter());\n\n            } else\n                this.force = f;\n        },\n\n        /**\n         * Applies immediate force to the entity at a given angle\n         * @param {Number} f Amount of force to apply\n         * @param {Number} a Direction to apply it at\n         */\n        applyImpulse:function (f, a)\n        {\n            if (this._body)\n            {\n                var angle = this._body.GetAngle();\n                if (pc.valid(a))\n                    angle = pc.Math.degToRad(a);\n\n                this._body.ApplyImpulse(\n                    Box2D.Common.Math.b2Vec2.Get(Math.cos(angle) * f, Math.sin(angle) * f),\n                    this._body.GetWorldCenter());\n            } else\n                this.impulse = f;\n        },\n\n        /**\n         * Applies angular force (torque/spin) to an object to rotate it\n         * @param {Number} a Amount of angular force\n         */\n        applyTorque:function (a)\n        {\n            if (this._body)\n            {\n                this._body.ApplyTorque(pc.Math.degToRad(a));\n            } else\n                this.torque = a;\n        },\n\n        /**\n         * Change the center of masss\n         * @param {Number} x x-position relative to the origin of the entity\n         * @param {Number} y y-position relative to the origin of the entity\n         */\n        setCenterOfMass:function (x, y)\n        {\n            if (this._body)\n            {\n                var md = new Box2D.Collision.Shapes.b2MassData();\n                md.center = Box2D.Common.Math.b2Vec2.Get(pc.systems.Physics.toP(x), pc.systems.Physics.toP(y));\n                this._body.SetMassData(md);\n            } else\n            {\n                this.centerOfMass.x = x;\n                this.centerOfMass.y = y;\n            }\n        },\n\n        /**\n         * Returns the current speed in linear velocity\n         * @return {Number} Current linear velocity (the length of the speed vector)\n         */\n        getSpeed:function ()\n        {\n            if (this._body)\n                return this._body.GetLinearVelocity().Length() / pc.systems.Physics.SCALE;\n            return 0;\n        },\n\n        /**\n         * Force change the speed of the entity\n         * @param {Number} x x-component of a speed vector\n         * @param {Number} y y-component of a speed vector\n         */\n        setLinearVelocity:function (x, y)\n        {\n            if (this._body)\n            {\n                this._body.SetLinearVelocity(Box2D.Common.Math.b2Vec2.Get(x * pc.systems.Physics.SCALE, y * pc.systems.Physics.SCALE));\n                this._body.SetAwake(true);\n            } else\n            {\n                this.linearVelocity.x = x;\n                this.linearVelocity.y = y;\n            }\n        },\n\n        _velReturn:null,\n\n        /**\n         * Current linear velocity vector\n         * @return {pc.Dim} Current velocity as a 2d vector\n         */\n        getLinearVelocity:function ()\n        {\n            if (this._body)\n            {\n                var v = this._body.GetLinearVelocity();\n                this._velReturn.setXY(pc.systems.Physics.fromP(v.x), pc.systems.Physics.fromP(v.y));\n            }\n            return this._velReturn;\n        },\n\n        /**\n         * Gets the angle based on the current velocity vector\n         * @return {Number} Angle\n         */\n        getVelocityAngle:function ()\n        {\n            return pc.Math.angleFromVector(this._body.GetLinearVelocity().x, this._body.GetLinearVelocity().y);\n        },\n\n        /**\n         * Forces an angular velocity (spin) change\n         * @param {Number} a Amount of angular force to apply\n         */\n        setAngularVelocity:function (a)\n        {\n            if (this._body)\n            {\n                this._body.SetAngularVelocity(a);\n                this._body.SetAwake(true);\n            }\n        },\n\n        /**\n         * Sets the linear damping\n         * @param {Number} d Amount of damping to apply\n         */\n        setLinearDamping:function (d)\n        {\n            if (this._body)\n            {\n                this._body.SetLinearDamping(a);\n                this._body.SetAwake(true);\n            }\n        },\n\n        /**\n         * Sets the friction\n         * @param {Number} f Amount of friction to apply\n         */\n        setFriction:function (f)\n        {\n            if (this._body)\n            {\n                this._body.SetFriction(f);\n                this._body.SetAwake(true);\n            }\n        },\n\n        /**\n         * Change the collision category (changes all shapes)\n         * @param {Number} c Category to change to\n         */\n        setCollisionCategory:function (c)\n        {\n            if (!this._fixtures.length) return;\n\n            this.collisionCategory = c;\n            for (var i = 0; i < this._fixtures.length; i++)\n            {\n                var f = this._fixtures[i].GetFilterData();\n                f.collisionCategory = c;\n                this._fixtures[i].SetFilterData(f);\n\n                this._fixtures[i].GetFilterData().categoryBits = c;\n            }\n        },\n\n        /**\n         * Change the collision group (changes all shapes)\n         * @param {Number} g Group to change to\n         */\n        setCollisionGroup:function (g)\n        {\n            if (!this._fixtures.length) return;\n\n            this.collisionGroup = g;\n            for (var i = 0; i < this._fixtures.length; i++)\n            {\n                var f = this._fixtures[i].GetFilterData();\n                f.groupIndex = g;\n                this._fixtures[i].SetFilterData(f);\n            }\n        },\n\n        /**\n         * Change the collision mask (changes all shapes)\n         * @param {Number} m Mask to change to\n         */\n        setCollisionMask:function (m)\n        {\n            if (!this._fixtures.length) return;\n\n            this.collisionMask = m;\n            for (var i = 0; i < this._fixtures.length; i++)\n            {\n                var f = this._fixtures[i].GetFilterData();\n                f.maskBits = m;\n                this._fixtures[i].SetFilterData(f);\n            }\n        },\n\n        /**\n         * Change the sensor only status of a given shape\n         * @param {Boolean} s True if this is only a sensor\n         * @param {Number} shapeIndex Index of the shape to change\n         */\n        setIsSensor:function (s, shapeIndex)\n        {\n            if (!this._fixtures.length) return;\n            this._fixtures[shapeIndex].isSensor = s;\n        }\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Alpha\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Render'>pc.systems.Render</a>]\n * <p>\n * Changes the alpha drawing of an associated drawable object (sprite, shape, text etc).\n */\npc.components.Alpha = pc.components.Component.extend('pc.components.Alpha',\n  /** @lends pc.components.Alpha */\n  {\n    /**\n     * Constructs (or acquires) an alpha component.\n     * @param {Number} options.level Amount of initial alpha to set\n     * @return {pc.components.Alpha} The new alpha object\n     */\n    create: function (options)\n    {\n      var n = this._super();\n      n.config(options);\n      return n;\n    }\n  },\n  /** @lends pc.components.Alpha.prototype */\n  {\n    /** Current alpha level 0=fully transparent */\n    level: 1,\n\n    /**\n     * Constructs a new component. See create method for options\n     */\n    init: function ()\n    {\n      this._super('alpha');\n    },\n\n    /**\n     * Configures the component. See create method for options\n     * @param {Object} options Options\n     */\n    config: function (options)\n    {\n      this.level = pc.checked(options.level, 1);\n    },\n\n    /**\n     * Set the alpha level\n     * @param {Number} a Level to set alpha to\n     */\n    setAlpha: function (a)\n    {\n      this.level = a;\n      this._fix(this.level);\n    },\n\n    /**\n     * Add to the alpha level\n     * @param {Number} a Amount to increase alpha by\n     */\n    addAlpha: function (a)\n    {\n      this.level += a;\n      this._fix(this.level);\n    },\n\n    /**\n     * Subtract from the alpha level\n     * @param {Number} a Amount o subtract\n     */\n    subAlpha: function (a)\n    {\n      this.level -= a;\n      this._fix(this.level);\n    },\n\n    _fix: function (c)\n    {\n      if (c > 1) return;\n      if (c < 0) return;\n      this.level = c;\n    }\n\n  });",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\npc.JointType = {\n    WELD:0,\n    REVOLUTE:1,\n    DISTANCE:2\n};\n\n/**\n * @class pc.components.Joint\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Physics'>pc.systems.Physics</a>]\n * <p>\n * Creates a joint that holds to physics entities together.\n */\npc.components.Joint = pc.components.Component.extend('pc.components.Joint',\n    /** @lends pc.components.Joint */\n    {\n        /**\n         * Construct (or acquires) a new component with the options supplied\n         * @param {pc.Entity} options.attachTo Entity to attach the joint to\n         * @param {pc.Dim} options.offset Dim x, y of the pixel offset the joint is relative to the source entity\n         * @param {pc.Dim} options.attachmentOffset Dim x, y of the offset of the joint on the attached entity\n         * @param {Number} options.distance How long the joint is\n         * @param {pc.JointType} options.type Type of joint (pc.JointType.WELD, pc.JointType.REVOLUTE, pc.JointType.DISTANCE)\n         * @param {Number} options.dampingRatio Ratio for damping motion\n         * @param {Number} options.lowerAngleLimit Limit angular movement this angle at the lowest\n         * @param {Number} options.upperAngleLimit Limit angular movement this angle at the highest\n         * @param {Boolean} options.enableLimit True is anglular limiting is enabled\n         * @param {Number} options.maxMotorTorque Highest torque that motor can power to\n         * @param {Number} options.motorSpeed Speed of the motor that drives joint turn\n         * @param {Boolean} options.enableMotor Whether to engage the motor\n         * @param {Number} options.angle Angle of the joint\n         * @return {pc.components.Joint} A configured joint component\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Joint.prototype */\n    {\n        /** The entity this joint attaches to */\n        attachTo:null,\n        /** Position offset of the joint on the source entity */\n        offset:null,\n        /** Position offset of the joint on the atached to entity */\n        attachmentOffset:null,\n        /** Distance / length of the joint */\n        distance:0,\n        /** Type of joint -- see pc.JointType */\n        type:0,\n\n        /** Frequency of the joint (distance joints only) */\n        frequency:0,\n        /** Damping ratio (distance joints only) */\n        dampingRatio:0,\n\n        /** Angle of the joint (revolute joints only) */\n        angle:0,\n        /** Lower angle limit (revolute joints only) */\n        lowerAngleLimit:0,\n        /** Upper angle limit (revolute joints only) */\n        upperAngleLimit:0,\n        /** Whether angule limiting is in play (revolute joints only) */\n        enableLimit:false,\n        /** Maxmium torque of the motor (revolute joints only) */\n        maxMotorTorque:0,\n        /** Whether the motor is enabled (revolute joints only) */\n        enableMotor:0,\n        /** Speed of the motor (revolute joints only) */\n        motorSpeed:0,\n\n        _joint:null,\n\n        /**\n         * Constructs a new joint (via new). See create method for options details.\n         */\n        init:function (options)\n        {\n            this._super('joint');\n            this.offset = pc.Point.create(0, 0);\n            this.attachmentOffset = pc.Point.create(0, 0);\n            if (pc.valid(options))\n                this.config(options);\n        },\n\n        /**\n         * Configures a joint. See create method for options details.\n         */\n        config:function (options)\n        {\n            this.attachTo = pc.checked(options.attachedTo, null);\n            if (options.offset)\n                this.offset.setXY(pc.checked(options.offset.x, 0), pc.checked(options.offset.y, 0));\n            if (options.attachmentOffset)\n                this.attachmentOffset.setXY(pc.checked(options.attachmentOffset.x, 0), pc.checked(options.attachmentOffset.y, 0));\n\n            this.distance = pc.checked(options.distance, 0);\n            this.type = pc.checked(options.type, pc.JointType.WELD);\n\n            this.dampingRatio = pc.checked(options.dampingRatio, 0);\n            this.lowerAngleLimit = pc.checked(options.lowerAngleLimit, 0);\n            this.upperAngleLimit = pc.checked(options.upperAngleLimit, 359);\n            this.enableLimit = pc.checked(options.enableLimit, false);\n            this.maxMotorTorque = pc.checked(options.maxMotorTorque, 100);\n            this.enableMotor = pc.checked(options.enableMotor, false);\n            this.motorSpeed = pc.checked(options.motorSpeed, 0);\n            this.angle = pc.checked(options.angle, 0);\n\n            this._joint = null;\n        },\n\n        /**\n         * Gets the current angle of the joint\n         * @return {Number} Angle\n         */\n        getAngle:function ()\n        {\n            return pc.Math.radToDeg(this._joint.GetJointAngle());\n        },\n\n        /**\n         * Gets the current speed of the motor\n         * @return {Number} Current speed\n         */\n        getSpeed:function ()\n        {\n            return this._joint.GetJointSpeed();\n        },\n\n        /**\n         * Sets the motor speed\n         * @param {Number} s Speed\n         */\n        setMotorSpeed:function (s)\n        {\n            this.motorSpeed = s;\n            this._joint.SetMotorSpeed(s);\n        },\n\n        /**\n         * Gets the current torque of the motor\n         * @return {Number} Torque\n         */\n        getMotorTorque:function ()\n        {\n            return this._joint.GetMotorTorque();\n        },\n\n        /**\n         * Gets whether the angle limits are on\n         * @return {Boolean} True is they are on\n         */\n        isLimitEnabled:function ()\n        {\n            return this.enableLimit;\n        },\n\n        /**\n         * Gets whether the motor is presently enabled\n         * @return {Boolean} True is the motor is enabled\n         */\n        isMotorEnabled:function ()\n        {\n            return this.enableMotor;\n        },\n\n        /**\n         * Sets the max motor torque level (how fast she'll spin)\n         * @param {Number} m Maxium\n         */\n        setMaxMotorTorque:function (m)\n        {\n            this.maxMotorTorque = m;\n            this._joint.SetMaxMotorTorque(m);\n        },\n\n        /**\n         * Gets the current max motor torque\n         * @return {Number} The max\n         */\n        getMaxMotorTorque:function ()\n        {\n            return this.maxMotorTorque;\n        }\n\n\n    });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Expiry\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Expiry'>pc.systems.Expiry</a>]\n * <p>\n * Automatically expires an entity after a given time. Great for things like bullets that have a known lifetime;\n * just add the expiry component and it will happily kill itself (release) after the given time\n */\npc.components.Expiry = pc.components.Component.extend('pc.components.Expiry',\n    /** @lends pc.components.Expiry */\n    {\n        /**\n         * Constructs (or acquires from the pool) an expiry component.\n         * @param {Number} options.lifetime Life time before expiry (in ms)\n         * @return {pc.components.Expiry} The shiny new component\n         */\n        create: function(options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Expiry.prototype */\n    {\n        /** lifetime of the expiry */\n        lifetime: 0,\n\n        /**\n         * Constructs a new component. See create method for options\n         */\n        init: function()\n        {\n            this._super('expiry');\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config: function(options)\n        {\n            this.lifetime = pc.checked(options.lifetime, 1000);\n        },\n\n        /**\n         * Reduce the lifetime\n         * @param {Number} time Amount to reduce the lifetime by\n         */\n        decrease: function(time)    { this.lifetime -= time;  },\n\n        /**\n         * Gets whether the lifetime has expired (typically only the expiry system will use this)\n         * @return {Boolean} True if it has expired\n         */\n        hasExpired: function()      { return this.lifetime <= 0; }\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.OriginShifter\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Render'>pc.systems.Render</a>]\n * <p>\n * Shifts the origin of the entity relative to the origin of the layer it's on, with an additional origin ratio\n * adjuster. You can use this to make an entity shift around as the layer origin moves (parallax within parallax)\n */\npc.components.OriginShifter = pc.components.Component.extend('pc.components.OriginShifter',\n    /** @lends pc.components.OriginShifter */\n    {\n        /**\n         * Constructs (or acquires from the pool) a component, configuring it with the given options.\n         * @param {Number} options.ratio The ratio to shift the position by\n         * @return {*}\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.OriginShifter.prototype */\n    {\n        /** current shift ratio */\n        ratio:1,\n\n        _offsetX: 0,\n        _offsetY: 0,\n\n        /**\n         * Constructs a new component. See create method for options\n         * @param {Object} options Options\n         */\n        init:function (options)\n        {\n            this._super('originshifter');\n            if (pc.valid(options))\n                this.config(options);\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            this.ratio = pc.checked(options.ratio, 1);\n        }\n\n    });\n\n\n\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Spatial\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Render'>pc.systems.Render</a>, <a href='pc.systems.Physics'>pc.systems.Physics</a>,\n * <a href='pc.systems.Layout'>pc.systems.Layout</a>]\n * <p>\n * Represents where an entity exists in 2D space (x, y, width and height). This component is mostly for use by other\n * systems to update and use.\n */\npc.components.Spatial = pc.components.Component.extend('pc.components.Spatial',\n    /** @lends pc.components.Spatial */\n    {\n        /**\n         * Constructs (or acquires from the pool) a spatial component configuring it with the given options\n         * @param {Number} [options.x=0] Entity horizontal coordinate (pixels from the left)\n         * @param {Number} [options.y=0] Entity vertical coordinate (pixels from the top)\n         * @param {Number} [options.w=0] Entity width (pixels)\n         * @param {Number} [options.h=0] Entity height (pixels)\n         * @param {Number} [options.dir=0] Rotation; 0 is upright, rotation is clockwise\n         * @param {Number} [options.scaleX=1] Horizontal scaling factor (1 is no scaling, -1 flips horizontally)\n         * @param {Number} [options.scaleY=1] Vertical scaling factor (1 is no scaling, -1 flips vertically)\n         * @return {pc.components.Spatial} A shiney new component\n         */\n        create: function(options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Spatial.prototype */\n    {\n        /** Last movement in 2D space */\n        lastMove: null,\n\n        /** position of the entity as a pc.Point object (use pos.x and pos.y). */\n        pos: null,\n        /** dimension of the entity as a pc.Dim object (use dim.x for width and dim.y for height) */\n        dim: null,\n        /** amount the spatial is scaled on x-axis */\n        scaleX: 0,\n        /** amount the spatial is scaled on y-axis */\n        scaleY: 0,\n        dir: 0,\n\n        _centerPos: null, // cache of the current center\n        _screenRect: null, // cache of the getScreenRect return\n\n        /**\n         * Constructs a new component. See create method for options\n         * @param {Object} options Options\n         */\n        init: function(options)\n        {\n            this._super('spatial');\n\n            this.pos = pc.Point.create(0, 0);\n            this.dim = pc.Dim.create(0, 0);\n            this._screenRect = pc.Rect.create(0, 0, 0, 0);\n            this._centerPos = pc.Point.create(0, 0);\n            this._unscaledPos = pc.Point.create(0,0);\n            this._unscaledDim = pc.Point.create(0,0);\n            this.lastMove = pc.Dim.create(0, 0);\n            this.scaleX = 1;\n            this.scaleY = 1;\n\n            if (pc.valid(options))\n                this.config(options);\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config: function(options)\n        {\n            this.pos.x = pc.checked(options.x, 0);\n            this.pos.y = pc.checked(options.y, 0);\n            this.dim.x = pc.checked(options.w, 0);\n            this.dim.y = pc.checked(options.h, 0);\n            this.dir = pc.checked(options.dir, 0);\n            this.scaleX = pc.checked(options.scaleX, 1);\n            this.scaleY = pc.checked(options.scaleY, 1);\n\n            this._centerPos.x = 0;\n            this._centerPos.y = 0;\n            this._screenRect.x = 0;\n            this._screenRect.y = 0;\n            this._screenRect.w = 0;\n            this._screenRect.h = 0;\n            this.lastMove.x = 0;\n            this.lastMove.y = 0;\n        },\n\n        /**\n         * Get the current position\n         * @return {pc.Point} the current position\n         */\n        getPos: function()\n        {\n            return this.pos;\n        },\n\n        /**\n         * Get the current dimensions (x, y)\n         * @return {pc.Dim} Reference to the current pc.Dim for this spatial\n         */\n        getDim: function()\n        {\n            return this.dim;\n        },\n\n        /**\n         * Increase the dimensions of the spatial by the given x and y scales. Scaling occurs relative to the\n         * center of the spatial, so the position is moved accordingly\n         * @param {Number} x x-axis scale to apply (can be negative to shrink)\n         * @param {Number} y y-axis scale to apply (can be negative to shrink)\n         */\n        addScale:function(x, y)\n        {\n            this.pos.x -= Math.abs((this.dim.x - (this.dim.x * x)) / 2);\n            this.pos.y -= Math.abs((this.dim.y - (this.dim.y * y)) / 2);\n            this.dim.x *= (x);\n            this.dim.y *= (y);\n            this.scaleX += x;\n            this.scaleY += y;\n        },\n\n        _unscaledPos: null,\n\n        /**\n         * Gets the spatial position, without any scaling effects\n         * @return {pc.Point} The unscaled position\n         */\n        getUnscaledPos:function()\n        {\n            this._unscaledPos.x = this.pos.x / this.scaleX;\n            this._unscaledPos.y = this.pos.y / this.scaleY;\n            return this._unscaledPos;\n        },\n\n        _unscaledDim: null,\n\n        /**\n         * Gets the spatial dimensions, without any scaling effects\n         * @return {pc.Dim} The unscaled dimensions\n         */\n        getUnscaledDim:function()\n        {\n            this._unscaledDim.x = this.dim.x / this.scaleX;\n            this._unscaledDim.y = this.dim.y / this.scaleY;\n            return this._unscaledDim;\n        },\n\n        /**\n         * Reduces the scale of the spatial. See addScale for details\n         * @param {Number} x x-axis scale to reduce by\n         * @param {Number} y y-axis scale to reduce by\n         */\n        subtractScale:function (x, y)\n        {\n            this.addScale(-x, -y);\n        },\n\n        /**\n         * Set the spatial direction\n         * @param {Number} d Direction to set\n         */\n        setDir:function(d)\n        {\n            this.dir = d;\n        },\n\n        /**\n         * Get the current direction\n         * @return {Number} Direction\n         */\n        getDir:function ()\n        {\n            return this.dir;\n        },\n\n        /**\n         * Get the center pos of the spatial (calculated when you call this)\n         * @return {pc.Point} A pc.Point representing the center of the spatial (cached so you do not need to release it)\n         */\n        getCenterPos: function()\n        {\n            this._centerPos.x = this.pos.x + (this.dim.x/2);\n            this._centerPos.y = this.pos.y + (this.dim.y/2);\n            return this._centerPos;\n        },\n\n        /**\n         * Gets a pc.Rect of the screen relative location of this spatial (i.e. not world space)\n         * @return {pc.Rect} on-screen rectangle (cached, so you should not release it). Null if not on a layer.\n         */\n        getScreenRect: function()\n        {\n            if (this._entity && this._entity.layer)\n            {\n                this._screenRect.x = this._entity.layer.screenX(this.pos.x);\n                this._screenRect.y = this._entity.layer.screenY(this.pos.y);\n                this._screenRect.w = this.dim.x;\n                this._screenRect.h = this.dim.y;\n                return this._screenRect;\n            }\n            return null;\n        },\n\n        /**\n         * A nice string representation of the spatial\n         * @return {String} A string representation\n         */\n        toString: function()\n        {\n            return 'x: ' + this.x + ' y: ' + this.y + ' z: ' + this.z + ' dir: '+ this.dir;\n        }\n\n\n    });",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Overlay\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Render'>pc.systems.Render</a>]\n * <p>\n * Used to lay another sprite over an entity, with options to automagically expire after a certain time limit.\n * Good for things like smoke, explosive damage or muzzle flashs, and where you don't need to create a complete\n * entity.\n */\npc.components.Overlay = pc.components.Component.extend('pc.components.Overlay',\n    /** @lends pc.components.Overlay */\n    {\n        /**\n         * Constructs (or acquires an object from the pool) with the given options.\n         * @param {Number} options.lifetime Lifetime of the overlay (will automatically remove itself)\n         * @param {pc.SpriteSheet} options.spriteSheet Sprite sheet to use for the animation\n         * @param {String} options.animationStart Which animation to play in the sprite\n         * @param {Number} options.animationStartDelay Amount of time in ms to increase or decrease the animation speed\n         * @return {pc.components.Overlay} An overlay component\n         */\n        create: function(options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Overlay.prototype */\n    {\n        /** lifetime the overlay will display for */\n        lifetime: 0,\n        /** sprite object this overlay displays */\n        sprite: null,\n\n        /**\n         * Constructs a new component. See create method for options\n         * @param {Object} options Options\n         */\n        init: function(options)\n        {\n            this._super('overlay');\n            this.sprite = pc.Sprite.create();\n            if (pc.valid(options))\n                this.config(options);\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config: function(options)\n        {\n            this.lifetime = pc.checked(options.lifetime, 1000);\n\n            var spriteSheet = pc.checked(options.spriteSheet, null);\n            if (spriteSheet == null)\n                throw this.getUniqueId() + ': no spritesheet specified';\n\n            this.sprite.setSpriteSheet(spriteSheet);\n\n            var animationStart = pc.checked(options.animationStart, null);\n            var animationStartDelay = pc.checked(options.animationStartDelay, 0);\n            if (animationStart != null)\n                this.sprite.setAnimation(animationStart, animationStartDelay);\n        },\n\n        /**\n         * Descreases the amount of time the sprite should stay alive for\n         * @param {Number} time Time to reduce by in ms\n         */\n        decrease: function(time)    { this.lifetime -= time;  },\n\n        /**\n         * Tests if the sprite has expired already\n         * @return {Boolean} True if it has expired\n         */\n        hasExpired: function()      { return this.lifetime <= 0; }\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Clip\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Render'>pc.systems.Render</a>]\n * <p>\n * Clips all rendering for an entity to be within the specified rect (in layer relative coordinates)\n * You can also specify an entity, which will clip based on the spatial rectangle of the other entity\n * You can also do both entity clipping as well as stacking a rectangle clip on top\n */\npc.components.Clip = pc.components.Component.extend('pc.components.Clip',\n    /** @lends pc.components.Clip */\n    {\n        /**\n         * Constructs (or acquires) a clipping component\n         * @param options\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Clip.prototype */\n    {\n        /** Clip this entity to the bounding rectangle of another entity */\n        clipEntity:null,\n        /** x-position of the top left of the clipping rectangle */\n        x:0,\n        /** y-position of the top left of the clipping rectangle */\n        y:0,\n        /** Width the clipping rectangle */\n        w:0,\n        /** Height the clipping rectangle */\n        h:0,\n\n        /**\n         * Constructs (or acquires) a clipping component\n         */\n        init:function ()\n        {\n            this._super('clip');\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            this.clipEntity = pc.checked(options.clipEntity, null);\n            this.x = pc.checked(options.x, 0);\n            this.y = pc.checked(options.y, 0);\n            this.w = pc.checked(options.w, 0);\n            this.h = pc.checked(options.h, 0);\n        }\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Activator\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Activation'>pc.systems.Activation</a>]\n * <p>\n * Causes an entity to be inactive (no rendering or physics etc) until another entity moves within range of it.\n * Great for autosleeping all your monsters until the player gets close.\n */\npc.components.Activator = pc.components.Component.extend('pc.components.Activator',\n    /** @lends pc.components.Activator */\n    {\n        /**\n         * Constructs a new activator component (by acquiring it from the pool).\n         * @param {String} options.tag Tag to look for. When an entity with this tag gets close... bing!\n         * @param {pc.Layer} options.layer The layer the target enitty is on\n         * @param {Number} options.range How close the tagged entity has to be to cause activation\n         * @param {Boolean} options.stayActive Stay active once active, otherwise go inactive if range exceeds (default false)\n         * @return {pc.components.Activator} The component\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Activator.prototype */\n    {\n        /**\n         * entities with this tag to track -- if entity moves within range, the entity with this component will become active\n         */\n        tag:null,\n\n        /**\n         * Layer name to look for the activation entity, default is the same layer as the entity (null)\n         */\n        layer: null,\n\n        /**\n         * Range (in pixels) to cause activation.\n         */\n        range:0,\n\n        /**\n         * Whether the entity should stay active once activated, otherwise if the range exceeds the distance the\n         * entity will go back to sleep\n         */\n        stayActive: false,\n\n        _cacheLayer:null,\n\n        /**\n         * Constructs a clipping component\n         */\n        init:function ()\n        {\n            this._super('activator');\n        },\n\n        /**\n         * Configures the component. See create method for options.\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            if (!options.tag)\n                throw 'Activator requires an entity to track against';\n\n            this.tag = options.tag;\n            this.layer = pc.checked(options.layer, null);\n            this.range = pc.checked(options.range, 300);\n            this.stayActive = pc.checked(options.stayActive, false);\n        }\n\n\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Input\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Input'>pc.systems.Input</a>]\n * <p>\n * Convenience component that lets you bind input states and actions to an entity.\n * In options provide an array of states and actions, with the associated input, e.g.\n * <pre><code>\n * states:\n * [\n *      ['moving right', ['D', 'TOUCH', 'RIGHT']],\n *      ['moving left', ['A', 'LEFT']],\n *      ['jumping', ['W', 'UP']],\n *      ['jumping', ['MOUSE_BUTTON_LEFT_DOWN', 'SPACE'], false],\n * ],\n * actions:\n * [\n *      ['fire', ['SPACE']]\n * ]\n * </code></pre>\n * Note the use of a positional input (the mouse left button click for attack). This takes an optional extra\n * boolean to set whether the positional event should be contained with the on-screen spatial rectangle of the entity.\n * In this case, true means only engage the attack state if the click is on the player; false means you can click\n * anywhere on-screen.\n */\npc.components.Input = pc.components.Component.extend('pc.components.Input',\n    /** @lends pc.components.Input */\n    {\n        /**\n         * Constructs (or acquires from the pool) an input component.\n         * @param {Array} options.states Array of states, e.g. states:['fire',['SPACE','D']];\n         * @param {Array} options.actions Array of actions, e.g. actions:['fire',['SPACE','D']];\n         * @param {pc.Entity} [options.target] Optional target entity. If set, actions and states will be set on this,\n         * not the entity that contains the component. It will only be used for spatial positional.\n         * @return {pc.components.Spatial} A shiny new input component\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Input.prototype */\n    {\n        /** target entity where states and actions will be sent */\n        target: null,\n\n        /** array of input states */\n        states:null,\n        /** array of input actions */\n        actions: null,\n\n        _bound: false,\n\n        /**\n         * Internal constructor: use .create\n         */\n        init:function (options)\n        {\n            this._super('input');\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            if (!options.states && !options.actions)\n                throw 'Input requires at least an action or state set';\n\n            this.states = options.states;\n            this.actions = options.actions;\n            this.target = options.target;\n        }\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Fade\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Effects'>pc.systems.Effects</a>]\n * <p>\n * Adds a fade effects to the entity. e.g.\n * <pre><code>\n * entity.addComponent(\n *      pc.components.Fade.create( { holdTime: 1300, fadeOutTime:200 } ) );\n * </code></pre>\n */\npc.components.Fade = pc.components.Component.extend('pc.components.Fade',\n    /** @lends pc.components.Fade */\n    {\n        /**\n         * Constructs (or acquires from the pool) a fade component\n         * @param {Number} options.startDelay ms to wait before doing anything\n         * @param {Number} options.fadeInTime time to fade in (in ms)\n         * @param {Number} options.fadeOutTime time to fade out (in ms)\n         * @param {Number} options.holdTime time to hold between fading in and fading out (in ms)\n         * @param {Number} options.loops number of loops (0=infinite)\n         * @return {pc.components.Fade} A configured fade component\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Fade.prototype */\n    {\n        /** ms to wait before doing anything */\n        startDelay:0,\n        /** time to fade in (in ms) */\n        fadeInTime:0,\n        /** time to fade out (in ms) */\n        fadeOutTime:0,\n        /** time to hold between fading in and fading out (in ms) */\n        holdTime:0,\n        /** when the current state started */\n        startTime:0,\n        /** how long before we need to change states */\n        timeLimit:0,\n        /** current state */\n        state:0,\n        /** number of loops (0=infinite) */\n        loops:1,\n\n        /** read-only for how many loops have been completed */\n        loopsSoFar:0,\n\n        /**\n         * Constructs a new component. See create method for options\n         */\n        init:function ()\n        {\n            this._super('fade');\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            this.startDelay = pc.checked(options.startDelay, 0);\n            this.fadeInTime = pc.checked(options.fadeInTime, 0);\n            this.fadeOutTime = pc.checked(options.fadeOutTime, 0);\n            this.holdTime = pc.checked(options.holdTime, 0);\n            this.loops = pc.checked(options.loops, 1);\n            this.timeLimit = 0;\n            this.state = 0;\n            this.loopsSoFar = 0;\n        }\n    });",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Rect\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Render'>pc.systems.Render</a>]\n * <p>\n * Adds a rectangle to an entity.\n * <p>\n * To modify rectangle color at runtime, you can change the value of the lineColor and color\n * members by calling set (they are instances of pc.Color). For example:\n * <pre><code>\n *     myEntity.getComponent('rect').lineColor.set( [128, 128, 128] )\n * </code></pre>\n */\npc.components.Rect = pc.components.Component.extend('pc.components.Rect',\n  /** @lends pc.components.Rect */\n  {\n    /**\n     * Constructs (or acquires from the pool) a rectangle component.\n     * @param {String} options.color Fill color in the form of #RRGGBB.\n     * @param {String} options.lineColor Line color in the form of #RRGGBB\n     * @param {Number} options.lineWidth Stroke width\n     * @param {Number} options.cornerRadius Radius of the corners (defaults to 0)\n     * @return {pc.components.Rect} A rectangle component\n     */\n    create: function (options)\n    {\n      var n = this._super();\n      n.config(options);\n      return n;\n    }\n  },\n  /** @lends pc.components.Rect.prototype */\n  {\n    /** pc.Color representing fill color */\n    color: null,\n    /** pc.Color representing stroke color */\n    lineColor: null,\n    /** Stroke width */\n    lineWidth: 0,\n    /** radius of the corners (0=straight edges) */\n    cornerRadius: 0,\n\n    /**\n     * Constructs a new component. See create method for options\n     * @param {Object} options Options\n     */\n    init: function (options)\n    {\n      this._super('rect');\n      this.color = null;\n      this.lineColor = null;\n      if (pc.valid(options))\n        this.config(options);\n    },\n\n    /**\n     * Configures the component. See create method for options\n     * @param {Object} options Options\n     */\n    config: function (options)\n    {\n      if (options.color)\n      {\n        if (this.color == null)\n          this.color = pc.Color.create();\n\n        this.color.set(options.color); // can be null\n      } else\n        this.color = null;\n\n      if (options.lineColor)\n      {\n        if (!this.lineColor)\n          this.lineColor = pc.Color.create();\n\n        this.lineColor.set(options.lineColor);\n      } else\n        this.lineColor = null;\n\n      this.lineWidth = pc.checked(options.lineWidth, 1);\n      this.cornerRadius = pc.checked(options.cornerRadius, 0);\n    }\n\n  });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Text\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Render'>pc.systems.Render</a>]\n * <p>\n * Adds display text to an entity.\n */\npc.components.Text = pc.components.Component.extend('pc.components.Text',\n    /** @lends pc.components.Text */\n    {\n        /**\n         * Constructs (or acquires from the pool) a text component.\n         * @param {String} options.color Fill color in the form of #RRGGBB.\n         * @param {String} options.strokeColor Line color in the form of #RRGGBB\n         * @param {Number} options.lineWidth Stroke width\n         * @param {String} options.font Name of the font\n         * @param {Number} options.fontHeight Size/height of the font (i.e. 20 for 20pt)\n         * @param {String} options.text String to display\n         * @param {pc.Point} options.offset Object containing x, y properties. Offset position of the text.\n         * @return {pc.components.Text} A text component\n         */\n        create: function(options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Text.prototype */\n    {\n        /** pc.Color representing fill color */\n        color: null,\n        /** pc.Color representing stroke color */\n        strokeColor: null,\n        /** Font name (read-only - use setFont) */\n        font: null,\n        /** Font size: 20 = 20pt (read-only - use setHeight) */\n        fontHeight: 0,\n        /** Display text */\n        text: null,\n        /** Stroke width */\n        lineWidth: 0,\n        /** Offset position of the text relative to the entity spatial */\n        offset: null,\n\n        _fontCache: null,\n\n        /**\n         * Constructs a new component. See create method for options\n         * @param {Object} options Options\n         */\n        init: function(options)\n        {\n            this._super('text');\n            this.color = pc.Color.create('#ffffff');\n            this.strokeColor = pc.Color.create('#888888');\n            this.text = [];\n            this.font = 'Calibri';\n            this.fontHeight = 20;\n            this.offset = pc.Dim.create(0,0);\n            this._fontCache = '';\n            if (pc.valid(options))\n                this.config(options);\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config: function(options)\n        {\n            this.color.set(pc.checked(options.color, '#ffffff'));\n            this.strokeColor.set(pc.checked(options.strokeColor, '#888888'));\n            this.lineWidth = pc.checked(options.lineWidth, 0);\n            this.text = pc.checked(options.text, ['']);\n            this.font = pc.checked(options.font, 'Arial');\n            this.fontHeight = pc.checked(options.fontHeight, 20);\n            if (pc.valid(options.offset))\n            {\n                this.offset.x = pc.checked(options.offset.x);\n                this.offset.y = pc.checked(options.offset.y);\n            }\n            this._updateFont();\n        },\n\n        /**\n         * Sets the font height\n         * @param {Number} height Height in points (20=20pt)\n         */\n        setHeight: function(height)\n        {\n            this.fontHeight = height;\n            this._updateFont();\n        },\n\n        /**\n         * Sets the font\n         * @param {String} font Name of the font (i.e. 'Arial')\n         */\n        setFont: function(font)\n        {\n            this.font = font;\n            this._updateFont();\n        },\n\n        _updateFont: function()\n        {\n            this._fontCache = '' + this.fontHeight + 'px ' + this.font;\n        }\n\n\n    });\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Sprite\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Render'>pc.systems.Render</a>]\n * <p>\n * Adds a sprite to an entity. See the core <a href='pc.Sprite'>sprite</a> class for information on sprites.\n */\npc.components.Sprite = pc.components.Component.extend('pc.components.Sprite',\n    /** @lends pc.components.Sprite */\n    {\n        /**\n         * Constructs (or acquires from the pool) a sprite component.\n         * @param {pc.SpriteSheet} options.spriteSheet SpriteSheet to use\n         * @param {pc.Point} [options.offset] Object containing x, y properties. Offset position of the sprite.\n         * @param {string} [options.animationStart] Initial animation to play\n         * @param {string} [options.animationStartDelay=0] Delay in playing initial animation\n         * @param {Number} [options.currentFrame=0] Starting frame, or if not animated, the image index into the sprite sheet to show\n         * @return {pc.components.Sprite} A newly configured sprite component\n         */\n        create: function(options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Sprite.prototype */\n    {\n        /** sprite object */\n        sprite:null,\n        /** Offset position of the sprite relative to the entity spatial */\n        offset:null,\n\n        /**\n         * Constructs a new component. See create method for options\n         * @param {Object} [options] Options\n         */\n        init: function(options)\n        {\n            this._super('sprite');\n            this.sprite = pc.Sprite.create();\n            this.offset = pc.Point.create(0,0);\n            if (pc.valid(options))\n                this.config(options);\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config: function(options)\n        {\n            var spriteSheet = pc.checked(options.spriteSheet, null);\n            if (spriteSheet == null)\n                throw this.getUniqueId() + ': no spritesheet specified';\n\n            this.sprite.setSpriteSheet(spriteSheet);\n\n            if (pc.valid(options.offset))\n            {\n                this.offset.x = pc.checked(options.offset.x, 0);\n                this.offset.y = pc.checked(options.offset.y, 0);\n            } else\n            {\n                this.offset.x = 0;\n                this.offset.y = 0;\n            }\n\n            var animationStart = pc.checked(options.animationStart, null);\n            var animationStartDelay = pc.checked(options.animationStartDelay, 0);\n            if (animationStart != null)\n                this.sprite.setAnimation(animationStart, animationStartDelay);\n\n            this.sprite.currentFrame = pc.checked(options.currentFrame, 0);\n        }\n\n\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.Layout\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Layout'>pc.systems.Layout</a>]\n * <p>\n * Automatically positions an entity on screen using a variety of layout options.\n * <p>\n * To use automated layout, add the layout system to the layer containing the entity:\n * <pre><code>\n * gameLayer.addSystem(new pc.systems.Layout());\n * </code></pre>\n * You can then add a layout component to an entity. The layout system will then automatically position the entity\n * bassed on the chosen alignment, and accomodating a given margin.\n * <pre><code>\n * entity.addComponent(pc.components.Layout.create(\n *     { vertical:'middle', horizontal:'right', margin:{ right:80 } }));\n * </code></pre>\n * Multiple items will be stacked vertically.\n */\npc.components.Layout = pc.components.Component.extend('pc.components.Layout',\n    /** @lends pc.components.Layout */\n    {\n        /**\n         * Constructs (or acquires from the pool) a layout component\n         * @param {String} options.vertical Vertical positioning: 'top', 'middle', 'bottom'\n         * @param {String} options.horizontal Horizontal positioning: 'left', 'center', 'right'\n         * @param {Object} options.margin Margin for the entity (ie. margin.left, right, top, bottom)\n         * @return {pc.components.Layout} A newly configured layout component\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.Layout.prototype */\n    {\n        /** Vertical positioning: 'top', 'middle', 'bottom' */\n        vertical:null,\n        /** Horizontal positioning: 'left', 'center', 'right' */\n        horizontal:null,\n        /** margin offset to the position */\n        margin:null,\n\n        /**\n         * Constructs a new component. See create method for options\n         */\n        init:function ()\n        {\n            this._super('layout');\n            this.margin = {};\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            if (pc.checked(options.margin))\n            {\n                this.margin.left = pc.checked(options.margin.left, 0);\n                this.margin.right = pc.checked(options.margin.right, 0);\n                this.margin.top = pc.checked(options.margin.top, 0);\n                this.margin.bottom = pc.checked(options.margin.bottom, 0);\n            } else\n            {\n                this.margin.left = 0;\n                this.margin.right = 0;\n                this.margin.top = 0;\n                this.margin.bottom = 0;\n            }\n\n            this.horizontal = pc.checked(options.horizontal, 'left');\n            this.vertical = pc.checked(options.vertical, 'top');\n        }\n\n\n    });",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.components.ParticleEmitter\n * @description\n * [Extends <a href='pc.components.Component'>pc.components.Component</a>]<BR>\n * [Used in <a href='pc.systems.Particles'>pc.systems.Particles</a>]\n * <p>\n * A particle generator.\n */\npc.components.ParticleEmitter = pc.components.Component.extend('pc.components.ParticleEmitter',\n    /** @lends pc.components.ParticleEmitter */\n    {\n        /**\n         * Constructs (or acquires from the pool) a particle emitter component\n         * @param {Object} options See member list for available options\n         * @return {pc.components.ParticleEmitter} A newly configured emitter component\n         */\n        create:function (options)\n        {\n            var n = this._super();\n            n.config(options);\n            return n;\n        }\n    },\n    /** @lends pc.components.ParticleEmitter.prototype */\n    {\n        /** set to false to pause the emitter (and all emissions) */\n        active: true,\n        /** set to false to stop new emissions, but still update existing ones */\n        emitting: true,\n        /** minimum amount to grow particles at (negative values shrink) x-axis */\n        growXMin:0,\n        /** maximum amount to grow particles at x-axis (defaults to growXMin) */\n        growXMax:0,\n        /** minimum amount to grow particles at (negative values shrink) y-axis */\n        growYMin:0,\n        /** maximum amount to grow particles at y-axis (defaults to growYMin) */\n        growYMax:0,\n        /** scaling of the image on x-axis (minimum) */\n        scaleXMin: 0,\n        /** scaling maximum. if different to min a random scale is chosen */\n        scaleXMax: 0,\n        /** scaling of the image on y-axis (minimum) */\n        scaleYMin: 0,\n        /** scaling maximum. if different to min a random scale is chosen */\n        scaleYMax: 0,\n        /** time to spend fading in the particle */\n        fadeInTime: 0,\n        /** time spent fading out the particle */\n        fadeOutTime: 0,\n        /** minimum angle (direction) to fire a particle in */\n        angleMin: 0,\n        /** maximum angle (direction) to fire a particle in */\n        angleMax: 0,\n        /** minimum speed */\n        thrustMin: 0,\n        /** (optional) maximum speed (default is speed minimum */\n        thrustMax: 0,\n        /** how long to thrust for */\n        thrustTime: 0,\n        /** min amount of spin on the particle (in degrees per second) */\n        spinMin: 0,\n        /** max spin (random spin chosen between min and max) */\n        spinMax: 0,\n        /** distribution of particles over x range */\n        rangeX: 1,\n        /** distribution of particles over y */\n        rangeY: 1,\n        /** number to fire out on each emission */\n        burst: 1,\n        /** delay time between emissions in ms */\n        delay: 25,\n        /** spritesheet to use (a particle = a frame) */\n        spriteSheet: null,\n        /** minimum life span of particles */\n        lifeMin: 0,\n        /** max life span (random life span = max-min) */\n        lifeMax: 0,\n        /** whether sprite should rotate with angle changes */\n        rotateSprite: false,\n        /** x position offset (from the position of the entity) */\n        offsetX: null,\n        /** y position offset (from the position of the entity) */\n        offsetY: null,\n        /** composite operation on the image */\n        compositeOperation: null,\n        /** whether particle angles should be relative to the entity I'm attached to */\n        relativeAngle: true,\n        /** number of shots the emitter shold fire (self destructs after this). 0=repeat continuously */\n        shots: 0,\n        /** minimum range of alpha to randomly change opacity/alpha */\n        alphaMin: 1,\n        /** minimum range of alpha to randomly change opacity/alpha */\n        alphaMax: 1,\n        /** delay before changing alpha */\n        alphaDelay: 0,\n\n        _particles: null,\n        _lastEmitTime: 0,\n        _shotCount: 0,\n\n        /**\n         * Constructs a new component. See create method for options\n         * @param {Object} options Options\n         */\n        init:function (options)\n        {\n            this._super('emitter');\n            if (pc.valid(options))\n                this.config(options);\n        },\n\n        /**\n         * Reset the emitter to start again\n         */\n        reset: function()\n        {\n            this._shotCount = 0;\n            this._lastEmitTime = 0;\n        },\n\n        /**\n         * Configures the component. See create method for options\n         * @param {Object} options Options\n         */\n        config:function (options)\n        {\n            this._lastEmitTime = 0;\n            this._shotCount = 0;\n\n            this.active = pc.checked(options.active, true);\n            this.emitting = pc.checked(options.emitting, true);\n            this.growXMin = pc.checked(options.growXMin, 0);\n            this.growXMax = pc.checked(options.growXMax, this.growXMin);\n            this.growYMin = pc.checked(options.growYMin, 0);\n            this.growYMax = pc.checked(options.growYMax, this.growYMin);\n            this.scaleXMin = pc.checked(options.scaleXMin, 1);\n            this.scaleYMin = pc.checked(options.scaleYMin, 1);\n            this.scaleXMax = pc.checked(options.scaleXMax, 1);\n            this.scaleYMax = pc.checked(options.scaleYMax, 1);\n            this.compositeOperation = pc.checked(options.compositeOperation, null);\n            this.alphaMin = pc.checked(options.alphaMin, 1);\n            this.alphaMax = pc.checked(options.alphaMax, this.alphaMin);\n            this.alphaDelay = pc.checked(options.alphaDelay, 50);\n            this.shots = pc.checked(options.shots, 0);\n            this.relativeAngle = pc.checked(options.relativeAngle, true);\n\n            this.rangeX = pc.checked(options.rangeX, 1);\n            this.rangeY = pc.checked(options.rangeY, 1);\n            this.fadeInTime = pc.checked(options.fadeInTime, 0);\n            this.fadeOutTime = pc.checked(options.fadeOutTime, 0);\n            this.angleMin = pc.checked(options.angleMin, 0);\n            this.angleMax = pc.checked(options.angleMax, 359);\n            this.thrustMin = pc.checked(options.thrustMin, 1);\n            this.thrustMax = pc.checked(options.thrustMax, this.thrustMin);\n            this.thrustTime = pc.checked(options.thrustTime, 100);\n            this.burst = pc.checked(options.burst, 1);\n            this.delay = pc.checked(options.delay, 25);\n            this.lifeMin = pc.checked(options.lifeMin, 100);\n            this.lifeMax = pc.checked(options.lifeMin, this.lifeMin);\n            this.rotateSprite = pc.checked(options.rotateSprite, false);\n            this.spinMin = pc.checked(options.spinMin, 0);\n            this.spinMax = pc.checked(options.spinMax, this.spinMin);\n            this.offsetX = pc.checked(options.offsetX, 0);\n            this.offsetY = pc.checked(options.offsetY, 0);\n            this.gravityX = pc.checked(options.gravityX, 0);\n            this.gravityY = pc.checked(options.gravityY, 0);\n            this.maxVelX = pc.checked(options.maxVelX, 50);\n            this.maxVelY = pc.checked(options.maxVelY, 50);\n\n            if (!pc.valid(options.spriteSheet))\n                throw \"A spritesheet is required for the emitter\";\n            else\n                this.spriteSheet = options.spriteSheet;\n\n            if (!Array.isArray(this._particles))\n                this._particles = new pc.LinkedList();\n            else\n                this._particles.clear();\n        },\n\n        onBeforeRemoved: function()\n        {\n            // being removed from entity, so need to release any particles that\n            // are left back into the pool\n            var p = this._particles.first;\n            while (p)\n            {\n                p.obj.release();\n                p = p.next();\n            }\n        }\n\n    });",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.EntityManager\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * Manages entities in a layer. This is the primary entity manager for the entity system. It contains, indexes and\n * handles the lifecycle of all entities.\n *\n * Unless you are building your own systems in a complex way, you should be using the pc.EntityLayer to handle\n * general entity management.\n */\npc.EntityManager = pc.Base.extend('pc.EntityManager',\n  /** @lends pc.EntityManager */\n  {},\n  /** @lends pc.EntityManager.prototype */\n  {\n    /** Index of all entities by tag */\n    entitiesByTag: null,\n    /** All the components indexed by entityID (as a linked list) */\n    componentsByEntity: null,\n    /** All the components, indexed by entityId and componentType (catted) */\n    componentsByEntityPlusType: null,\n\n    /** Linked list of all entities */\n    entities: null,\n    /** entities to be removed at the end of processing */\n    entitySuicides: null,\n    /** the layer this entitymanager is within (set by the layer class) */\n    layer: null,\n\n    /**\n     * Constructs a new entity manager\n     * @param {pc.EntityLayer} layer The entity layer this entity manager is doing work for\n     */\n    init: function (layer)\n    {\n      this.layer = layer;\n      this.entitiesByTag = new pc.HashList();\n      this.entities = new pc.LinkedList();\n      this.componentsByEntity = new pc.Hashmap();\n      this.componentsByEntityPlusType = new pc.Hashmap();\n      this.entitySuicides = new pc.LinkedList();\n    },\n\n    /**\n     * Called by the core game loop to give the manager a chance to cleanup\n     */\n    cleanup: function ()\n    {\n      var entity = this.entitySuicides.first;\n      while (entity)\n      {\n        this._doRemoveEntity(entity.object());\n        entity = entity.next();\n      }\n\n      this.entitySuicides.clear();\n    },\n\n    /**\n     * Adds an entity to the manager\n     * @param {pc.Entity} entity Entity to add\n     * @param {String} [tag] A convenient way to add an entity and tag at the same time\n     */\n    add: function (entity, tag)\n    {\n      // add the entity to our big global map\n      this.entities.add(entity);\n      if (tag != undefined)\n        this.entitiesByTag.add(tag, entity);\n\n      // add this entity to the component type indexes\n      var componentMap = entity.getAllComponents();\n      if (componentMap != null)\n      {\n        var components = componentMap.values();\n        for (var i = 0; i < components.length; i++)\n          this._addToComponentMap(entity, components[i]);\n      }\n\n      // let the system manager take care of business\n      this.layer.systemManager._handleEntityAdded(entity);\n    },\n\n    /**\n     * Removes an entity from the manager\n     * @param {pc.Entity} entity Entity to remove\n     */\n    remove: function (entity)\n    {\n      if (!this.entitySuicides.has(entity))\n      {\n        this.entitySuicides.add(entity);\n        entity.active = false;\n      }\n    },\n\n    /**\n     * Removes a component from an entity, and releases it back to the pool\n     * @param {pc.Entity} entity Entity to remove the component from\n     * @param {pc.components.Component} component Component to remove\n     */\n    removeComponent: function (entity, component)\n    {\n      this._removeFromComponentMap(entity, component);\n      entity._handleComponentRemoved(component);\n      this.layer.systemManager._handleComponentRemoved(entity, component);\n      component._entity = null;\n    },\n\n    /**\n     * Adds a tag to an entity\n     * @param {pc.Entity} entity Entity to add the tag to\n     * @param {String} tag Tag to assign to the entity\n     */\n    addTag: function (entity, tag)\n    {\n      if (entity.tags.indexOf(tag.toLowerCase()) != -1) return;\n\n      this.entitiesByTag.add(tag.toLowerCase(), entity);\n      entity.tags.push(tag.toLowerCase());\n    },\n\n    /**\n     * Removes a tag from an entity\n     * @param {pc.Entity} entity Entity to remove the tag from\n     * @param {String} tag Tag to remove\n     */\n    removeTag: function (entity, tag)\n    {\n      this.entitiesByTag.remove(tag.toLowerCase(), entity);\n      pc.Tools.arrayRemove(entity.tags, tag.toLowerCase());\n    },\n\n    /**\n     * Gets all the entities that have a given tag\n     * @param {String} tag Tag to match\n     * @return {pc.LinkedList} List of entities\n     */\n    getTagged: function (tag)\n    {\n      return this.entitiesByTag.get(tag.toLowerCase());\n    },\n\n    /**\n     * Makes an entity active (processed by systems).\n     * @param entity {pc.Entity} Entity to make active\n     */\n    activate: function (entity)\n    {\n      if (entity.active) return;\n\n      this.layer.systemManager._handleEntityAdded(entity);\n      entity.active = true;\n    },\n\n    /**\n     * Makes an entity inactive (no longer processed)\n     * @param {pc.Entity} entity Entity to deactivate\n     */\n    deactivate: function (entity)\n    {\n      if (!entity.active) return;\n\n      // remove from the systems - we still keep it in the entitymanager lists, but remove it\n      // from the systems so it wont be processed anymore\n      this.layer.systemManager._handleEntityRemoved(entity);\n\n      // mark as inactive\n      entity.active = false;\n    },\n\n    _doRemoveEntity: function (entity)\n    {\n      this.entities.remove(entity);\n      var componentMap = entity.getAllComponents();\n      if (componentMap != null)\n      {\n        var components = componentMap.values();\n        for (var i = 0; i < components.length; i++)\n          this._removeFromComponentMap(entity, components[i]);\n      }\n\n      // remove entities from any tag map it exists in\n      for (var t = 0; t < entity.tags.length; t++)\n        this.entitiesByTag.remove(entity.tags[t], entity);\n\n      this.layer.systemManager._handleEntityRemoved(entity);\n\n      entity.release();\n    },\n\n    /**\n     * Add a component to an entity\n     * @param {pc.Entity} entity Entity to add the component to\n     * @param {pc.components.Component} component Component to add\n     * @return {pc.components.Component} Component that was added (for convience)\n     */\n    addComponent: function (entity, component)\n    {\n      // make sure this entity is in the correct component maps\n      this._addToComponentMap(entity, component);\n      entity._handleComponentAdded(component);\n      this.layer.systemManager._handleComponentAdded(entity, component);\n      component._entity = entity;\n      return component;\n    },\n\n    /**\n     * Get a component of a given class from an entity\n     * @param {pc.Entity} entity Entity that has the component you're looking for\n     * @param {String} componentType Class of component to get (e.g. pc.component.Position)\n     */\n    getComponent: function (entity, componentType)\n    {\n      return this.componentsByEntityPlusType.get(entity.uniqueId + ':' + componentType);\n    },\n\n    /**\n     * Gets the components in an entity\n     * @param {pc.Entity} entity Entity you want the components of\n     * @return {pc.Hashtable} Hashtable of components keyed by component type\n     */\n    getComponents: function (entity)\n    {\n      return this.componentsByEntity.get(entity.uniqueId);\n    },\n\n    /**\n     * Checks if a given entity contains a component of a given type\n     * @param {pc.Entity} entity Entity to check\n     * @param {String} componentType Type to check for\n     */\n    hasComponentOfType: function (entity, componentType)\n    {\n      return this.componentsByEntityPlusType.containsKey(entity.uniqueId + ':' + componentType);\n    },\n\n    //\n    // INTERNALS\n    //\n    _addToComponentMap: function (entity, component)\n    {\n      // Seeing a getType error here? Likely, you didn't call .create on your component? just maybe? hint hint\n      if (this.componentsByEntityPlusType.get(entity.uniqueId + ':' + component.getType()))\n      {\n        // multiple components of the same type are not supported due to performance reasons\n        throw ('adding component ' + component.getType() +\n          ' to entity ' + entity + ' when it already has one of that type');\n      }\n      this.componentsByEntityPlusType.put(entity.uniqueId + ':' + component.getType(), component);\n      // seeing a getType error above? -- you forgot to use .create when constructing the component\n      this.componentsByEntity.put(entity.uniqueId, component);\n    },\n\n    _removeFromComponentMap: function (entity, component)\n    {\n      // need to handle removing an entity that has attachments, remove the attached entities as well\n      component.onBeforeRemoved();\n\n      this.componentsByEntityPlusType.remove(entity.uniqueId + ':' + component.getType());\n      this.componentsByEntity.remove(entity.uniqueId);\n      component.release();\n    }\n\n\n\n  });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.SystemManager\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * Manages systems that are within a layer.\n *\n * Unless you are building your own systems in a complex way, you should be using the pc.EntityLayer to handle\n * general system management.\n */\npc.SystemManager = pc.Base.extend('pc.SystemManager',\n    /** @lends pc.SystemManager */\n    {},\n    /** @lends pc.SystemManager.prototype */\n    {\n        /** pc.LinkedList of systems */\n        systems:null,\n        /** Index of the systems by component type */\n        systemsByComponentType:null,\n        /** layer the system is on */\n        layer:null,\n\n        /**\n         * Constructs a system manager.\n         */\n        init:function (layer)\n        {\n            this.systems = new pc.LinkedList();\n            this.systemsByComponentType = new pc.Hashtable();\n            this.layer = layer;\n        },\n\n        /**\n         * Adds a system to the system manager\n         * @param {pc.systems.System} system System to add\n         */\n        add:function (system)\n        {\n            system.layer = this.layer;\n            system.systemManager = this;\n\n            this.systems.add(system);\n\n            if (!pc.valid(system.componentTypes))\n                throw 'Invalid component types: it can be empty, but not undefined. Did you forget to ' +\n                    'add an init method to your system and/or not call this._super(componentTypes)';\n\n            for (var i = 0; i < system.componentTypes.length; i++)\n            {\n                var ctype = system.componentTypes[i].toLowerCase();\n\n                var list = this.systemsByComponentType.get(ctype);\n                if (list == null)\n                {\n                    // create a new linked list for systems matching this component type\n                    list = new pc.LinkedList();\n                    this.systemsByComponentType.put(ctype, list);\n                }\n\n                // add this system to the component type map, but only if it hasn't been added already\n                if (!list.has(system))\n                    list.add(system);\n            }\n\n            // add all the entities to this system\n            var entity = this.layer.entityManager.entities.first;\n            while (entity)\n            {\n                this._handleEntityAdded(entity.object());\n                entity = entity.next();\n            }\n\n            system.onAddedToLayer(this.layer);\n        },\n\n        /**\n         * Removes a system from the system manager\n         * @param {pc.systems.System} system System to remove\n         */\n        remove:function (system)\n        {\n            system.onRemovedFromLayer(system.layer);\n            this.systems.remove(system);\n\n            for (var i = 0; i < system.componentTypes; i++)\n            {\n                var list = this.systemsByComponentType.get(system.componentTypes[i].toLowerCase());\n                assert(list != null, \"Oops, trying to remove a system and it's not in the by type list\");\n\n                system.systemManager = null;\n                list.remove(system);\n            }\n        },\n\n        /**\n         * Gets systems based on a component type\n         * @param {String} componentType Component type\n         * @return {pc.LinkedList} A linked list of the systems that have the given component type\n         */\n        getByComponentType:function (componentType)\n        {\n            return this.systemsByComponentType.get(componentType);\n        },\n\n        /**\n         * Called when the origin of the layer changes\n         * @param {Number} x x-position of the origin\n         * @param {Number} y y-position of the origin\n         */\n        onOriginChange:function (x, y)\n        {\n            var system = this.systems.first;\n            while (system)\n            {\n                system.object().onOriginChange(x, y);\n                system = system.next();\n            }\n        },\n\n        _handleEntityAdded:function (entity)\n        {\n            // grab a list of all the component types from the entity\n            var componentTypes = entity.getComponentTypes();\n            for (var i = 0; i < componentTypes.length; i++)\n            {\n                // for every type, grab all the systems that use this type and add this entity\n                var systems = this.systemsByComponentType.get(componentTypes[i].toLowerCase());\n                if (systems)\n                {\n                    var next = systems.first;\n                    while (next)\n                    {\n                        // add will check to make sure this entity isn't in there already\n                        next.obj.add(entity);\n                        next = next.next();\n                    }\n                }\n            }\n        },\n\n        _handleEntityRemoved:function (entity)\n        {\n            // grab a list of all the component types from the entity\n            var componentMap = entity.getAllComponents();\n            if (componentMap == null) return;\n            var componentTypes = componentMap.keys();\n\n            for (var i = 0; i < componentTypes.length; i++)\n            {\n                // for every type, grab all the systems that use this type and add this entity\n                var systems = this.systemsByComponentType.get(componentTypes[i].toLowerCase());\n                if (systems)\n                {\n                    var next = systems.first;\n                    while (next)\n                    {\n                        // just a plain removal, since this entity is going entirely\n                        next.obj.remove(entity);\n                        next = next.next();\n                    }\n                }\n            }\n        },\n\n        _handleComponentAdded:function (entity, component)\n        {\n            // get a list of all the systems that are processing components of this type\n            // then ask that system to add this entity, if it's not already there\n            var list = this.systemsByComponentType.get(component.getType());\n            if (list == null)\n            {\n                // this.warn('Entity (' + entity.toString() + ' added component ' + component + ' but no system is ' +\n                //    ' handling components of type: ' + component.getType() +'. Did you forget to add a system' +\n                //    ' to the system manager (and was it added to the same layer as this entity)?');\n                return;\n            }\n\n            // todo: the systemsByComponentType map doesn't work well if systems support\n            // multiple components; need to take a fresh look at that if multiple component types\n            // support is added to systems (probably change the systemsByComponentType map support combinations\n            // of components as a compound key (which map to a set of matching systems with no duplicates\n            var next = list.first;\n            while (next)\n            {\n                next.obj.add(entity);\n                next.obj.onComponentAdded(entity, component);\n                next = next.next();\n            }\n        },\n\n        _handleComponentRemoved:function (entity, component)\n        {\n            // get a list of all the systems that are processing components of a given type\n            var list = this.systemsByComponentType.get(component.getType());\n            if (list == null) return;\n\n            var next = list.first;\n            while (next)\n            {\n                // then ask that system to remove this entity, but be careful that it no longer matches\n                // another type might still apply to a given system\n                next.obj.removeIfNotMatched(entity);\n                next.obj.onComponentRemoved(entity, component);\n                next = next.next();\n            }\n\n        },\n\n        /**\n         * Process all the systems\n         */\n        processAll:function ()\n        {\n            var next = this.systems.first;\n            while (next)\n            {\n                if (next.obj.delay == 0 || (pc.device.now - next.obj._lastRun > next.obj.delay))\n                {\n                    next.obj.processAll();\n                    if (next.obj.delay != 0)\n                        next.obj._lastRun = pc.device.now;\n                }\n                next = next.next();\n            }\n        },\n\n        /**\n         * Called when the layer resizes\n         * @param {Number} width Width of the layer\n         * @param {Number} height Height of the layer\n         */\n        onResize:function (width, height)\n        {\n            var next = this.systems.first;\n            while (next)\n            {\n                next.obj.onResize(width, height);\n                next = next.next();\n            }\n        }\n\n\n\n    });",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\npc.systems = {};\n\n/**\n * @class pc.systems.System\n * @description\n * [Extends <a href='pc.Base'>pc.Base</a>]\n * <p>\n * The base class for all systems. See the entity systems guide for more information on creating your own systems.\n */\n\npc.systems.System = pc.Base.extend('pc.System',\n    /** @lends pc.systems.System */\n    { },\n    /** @lends pc.systems.System.prototype */\n    {\n        /** layer this system is on */\n        layer: null,\n        /** array of string component types this system handles */\n        componentTypes: null,\n        /** reference to the systems system manager (read-only) */\n        systemManager: null,\n        /** optional delay for running this system, default is 0 (which means run every cycle) */\n        delay: 0,\n\n        _lastRun: 0,\n\n        /**\n         * Constructs a new system\n         * @param {Array} componentTypes Array of strings representing the component types this system will handle\n         * @param {Number} delay Amount of time delay in ms between runs. i.e. systems that don't need to run every.\n         */\n        init: function(componentTypes, delay)\n        {\n            this._super();\n            this.delay = pc.checked(delay, 0);\n            if (!componentTypes instanceof Array)\n                throw \"Invalid component types array. Use a blank array ([]) if there are no components handled by the system.\";\n            this.componentTypes = componentTypes;\n        },\n\n        /**\n         * Called by the system manager to allow this system to take care of business. This default does nothing.\n         */\n        processAll: function()\n        {\n        },\n\n        /**\n         * Called by the system when the layer has changed size\n         */\n        onResize: function()\n        {\n        },\n\n        /**\n         * Called by the system when the origin changes\n         */\n        onOriginChange: function(x, y)\n        {\n        },\n\n        /**\n         * Called when this system instance is added to a layer\n         */\n        onAddedToLayer: function(layer)\n        {\n        },\n\n        /**\n         * Called when this system instance is removed from a layer\n         */\n        onRemovedFromLayer:function (layer)\n        {\n        }\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.systems.EntitySystem\n * @description\n * [Extends <a href='pc.Base'>pc.System</a>]\n * <p>\n * A system that processes entities.\n */\npc.systems.EntitySystem = pc.systems.System.extend('pc.systems.EntitySystem',\n    /** @lends pc.systems.EntitySystem */\n    {},\n    /** @lends pc.systems.EntitySystem.prototype */\n    {\n        /** list of entities that are to be process by this system */\n        entities: null,\n        /** holding place for entities that are to be removed at the end of each cycle */\n        suicides: null,\n\n        /**\n         * Constructor for a system\n         * @param {Array} componentTypes An array of component types this system is interested in. Any entity with\n         * a component matching this type will be sent to this system for processing.\n         * @param {Number} delay Amount of time between cycles for this system (default = 0)\n         */\n        init: function(componentTypes, delay)\n        {\n            this._super(componentTypes, delay);\n            this.entities = new pc.LinkedList();\n            this.suicides = new pc.LinkedList();\n        },\n\n        /**\n         * Adds an entity to this system, but only if the entity has a component type matching one of the types\n         * used by this system (this.componentTypes)\n         * @param {pc.Entity} entity Entity to add (if the entity's component type matches the systems\n         */\n        addIfMatched: function(entity)\n        {\n            // checks the entity to see if it should be added to this system\n            for (var i=0; i < this.componentTypes.length; i++)\n                if (entity.hasComponentOfType(this.componentTypes[i]))\n                {\n                    this.entities.add(entity);\n                    this.onEntityAdded(entity);\n                    return; // we only need to add an entity once\n                }\n        },\n\n        /**\n         * Adds an entity to the system\n         * @param {pc.Entity} entity Entity to add\n         */\n        add: function(entity)\n        {\n            if (this.entities.has(entity)) return; // already in the list\n            this.entities.add(entity);\n            this.onEntityAdded(entity);\n        },\n\n        /**\n         * Removes an entity from this system -- ignored if the entity isn't there\n         * @param {pc.Entity} entity Entity to remove\n         */\n        remove: function(entity)\n        {\n            if (this.entities.remove(entity)) // return true if one was removed\n                this.onEntityRemoved(entity);\n        },\n\n        /**\n         * Removes an entity from this system, but checks to see if it still matches first (has a component of\n         * the correct type). This is called by the entity manager when a component is removed. Typically\n         * this is called after a component has been removed. We then check if it's ok to pull the entity which\n         * contained the component from the system, but we have to make sure there isn't another component on the\n         * entity that still matches for this system (in which case we don't remove it).\n         * @param {pc.Entity} entity Entity to remove\n         */\n        removeIfNotMatched: function(entity)\n        {\n            // checks the entity to see if it should be added to this system\n            for (var i=0; i < this.componentTypes.length; i++)\n            {\n                if (entity.hasComponentOfType(this.componentTypes[i]))\n                    return; // still matches, abort removing\n            }\n\n            // we got to here, so nothing matched, ok to remove the entity\n            this.remove(entity);\n        },\n\n        /**\n         * Processes all entities. If you override this method, make sure you call this._super() to give the entity\n         * system a chance to process and clean up all entities.\n         */\n        processAll: function()\n        {\n            var next = this.entities.first;\n            while (next)\n            {\n                this.process(next.obj);\n                next = next.next();\n            }\n\n            next = this.suicides.first;\n            while (next)\n            {\n                this.remove(next.obj);\n                next = next.next();\n            }\n            this.suicides.clear();\n\n        },\n\n        /**\n         * Override this in your system to handle updating of matching entities\n         * @param {pc.Entity} entity Entity to update\n         */\n        process: function(entity) {},\n\n        /**\n         * Adds the entity to the suicide list; it will be removed at the end of the cycle.\n         * @param entity\n         */\n        suicide: function(entity)\n        {\n            this.suicides.add(entity);\n        },\n\n        /**\n         * Called when an entity has been added to this system\n         * @param {pc.Entity} entity Entity that was added\n         */\n        onEntityAdded: function(entity) {},\n\n        /**\n         * Called when an entity has been removed from this system\n         * @param {pc.Entity} entity Entity that was removed\n         */\n        onEntityRemoved: function(entity) {},\n\n        /**\n         * Called when a component is added to an entity\n         * @param {pc.Entity} entity Entity the component was added to\n         * @param {pc.components.Component} component Component that was added\n         */\n        onComponentAdded: function(entity, component) {},\n\n        /**\n         * Called when a component is removed from an entity\n         * @param {pc.Entity} entity Entity the component was removed from\n         * @param {pc.components.Component} component Component that was removed\n         */\n        onComponentRemoved: function(entity, component) {}\n\n    });\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\npc.CollisionShape = {\n  RECT: 0, // rectangular collision area\n  CIRCLE: 1, // circular\n  POLY: 2     // a polygon\n};\n\npc.BodyType = {\n  ENTITY: 0,\n  TILE: 1\n};\n\n/**\n * @class pc.systems.Physics\n * @description\n * [Extends <a href='pc.systems.System'>pc.systems.System</a>]\n * <p>\n * A 2D physics system for entities. See the <a href='pc.components.Physics'>physics component</a> and\n * <a href='/develop/guide/physics'>physics guide</a>.\n */\npc.systems.Physics = pc.systems.EntitySystem.extend('pc.systems.Physics',\n  /** @lends pc.systems.Physics */\n  {\n    /** scale of the physics systems relative to 1 pixel */\n    SCALE: 0.1,\n\n    /** static function to convert from a screen coordinate to physics space */\n    toP: function (a)\n    {\n      return a * this.SCALE;\n    },\n\n    /** static function to convert from a physics coordinate to a screen space */\n    fromP: function (a)\n    {\n      return a / this.SCALE;\n    }\n  },\n  /** @lends pc.systems.Physics.prototype */\n  {\n    /** the physics world */\n    world: null,\n    /** current gravity (pc.Dim) */\n    gravity: null,\n    /** whether debugging is enabled */\n    debug: false,\n\n    debugDraw: null,\n\n    /**\n     * Constructs a new physics systems with options.\n     * @param {pc.Dim} options.gravity Level of gravity as a 2D vector (gravity.x, gravity.y)\n     * @param {pc.TileMap} options.tileCollisionMap.tileMap A tile map which will be used to construct tile collisions\n     * @param {Number} options.tileCollisionMap.collisionCategory Collision category for the tile map\n     * @param {Number} options.tileCollisionMap.collisionMask Collision mask for the tile map\n     * @param {Number} options.tileCollisionMap.collisionGroup Collision group for the tile map\n     * @param {Boolean} options.debug Whether debugging is enabled\n     */\n    init: function (options)\n    {\n      this._super([ 'physics' ]);\n\n      if (options && options.gravity)\n        this.gravity = pc.Point.create(pc.checked(options.gravity.x, 0), pc.checked(options.gravity.y, 0));\n      else\n        this.gravity = pc.Point.create(0, 0);\n\n      var gravity = new Box2D.Common.Math.b2Vec2(this.gravity.x * this.Class.SCALE, this.gravity.y * this.Class.SCALE);\n      this.world = new Box2D.Dynamics.b2World(gravity, true);\n\n      if (options && pc.valid(options.tileCollisionMap))\n      {\n        pc.assert(pc.valid(options.tileCollisionMap.tileMap), 'A tileMap is required for a tileCollisionMap');\n        this.addTileCollisionMap(\n          options.tileCollisionMap.tileMap,\n          pc.checked(options.tileCollisionMap.collisionGroup, 0),\n          pc.checked(options.tileCollisionMap.collisionCategory, 0),\n          pc.checked(options.tileCollisionMap.collisionMask, 0));\n      }\n\n      // setup the contact listeners\n      var listener = new Box2D.Dynamics.b2ContactListener;\n      listener.BeginContact = this._beginContactListener.bind(this);\n      listener.EndContact = this._endContactListener.bind(this);\n      listener.PostSolve = this._postSolveListener.bind(this);\n      this.world.SetContactListener(listener);\n\n      // setup debug drawing\n      var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;\n      this.debugDraw = new b2DebugDraw();\n      this.debugDraw.SetSprite(pc.device.ctx);\n      this.debugDraw.SetDrawScale(this.Class.SCALE * 100);\n      this.debugDraw.SetFillAlpha(0.3);\n      this.debugDraw.SetLineThickness(1.0);\n      this.debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit | b2DebugDraw.e_centerOfMassBit);\n\n      if (options && options.debug == true)\n      {\n        this.debug = options.debug;\n        this.setDebug(options.debug);\n      }\n    },\n\n    _beginContactListener: function (contact)\n    {\n      this.onCollisionStart(\n        contact.GetFixtureA().GetBody()._pc_bodyType,\n        contact.GetFixtureB().GetBody()._pc_bodyType,\n        contact.GetFixtureA().GetBody().GetUserData(),\n        contact.GetFixtureB().GetBody().GetUserData(),\n        contact.GetFixtureA()._pc_type,\n        contact.GetFixtureB()._pc_type,\n        contact);\n    },\n\n    _endContactListener: function (contact)\n    {\n      this.onCollisionEnd(\n        contact.GetFixtureA().GetBody()._pc_bodyType,\n        contact.GetFixtureB().GetBody()._pc_bodyType,\n        contact.GetFixtureA().GetBody().GetUserData(),\n        contact.GetFixtureB().GetBody().GetUserData(),\n        contact.GetFixtureA()._pc_type,\n        contact.GetFixtureB()._pc_type,\n        contact);\n    },\n\n    _postSolveListener: function (contact, impulse)\n    {\n      var i = impulse.normalImpulses[0];\n      this.onCollision(\n        contact.GetFixtureA().GetBody()._pc_bodyType,\n        contact.GetFixtureB().GetBody()._pc_bodyType,\n        contact.GetFixtureA().GetBody().GetUserData(),\n        contact.GetFixtureB().GetBody().GetUserData(),\n        i,\n        contact.GetFixtureA()._pc_type,\n        contact.GetFixtureB()._pc_type,\n        contact);\n    },\n\n    /**\n     * Process an entity's physics. Called automatically by the entity system.\n     * @param {pc.Entity} entity Entity being processed\n     */\n    process: function (entity)\n    {\n      if (!entity.active) return;\n\n      var sp = entity.getComponent('spatial');\n      var ph = entity.getComponent('physics');\n      if (!ph.active) return;\n\n      var at = entity.getComponent('joint');\n\n      if (!ph._body)\n      {\n        // setup physics body\n        var bodyDef = new Box2D.Dynamics.b2BodyDef();\n        bodyDef.type = ph.immovable ? Box2D.Dynamics.b2BodyDef.b2_staticBody :\n          bodyDef.type = Box2D.Dynamics.b2BodyDef.b2_dynamicBody;\n\n        if (ph.centered)\n        {\n          bodyDef.position.x = this.Class.toP(sp.pos.x + (sp.dim.x / 2));\n          bodyDef.position.y = this.Class.toP(sp.pos.y + (sp.dim.y / 2));\n        } else\n        {\n          bodyDef.position.x = this.Class.toP(sp.pos.x);\n          bodyDef.position.y = this.Class.toP(sp.pos.y);\n        }\n        bodyDef.linearDamping = ph.linearDamping;\n        bodyDef.angularDamping = ph.angularDamping;\n        bodyDef.isBullet = ph.bullet;\n        bodyDef.fixedRotation = ph.fixedRotation;\n\n        ph._body = this.world.CreateBody(bodyDef);\n        ph._body.SetAngle(pc.Math.degToRad(sp.dir));\n        ph._body.SetUserData(entity);\n        ph._body._pc_bodyType = pc.BodyType.ENTITY;\n\n        if (ph.linearVelocity)\n        {\n          ph._body.SetLinearVelocity(Box2D.Common.Math.b2Vec2.Get(\n            ph.linearVelocity.x * pc.systems.Physics.SCALE,\n            ph.linearVelocity.y * pc.systems.Physics.SCALE));\n        }\n\n        // custom gravity for the body (optional)\n        if (ph.gravity)\n          ph.setGravity(ph.gravity.x, ph.gravity.y);\n\n        //\n        // Fixtures\n        //\n        pc.assert(ph.shapes.length, \"You must specify at least one shape for a physics entity\");\n\n        // configure the shapes as fixtures\n        for (var i = 0; i < ph.shapes.length; i++)\n        {\n          var shape = ph.shapes[i];\n\n          // take the spatial, then offset\n          var w = (sp.dim.x + shape.offset.w) * this.Class.SCALE;\n          var h = (sp.dim.y + shape.offset.h) * this.Class.SCALE;\n          var hw = w / 2;\n          var hh = h / 2;\n          var hx = (shape.offset.x * this.Class.SCALE) / 2;\n          var hy = (shape.offset.y * this.Class.SCALE) / 2;\n\n          pc.assert(hw > 0 && hh > 0, \"Physics requires a spatial size minimum of 1\");\n\n          var fixDef = new Box2D.Dynamics.b2FixtureDef();\n          fixDef.density = ph.density;\n          fixDef.friction = ph.friction;\n          fixDef.restitution = ph.bounce;\n\n          switch (shape.shape)\n          {\n            case pc.CollisionShape.CIRCLE:\n              fixDef.shape = new Box2D.Collision.Shapes.b2CircleShape(w / 2);\n              fixDef.shape.SetLocalPosition(\n                Box2D.Common.Math.b2Vec2.Get(shape.offset.x * this.Class.SCALE,\n                  shape.offset.y * this.Class.SCALE));\n              break;\n\n            case pc.CollisionShape.POLY:\n              fixDef.shape = new Box2D.Collision.Shapes.b2PolygonShape;\n\n              var points = [];\n              for (var q = 0; q < shape.points.length; q++)\n                points.push(Box2D.Common.Math.b2Vec2.Get(\n                  (shape.offset.x + shape.points[q][0]) * this.Class.SCALE,\n                  (shape.offset.y + shape.points[q][1]) * this.Class.SCALE));\n\n              fixDef.shape.SetAsArray(points, points.length);\n              break;\n\n            default: // pc.CollisionShape.RECT:\n              fixDef.shape = new Box2D.Collision.Shapes.b2PolygonShape;\n\n              // need to set based on polygon rectangle --\n              points = [];\n\n              // the body is positioned relative to the center in physics,\n              // so we have to figure out the correct position of the center\n              points.push(Box2D.Common.Math.b2Vec2.Get(-(hw) + hx, -(hh) + hy));   // top left\n              points.push(Box2D.Common.Math.b2Vec2.Get(hw, -(hh) + hy));    // top right\n              points.push(Box2D.Common.Math.b2Vec2.Get(hw, hh));    // bottom right\n              points.push(Box2D.Common.Math.b2Vec2.Get(-(hw) + hx, hh));   // bottom left\n\n              fixDef.shape.SetAsArray(points, points.length);\n              break;\n          }\n\n          // set the collision filters\n          fixDef.filter.groupIndex = shape.collisionGroup;\n          fixDef.filter.categoryBits = shape.collisionCategory;\n          fixDef.filter.maskBits = shape.collisionMask;\n          fixDef.isSensor = shape.sensorOnly;\n\n          var f = ph._body.CreateFixture(fixDef);\n          f._pc_type = shape.type;\n          ph._fixtures.push(f);\n        }\n\n\n        if (ph.centerOfMass.x != 0 || ph.centerOfMass.y != 0 || ph.mass != -1)\n        {\n          var md = new Box2D.Collision.Shapes.b2MassData();\n          md.center = Box2D.Common.Math.b2Vec2.Get(ph.centerOfMass.x * pc.systems.Physics.SCALE, ph.centerOfMass.y * pc.systems.Physics.SCALE);\n          if (ph.mass != -1) md.mass = ph.mass;\n          md.I = 1;\n          ph._body.SetMassData(md);\n        } else\n        {\n          md = new Box2D.Collision.Shapes.b2MassData();\n          md.mass = 1;\n          md.I = 1;\n\n          ph._body.SetMassData(md);\n        }\n\n        if (ph.torque) ph.applyTorque(ph.torque);\n        if (ph.turn) ph.applyTurn(ph.turn);\n        if (ph.force) ph.applyForce(ph.force);\n        if (ph.impulse) ph.applyImpulse(ph.impulse);\n\n        ph._lastSpatialPos = pc.Point.create(sp.pos.x, sp.pos.y);\n        ph._lastSpatialDim = pc.Dim.create(sp.dim.x, sp.dim.y);\n        ph._lastSpatialDir = sp.dir;\n      }\n\n      // handle attachments/joints\n      if (at)\n      {\n        if (!at._joint) // still not hooked up\n        {\n          // test if we're ready to create a join (is other entity bound to physics and\n          // therefore has a body already)\n          var connectToPhysics = at.attachTo.getComponent('physics');\n          if (connectToPhysics._body)\n          {\n            var jointDef = null;\n\n            switch (at.type)\n            {\n              case pc.JointType.WELD:\n                jointDef = new Box2D.Dynamics.Joints.b2WeldJointDef;\n                jointDef.bodyA = connectToPhysics._body;\n                jointDef.bodyB = ph._body;\n                jointDef.collideConnected = false;\n                jointDef.localAnchorA.Set(at.offset.x * this.Class.SCALE, at.offset.y * this.Class.SCALE);\n                jointDef.localAnchorB.Set(at.attachmentOffset.x * this.Class.SCALE, at.attachmentOffset.y * this.Class.SCALE);\n                connectToPhysics._body.SetAwake(true);\n\n                // set this bodies position to the right place\n                var atPos = connectToPhysics._body.GetPosition();\n                ph._body.SetPosition(\n                  {\n                    x: atPos.x + (at.offset.x * this.Class.SCALE),\n                    y: atPos.y + (at.offset.y * this.Class.SCALE)\n                  });\n                break;\n\n              case pc.JointType.DISTANCE:\n                jointDef = new Box2D.Dynamics.Joints.b2DistanceJointDef;\n                jointDef.bodyA = connectToPhysics._body;\n                jointDef.bodyB = ph._body;\n                jointDef.frequency = at.frequency;\n                jointDef.dampingRatio = at.dampingRatio;\n                jointDef.collideConnected = false;\n                jointDef.length = at.distance;\n                jointDef.localAnchorA.Set(at.offset.x * this.Class.SCALE, at.offset.y * this.Class.SCALE);\n                jointDef.localAnchorB.Set(at.attachmentOffset.x * this.Class.SCALE, at.attachmentOffset.y * this.Class.SCALE);\n                connectToPhysics._body.SetAwake(true);\n\n                // set this bodies position to the right place\n                atPos = connectToPhysics._body.GetPosition();\n                ph._body.SetPosition(\n                  {\n                    x: atPos.x + (at.offset.x * this.Class.SCALE),\n                    y: atPos.y + (at.offset.y * this.Class.SCALE)\n                  });\n                break;\n\n              case pc.JointType.REVOLUTE:\n                jointDef = new Box2D.Dynamics.Joints.b2RevoluteJointDef;\n                jointDef.bodyA = connectToPhysics._body;\n                jointDef.bodyB = ph._body;\n                jointDef.collideConnected = false;\n                jointDef.referenceAngle = at.angle;\n                jointDef.localAnchorA.Set(at.offset.x * this.Class.SCALE, at.offset.y * this.Class.SCALE);\n                jointDef.localAnchorB.Set(at.attachmentOffset.x * this.Class.SCALE, at.attachmentOffset.y * this.Class.SCALE);\n                connectToPhysics._body.SetAwake(true);\n\n                if (at.enableLimit)\n                {\n                  jointDef.enableLimit = at.enableLimit;\n                  jointDef.lowerAngle = pc.Math.degToRad(at.lowerAngleLimit);\n                  jointDef.upperAngle = pc.Math.degToRad(at.upperAngleLimit);\n                }\n\n                if (at.enableMotor)\n                {\n                  jointDef.enableMotor = at.enableMotor;\n                  jointDef.motorSpeed = pc.Math.degToRad(at.motorSpeed);\n                  jointDef.maxMotorTorque = at.maxMotorTorque;\n                }\n\n                // set this bodies position to the right place\n                var atPos2 = connectToPhysics._body.GetPosition();\n                ph._body.SetPosition(\n                  {\n                    x: atPos2.x + this.Class.toP(at.offset.x),\n                    y: atPos2.y + this.Class.toP(at.offset.y)\n                  });\n                break;\n            }\n\n            if (!jointDef)\n              throw \"Invalid attachment config\";\n            at._joint = this.world.CreateJoint(jointDef);\n          }\n        }\n      }\n\n      // sync up with the spatial component\n      var p = ph._body.GetPosition();\n      var dir = Math.round(pc.Math.radToDeg(ph._body.GetAngle()));\n\n      // first check to see if the spatial position or dimensions have changed from what we last set them to be\n      // if it has changed, force a position, dimension or direction change\n      if (ph._lastSpatialPos.x != sp.pos.x || ph._lastSpatialPos.y != sp.pos.y)\n      {\n        // the spatial position changed, so we move the physics object accordingly\n        var x = ph._lastSpatialPos.x != sp.pos.x ? this.Class.toP(sp.pos.x + (sp.dim.x / 2)) : p.x;\n        var y = ph._lastSpatialPos.y != sp.pos.y ? this.Class.toP(sp.pos.y + (sp.dim.y / 2)) : p.y;\n\n        ph._body.SetPosition(Box2D.Common.Math.b2Vec2.Get(x, y));\n      }\n\n      if (ph._lastSpatialDir != sp.dir)\n      {\n        ph._body.SetAngle(pc.Math.degToRad(sp.dir));\n        dir = Math.round(pc.Math.radToDeg(ph._body.GetAngle()));\n      }\n\n      // update the spatial to match the physics position\n      sp.pos.x = Math.round(this.Class.fromP(p.x) - (sp.dim.x / 2));\n      sp.pos.y = Math.round(this.Class.fromP(p.y) - (sp.dim.y / 2));\n      sp.dir = dir;\n\n      // update what we think is the last position (according to the physics system)\n      ph._lastSpatialPos.x = sp.pos.x;\n      ph._lastSpatialPos.y = sp.pos.y;\n      ph._lastSpatialDir = dir;\n\n      // if there is a max velocity set enforce it\n      if (ph.maxSpeed.x > 0 || ph.maxSpeed.y > 0)\n      {\n        var velocity = ph._body.GetLinearVelocity();\n        if (velocity.x != 0 || velocity.y != 0)\n        {\n          var maxX = this.Class.toP(ph.maxSpeed.x);\n          if (velocity.x > 0 && velocity.x > maxX)\n            ph._body.SetLinearVelocity(Box2D.Common.Math.b2Vec2.Get(maxX, velocity.y));\n          if (velocity.x < 0 && velocity.x < -maxX)\n            ph._body.SetLinearVelocity(Box2D.Common.Math.b2Vec2.Get(-maxX, velocity.y));\n\n          var maxY = this.Class.toP(ph.maxSpeed.y);\n          if (velocity.y > 0 && velocity.y > maxY)\n            ph._body.SetLinearVelocity(Box2D.Common.Math.b2Vec2.Get(velocity.x, maxY));\n          if (velocity.y < 0 && velocity.y < -maxY)\n            ph._body.SetLinearVelocity(Box2D.Common.Math.b2Vec2.Get(velocity.x, -maxY));\n        }\n      }\n    },\n\n    /**\n     * Called when the origin of the layer changes\n     * @param {Number} x x-position of the origin\n     * @param {Number} y y-position of the origin\n     */\n    onOriginChange: function (x, y)\n    {\n      // update the debug draw origin so it keeps up with us\n      this.debugDraw.SetOrigin(x, y);\n    },\n\n    /**\n     * Process the system\n     */\n    processAll: function ()\n    {\n      // this.world.Step(pc.device.elapsed / 200, 20, 20);\n      this.world.Step(0.08, 10, 10); // fixed step to avoid frame rate physics issues when encountering lag\n      this.world.DrawDebugData();\n      this.world.ClearForces();\n\n      this._super();\n    },\n\n    onAddedToLayer: function (layer)\n    {\n      var worldBoundingBox = new Box2D.Collision.b2AABB();\n      worldBoundingBox.lowerBound.Set(0, 0);\n      worldBoundingBox.upperBound.Set(this.Class.toP(layer.worldSize.x), this.Class.toP(layer.worldSize.y));\n    },\n\n    /**\n     * Sets debugging\n     * @param {Boolean} on True to enable debugging\n     */\n    setDebug: function (on)\n    {\n      if (on)\n      {\n        this.world.SetDebugDraw(this.debugDraw);\n      } else\n        this.world.SetDebugDraw(null);\n\n      this.debug = on;\n    },\n\n    /**\n     * Get all the entities in a given area\n     * @param {pc.Rect} rect Area to query\n     * @return {Array} Array of entities in the area\n     */\n    getEntitiesInArea: function (rect)\n    {\n      var aabb = new Box2D.Collision.b2AABB(), entities = [];\n      aabb.lowerBound.Set(rect.x, rect.y);\n      aabb.upperBound.Set(rect.w, rect.h);\n\n      // Query the world\n      this.world.QueryAABB(function (fixture)\n      {\n        //if (fixture.GetBody().GetType() != Box2D.Dynamics.b2Body.b2_staticBody)\n        entities.push(fixture.GetBody().GetUserData());\n        return true;\n      }, aabb);\n\n      return entities;\n    },\n\n    /**\n     * Quick way to create a static shape and add it directly to the physics world (without requiring an entity).\n     * Great for collision shapes like world boundaries\n     * @param {Number} x x-position of the collidable shape\n     * @param {Number} y y-position of the collidable shape\n     * @param {Number} w width of the collidable shape\n     * @param {Number} h height of the collidable\n     * @param {Number} collisionGroup Collision group index\n     * @param {Number} collisionCategory Collision category\n     * @param {Number} collisionMask Collision mask\n     */\n    createStaticBody: function (x, y, w, h, collisionGroup, collisionCategory, collisionMask)\n    {\n      var hw = this.Class.toP(w / 2);\n      var hh = this.Class.toP(h / 2);\n\n      // setup physics body\n      var fixDef = new Box2D.Dynamics.b2FixtureDef();\n      var bodyDef = new Box2D.Dynamics.b2BodyDef();\n\n      bodyDef.type = Box2D.Dynamics.b2BodyDef.b2_staticBody;\n      fixDef.shape = new Box2D.Collision.Shapes.b2PolygonShape;\n\n      var points = [];\n      points.push(Box2D.Common.Math.b2Vec2.Get(-hw, -hh));   // top left\n      points.push(Box2D.Common.Math.b2Vec2.Get(hw, -hh));    // top right\n      points.push(Box2D.Common.Math.b2Vec2.Get(hw, hh));    // bottom right\n      points.push(Box2D.Common.Math.b2Vec2.Get(-hw, hh));   // bottom left\n      fixDef.shape.SetAsArray(points, points.length);\n\n      // set the collision filters\n      fixDef.filter.groupIndex = collisionGroup;\n      fixDef.filter.categoryBits = collisionCategory;\n      fixDef.filter.maskBits = collisionMask;\n\n      bodyDef.position.x = this.Class.toP(x) + hw;\n      bodyDef.position.y = this.Class.toP(y) + hh;\n\n      var body = this.world.CreateBody(bodyDef);\n      body._pc_bodyType = pc.BodyType.TILE;\n      body.CreateFixture(fixDef);\n    },\n\n    /**\n     * Add a collision tile map (by creating collidable shapes in the physics world matching the tile map)\n     * @param {pc.TileMap} tileMap Tile map for all the tiles\n     * @param {Number} collisionGroup Collision group index\n     * @param {Number} collisionCategory Collision category\n     * @param {Number} collisionMask Collision mask\n     */\n    addTileCollisionMap: function (tileMap, collisionGroup, collisionCategory, collisionMask)\n    {\n      // Generate a set of rectangles (polys) for the tiles. To make things more efficient\n      // we pack tiles horizontally across to reduce the total number of physics fixtures being\n      // added.\n\n      for (var ty = 0; ty < tileMap.tilesHigh; ty++)\n      {\n        // new row, start again\n        var x = 0;\n        var w = 0;\n\n        for (var tx = 0; tx < tileMap.tilesWide; tx++)\n        {\n          if (tileMap.tiles[ty][tx] >= 0)\n          {\n            w += tileMap.tileWidth;\n\n          } else\n          {\n            // we found a gap, so create the physics body for his horizontal tile set\n            if (w > 0)\n            {\n              this.createStaticBody(x - (this.layer ? this.layer.origin.x : 0), ty * tileMap.tileHeight - (this.layer ? this.layer.origin.y : 0), w,\n                tileMap.tileHeight, collisionGroup, collisionCategory, collisionMask);\n              w = 0;\n            }\n\n            // set the starting x position for the next rectangle\n            x = ((tx + 1) * tileMap.tileWidth);\n          }\n        }\n\n        // end of a row -- check we have a horizontal block at the edge\n        if (w > 0)\n        {\n          this.createStaticBody(x - (this.layer ? this.layer.origin.x : 0), ty * tileMap.tileHeight - (this.layer ? this.layer.origin.y : 0), w,\n            tileMap.tileHeight, collisionGroup, collisionCategory, collisionMask);\n        }\n      }\n    },\n\n    /** Not implemented fully yet\n     getEntityAtPoint:function (p)\n     {\n     var aabb = new Box2D.Collision.b2AABB();\n     var entity = null;\n\n     var wx = p.x / this.Class.SCALE;\n     var wy = p.y / this.Class.SCALE;\n\n     aabb.lowerBound.Set(wx, wy);\n     aabb.upperBound.Set(wx, wy);\n\n     // Query the world\n     this.world.QueryAABB(\n     function (fixture)\n     {\n     if (fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), b2P))\n     {\n     body = fixture.GetBody();\n     return false;\n     }\n     return true;\n     }, aabb);\n\n     return body;\n     },\n     */\n\n\n    /**\n     * Called when an entity first collides with a tile or another entity. Use the fixture types to differentiate\n     * collisions with different fixtures.\n     * @param {pc.BodyType} aType Type of the collision body (pc.BodyType.TILE or pc.BodyType.ENTITY)\n     * @param {pc.BodyType} bType Type of the collision body (pc.BodyType.TILE or pc.BodyType.ENTITY)\n     * @param {pc.Entity} entityA If an entity, a reference to the entity that was the first part of the collision\n     * @param {pc.Entity} entityB If an entity, a reference to the entity that was the second part of the collision\n     * @param {Number} fixtureAType User type provided when fixture was created of the first fixture\n     * @param {Number} fixtureBType User type provided when fixture was created of the second fixture\n     * @param {b2Contact} contact Additional contact information\n     */\n    onCollisionStart: function (aType, bType, entityA, entityB, fixtureAType, fixtureBType, contact)\n    {\n    },\n\n    /**\n     * Continuously called when in a collision state -- note that sensors will not be reported as constantly\n     * colliding, they will only be reported as collision start and end events.\n     * @param {pc.BodyType} aType Type of the collision body (pc.BodyType.TILE or pc.BodyType.ENTITY)\n     * @param {pc.BodyType} bType Type of the collision body (pc.BodyType.TILE or pc.BodyType.ENTITY)\n     * @param {pc.Entity} entityA If an entity, a reference to the entity that was the first part of the collision\n     * @param {pc.Entity} entityB If an entity, a reference to the entity that was the second part of the collision\n     * @param {Number} force The impact force of the collision\n     * @param {Number} fixtureAType User type provided when fixture was created of the first fixture\n     * @param {Number} fixtureBType User type provided when fixture was created of the second fixture\n     * @param {b2Contact} contact Additional contact information\n     */\n    onCollision: function (aType, bType, entityA, entityB, force, fixtureAType, fixtureBType, contact)\n    {\n    },\n\n    /**\n     * Called when an entity has finished colliding with a tile or another entity\n     * @param {pc.BodyType} aType Type of the collision body (pc.BodyType.TILE or pc.BodyType.ENTITY)\n     * @param {pc.BodyType} bType Type of the collision body (pc.BodyType.TILE or pc.BodyType.ENTITY)\n     * @param {pc.Entity} entityA If an entity, a reference to the entity that was the first part of the collision\n     * @param {pc.Entity} entityB If an entity, a reference to the entity that was the second part of the collision\n     * @param {Number} fixtureAType User type provided when fixture was created of the first fixture\n     * @param {Number} fixtureBType User type provided when fixture was created of the second fixture\n     * @param {b2Contact} contact Additional contact information\n     */\n    onCollisionEnd: function (aType, bType, entityA, entityB, fixtureAType, fixtureBType, contact)\n    {\n    },\n\n    onEntityAdded: function (entity)\n    {\n    },\n\n    onEntityRemoved: function (entity)\n    {\n      var ph = entity.getComponent('physics');\n      if (ph._body)\n      {\n        this.world.DestroyBody(ph._body);\n        var at = entity.getComponent('joint');\n        if (at)\n        {\n          this.world.DestroyJoint(at._joint);\n        }\n      }\n    }\n\n  });\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.systems.Effects\n * @description\n * [Extends <a href='pc.systems.System'>pc.systems.System</a>]\n * <p>\n * A effects system that drives effects like fade.\n */\npc.systems.Effects = pc.systems.EntitySystem.extend('pc.systems.Effects',\n    /** @lends pc.systems.Effects */\n    {\n        FadeState:\n        {\n            NOT_STARTED: 0,\n            DELAYING:1,\n            FADING_IN:2,\n            HOLDING:3,\n            FADING_OUT:4,\n            DONE: 5\n        }\n    },\n    /** @lends pc.systems.Effects.prototype */\n    {\n        /**\n         * Constructs a new systems with options.\n         */\n        init: function()\n        {\n            this._super( [ 'fade', 'spin', 'scale' ] );\n        },\n\n        /**\n         * Processes all the entities with effect components\n         */\n        processAll: function()\n        {\n            var next = this.entities.first;\n            while (next)\n            {\n                var entity = next.obj;\n                if (entity.active)\n                {\n                    var fade = entity.getComponent('fade');\n                    if (fade && fade.active)\n                    {\n                        var alpha = entity.getComponent('alpha');\n                        if (!alpha)\n                            alpha = entity.addComponent(pc.components.Alpha.create({}));\n\n                        if (fade.state != this.Class.FadeState.DONE)\n                        {\n                            if (!this._fade(alpha, fade))\n                                entity.removeComponent(fade);\n                        }\n                    }\n                    var spin = entity.getComponent('spin');\n                    if (spin && spin.spinning && spin.active)\n                    {\n                        var spatial = entity.getComponent('spatial');\n                        var a = spin.rate / pc.device.elapsed;\n\n                        if (spin.max > 0 && spin.spinSoFar+a >= spin.max)\n                        {\n                            spin.spinning = false;\n                            a = (spin.max-spin.spinSoFar);\n                        }\n                        spin.spinSoFar += a;\n                        spatial.setDir( pc.Math.rotate(spatial.getDir(), spin.clockwise ? a : -a));\n                    }\n\n                    var scale = entity.getComponent('scale');\n                    if (scale && scale.scaling && scale.active)\n                    {\n                        spatial = entity.getComponent('spatial');\n\n                        if (!scale._bound && (scale.x != 1 || scale.y != 1))\n                        {\n                            spatial.addScale(scale.x, scale.y);\n                            scale._bound = true;\n                            if (scale.growX == 0 && scale.growY == 0)\n                                scale.scaling = false;\n                        }\n\n                        var sx = scale.growX / pc.device.elapsed;\n                        var sy = scale.growY / pc.device.elapsed;\n\n                        if (scale.maxX != 0 && (scale.scaledXSoFar > 0 && scale.scaledXSoFar + sx >= scale.maxX))\n                            sx = (scale.maxX - scale.scaledXSoFar);\n                        if (scale.maxY != 0 && (scale.scaledYSoFar > 0 && scale.scaledYSoFar + sy >= scale.maxY))\n                            sy = (scale.maxY - scale.scaledYSoFar);\n\n                        if (sx != 0 && sy != 0)\n                        {\n                            scale.scaledXSoFar += sx;\n                            scale.scaledYSoFar += sy;\n                            spatial.addScale(sx, sy);\n                        }\n\n                        if ((scale.maxX != 0 && scale.scaledXSoFar >= scale.maxX) &&\n                            (scale.maxY != 0 && scale.scaledYSoFar >= scale.maxY))\n                            scale.scaling = false;\n\n                        scale._bound = true\n                    }\n                }\n\n                next = next.next();\n            }\n        },\n\n        _fade: function(alpha, fader)\n        {\n            var timeSinceStart = pc.device.now - fader.startTime;\n\n            // do something about the current state, and change states if it's time.\n            switch (fader.state)\n            {\n                case this.Class.FadeState.NOT_STARTED:\n                    fader.startTime = pc.device.now;\n\n                    if (fader.startDelay > 0)\n                    {\n                        fader.state = this.Class.FadeState.DELAYING;\n                        fader.timeLimit = fader.startDelay;\n                        alpha.setAlpha(0);\n\n                    } else if (fader.fadeInTime > 0)\n                    {\n                        fader.state = this.Class.FadeState.FADING_IN;\n                        fader.timeLimit = fader.fadeInTime;\n                        // if we have a fade in element, then start alpha at 0\n                        alpha.setAlpha(0);\n                    }\n                    else if (fader.holdTime > 0)\n                    {\n                        fader.state = this.Class.FadeState.HOLDING;\n                        fader.timeLimit = fader.holdTime;\n                    }\n                    else if (fader.fadeOutTime > 0)\n                    {\n                        fader.state = this.Class.FadeState.FADING_OUT;\n                        fader.timeLimit = fader.fadeOutTime;\n                    }\n                    break;\n\n                case this.Class.FadeState.DELAYING:\n                    // do nothing whilst holding\n                    if (timeSinceStart > fader.timeLimit)\n                    {\n                        fader.timeLimit = fader.fadeInTime;\n                        fader.startTime = pc.device.now;\n                        fader.state = this.Class.FadeState.FADING_IN;\n                    }\n                    break;\n                case this.Class.FadeState.FADING_IN:\n                    alpha.addAlpha((pc.device.elapsed * (100 / fader.timeLimit)) / 100);\n                    if (timeSinceStart > fader.timeLimit)\n                    {\n                        fader.timeLimit = fader.holdTime;\n                        fader.startTime = pc.device.now;\n                        fader.state = this.Class.FadeState.HOLDING;\n                    }\n                    break;\n                case this.Class.FadeState.HOLDING:\n                    if (timeSinceStart > fader.timeLimit)\n                    {\n                        fader.timeLimit = fader.fadeOutTime;\n                        fader.startTime = pc.device.now;\n                        fader.state = this.Class.FadeState.FADING_OUT;\n                    }\n                    // do nothing whilst holding\n                    break;\n                case this.Class.FadeState.FADING_OUT:\n                    if (timeSinceStart > fader.timeLimit)\n                    {\n                        fader.loopsSoFar++;\n\n                        if (fader.loops > 1 || fader.loops == 0) // restart?\n                        {\n                            fader.startTime = pc.device.now;\n                            fader.timeLimit = fader.fadeInTime;\n                            fader.state = this.Class.FadeState.FADING_IN;\n                            if (fader.timeLimit > 0) alpha.setAlpha(0);\n                        }\n\n                        if (fader.loopsSoFar >= fader.loops && fader.loops)\n                        {\n                           // all done, kill thyself\n                           fader.state = this.Class.FadeState.DONE;\n                           if (fader.timeLimit > 0) alpha.setAlpha(0);\n                           return false;\n                        }\n                    } else\n                    {\n                        alpha.subAlpha((pc.device.elapsed * (100 / fader.timeLimit)) / 100);\n                    }\n\n                    break;\n            }\n            return true;\n        }\n\n\n    });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.systems.Particles\n * @description\n * [Extends <a href='pc.systems.System'>pc.systems.System</a>]\n * <p>\n * A particle system. See the particle component for more information.\n */\npc.systems.Particles = pc.systems.EntitySystem.extend('pc.systems.Particles',\n    /** @lends pc.systems.Particles */\n    { },\n    /** @lends pc.systems.Particles.prototype */\n    {\n        /**\n         * Constructs a new particle system\n         */\n        init:function ()\n        {\n            this._super([ 'emitter' ]);\n        },\n\n        _drawStartTime: 0,\n\n        process:function (entity)\n        {\n            if (!entity.active) return;\n\n            var em = entity.getComponent('emitter');\n            if (!em.active) return;\n\n            var sp = entity.getComponent('spatial');\n            if (!sp)\n                sp = entity.addComponent(new pc.components.Spatial({}));\n\n            if (em)\n            {\n                if (!em.active) return;\n\n                // New emissions\n                if (em.emitting && Date.now() - em._lastEmitTime > em.delay && (em.shots == 0 || em._shotCount < em.shots))\n                {\n                    for (var b = 0; b < em.burst; b++)\n                    {\n                        // if this sprite sheet has no animations, then we just use the spritesheet frames\n                        var frame = 0;\n                        if (em.spriteSheet.animations.size() == 0)\n                            // pick a random frame to use\n                            frame = pc.Math.rand(0, (em.spriteSheet.framesHigh * em.spriteSheet.framesWide)-1);\n\n                        em._particles.add(\n                            pc._Particle.create(\n                                sp.pos.x + em.offsetX + pc.Math.rand(-(em.rangeX/2), em.rangeX/2),\n                                sp.pos.y + em.offsetY + pc.Math.rand(-(em.rangeY/2), em.rangeY/2),\n                                pc.Math.rotate(em.relativeAngle ? sp.dir : 0, pc.Math.rand(em.angleMin, em.angleMax)),\n                                pc.Math.randFloat(em.thrustMin, em.thrustMax),\n                                pc.Math.randFloat(em.lifeMin, em.lifeMax),\n                                pc.Math.randFloat(em.spinMin, em.spinMax),\n                                pc.Math.randFloat(em.growXMin, em.growXMax),\n                                pc.Math.randFloat(em.growYMin, em.growYMax),\n                                pc.Math.randFloat(em.scaleXMin, em.scaleXMax),\n                                pc.Math.randFloat(em.scaleYMin, em.scaleYMax),\n                                em.fadeInTime, em.fadeOutTime,\n                                em.alphaMin, em.alphaMax,\n                                em.spriteSheet,\n                                em.compositeOperation,\n                                frame));\n                    }\n\n                    em._lastEmitTime = Date.now();\n                    em._shotCount++;\n                }\n\n                // update all the particles\n                var next = em._particles.first;\n                while (next)\n                {\n                    var p = next.obj;\n\n                    // move the particles in the right direction\n                    if (pc.device.now - p.start > em.thrustTime)\n                        p.thrust = 0;\n\n                    var accelX = p.thrust * Math.cos( pc.Math.degToRad(p.dir) );\n                    var accelY = p.thrust * Math.sin( pc.Math.degToRad(p.dir) );\n\n                    // add the acceleration to velocity\n                    p.velX += (accelX * (pc.device.elapsed/1000)) + em.gravityX;\n                    p.velY += (accelY * (pc.device.elapsed/1000)) + em.gravityY;\n                    p.velX = pc.Math.limit(p.velX, -em.maxVelX, em.maxVelX);\n                    p.velY = pc.Math.limit(p.velY, -em.maxVelY, em.maxVelY);\n                    p.x += p.velX;\n                    p.y += p.velY;\n\n                    // render aspects (spin, grow, fade etc)\n                    if (p.spin)\n                        p.rotation = pc.Math.rotate(p.rotation, p.spin * (pc.device.elapsed/1000));\n                    if (p.growXRate != 0 || p.growYRate != 0)\n                    {\n                        p.scaleX += p.growXRate * (pc.device.elapsed/1000);\n                        p.scaleY += p.growYRate * (pc.device.elapsed/1000);\n                    }\n\n                    if (p.fadeState == 0) // fading in\n                    {\n                        p.sprite.addAlpha((pc.device.elapsed * (100 / p.fadeInTime)) / 100);\n                        if (pc.device.now - p.fadeStateStart > p.fadeInTime)\n                        {\n                            p.fadeState++;\n                            p.fadeStateStart = pc.device.now;\n                        }\n                    }\n\n                    if (p.fadeState == 1)\n                    {\n                        if (pc.device.now - p.fadeStateStart > p.holdTime)\n                        {\n                            p.fadeState++;\n                            p.fadeStateStart = pc.device.now;\n                        }\n                    }\n\n                    if (p.fadeState == 2) // fading out\n                    {\n                        if (p.fadeOutTime > 0)// && p.sprite.alpha > 0)\n                        {\n                            var fa = (pc.device.elapsed * (100 / p.fadeOutTime)) / 100;\n                            p.sprite.subAlpha(fa);\n                            // doesn't need to time ending because lifetime will take over\n                            // down below and kill this particle\n                        }\n                    }\n\n                    // pick a random alpha\n                    if (p.alphaMin != 1 || p.alphaMax != 1)\n                    {\n                        if (pc.device.now - p.lastAlpha > em.alphaDelay)\n                        {\n                            p.sprite.setAlpha(pc.Math.rand(p.alphaMin, p.alphaMax));\n                            p.lastAlpha = pc.device.now;\n                        }\n                    }\n\n                    // draw it\n                    this.drawStartTime = Date.now();\n                    if (p.scaleX != 1 || p.scaleY != 1)\n                        em.spriteSheet.setScale(p.scaleX, p.scaleY);\n\n                    if (!p.sprite.currentAnim)\n                    {\n                        p.sprite.drawFrame(pc.device.ctx, p.frame % em.spriteSheet.framesWide,\n                            Math.floor(p.frame / em.spriteSheet.framesWide),\n                            p.x - entity.layer.origin.x - entity.layer.scene.viewPort.x,\n                            p.y - entity.layer.origin.y - entity.layer.scene.viewPort.y,\n                            em.rotateSprite ? p.rotation : p.dir);\n                        pc.device.lastDrawMS += (Date.now() - this.drawStartTime);\n                    }\n                    else\n                    {\n                        p.sprite.draw(pc.device.ctx,\n                            p.x - entity.layer.origin.x - entity.layer.scene.viewPort.x,\n                            p.y - entity.layer.origin.y - entity.layer.scene.viewPort.y,\n                            p.dir);\n                        pc.device.lastDrawMS += (Date.now() - this.drawStartTime);\n                        p.sprite.update(pc.device.elapsed);\n                    }\n\n                    if (p.scaleX != 1 || p.scaleY != 1)\n                        em.spriteSheet.setScale(1, 1);\n\n                    // assign next before we (maybe) remove this one\n                    next = next.next();\n\n                    // time to die?\n                    if (pc.device.now - p.start > p.lifetime)\n                    {\n                        p.release();\n                        em._particles.remove(p);\n                    }\n                }\n\n                // if all the particles are done, and the shot count is finished, time to kill the emitter\n                if (em.shots != 0)\n                {\n                    if (em._particles.first == null && em._shotCount >= em.shots)\n                       em.active = false;\n                }\n\n            }\n        }\n\n\n    });\n\n\npc._Particle = pc.Pooled.extend('pc._Particle',\n    {\n        create:function (x, y, dir, thrust, lifetime, spin, growXRate, growYRate, scaleX, scaleY,\n                         fadeInTime, fadeOutTime, alphaMin, alphaMax, spriteSheet, compositeOperation, frame)\n        {\n            var n = this._super();\n            n.x = x;\n            n.y = y;\n            n.dir = dir;\n            n.thrust = thrust;\n            n.frame = frame;\n            n.lifetime = lifetime;\n            n.spin = spin;\n            n.growXRate = growXRate;\n            n.growYRate = growYRate;\n            n.scaleX = scaleX;\n            n.scaleY = scaleY;\n            if (n.sprite == null)\n                n.sprite = pc.Sprite.create(spriteSheet);\n            else\n                n.sprite.setSpriteSheet(spriteSheet);\n            n.start = pc.device.now;\n            n.fadeStart = 0;\n            n.velX = 0;\n            n.velY = 0;\n            n.rotation = 0;\n            n.alphaMin = alphaMin;\n            n.alphaMax = alphaMax;\n            n.lastAlpha = pc.device.now;\n            n.fadeInTime = fadeInTime;\n            n.fadeOutTime = fadeOutTime;\n            n.holdTime = n.lifetime - (n.fadeInTime + n.fadeOutTime);\n            if (compositeOperation)\n                n.sprite.setCompositeOperation(compositeOperation);\n            else\n                n.sprite.setCompositeOperation('source-over');\n\n            n.fadeState = 1;    // 0=fading in, 1 = displaying, 2 = fading out\n            n.fadeStateStart = pc.device.now;\n            if (n.fadeInTime > 0)\n            {\n                n.fadeState = 0;\n                n.sprite.setAlpha(0);\n            } else\n                n.sprite.setAlpha(1);\n\n            return n;\n        }\n    },\n    {\n        x: 0,\n        y: 0,\n        dir: 0,\n        rotation: 0,\n        thrust: 0,\n        sprite: null,\n        start: 0,\n        frame: 0,\n        fadeStart: 0,\n        velX: 0,\n        velY: 0,\n        spin: 0,\n        growXRate: 0,\n        growYRate: 0,\n        scaleX: 1,\n        scaleY: 1,\n        fadeInTime: 0,\n        fadeOutTime: 0,\n        fadeStateStart: 0,\n        holdTime: 0,\n        fadeState: 1,\n        alphaMin: 1,\n        alphaMax: 1,\n        lastAlpha: 0 // time of last alpha change\n\n    });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.systems.Input\n * @description\n * [Extends <a href='pc.systems.System'>pc.systems.System</a>]\n * <p>\n * Input system. See the <a href='pc.components.Input'>input component</a> for more information.\n */\npc.systems.Input = pc.systems.EntitySystem.extend('pc.systems.Input',\n    /** @lends pc.systems.Input */\n    {},\n    /** @lends pc.systems.Input.prototype */\n    {\n        /**\n         * Constructs a new input system.\n         */\n        init:function ()\n        {\n            this._super(['input']);\n        },\n\n        process:function (entity)\n        {\n            var input = entity.getComponent('input');\n            if (!input.active) return;\n\n            if (!input._bound)\n            {\n                var uiSpatial = entity.getComponent('spatial');\n                var eventTarget = entity;\n\n                // if there is a target specified for the events, then we flip things around a little\n                // we bind the input to the entity target, and make this entity (the one with the entity component\n                // on it the uiTarget (bounding rectangle)\n                if (input.target)\n                    eventTarget = input.target;\n\n                // bind all the inputs we want\n                if (input.states)\n                {\n                    for (var i=0; i < input.states.length; i++)\n                    {\n                        var keys = input.states[i][1];\n                        for (var k = 0; k < keys.length; k++)\n                        {\n                            var ts = uiSpatial;\n                            if (pc.valid(input.states[i][2]) && input.states[i][2] == false)\n                                ts = null;\n                            pc.device.input.bindState(eventTarget, input.states[i][0], keys[k], ts);\n                        }\n                    }\n                }\n\n                if (input.actions)\n                {\n                    //eventTarget = this;\n                    for (i = 0; i < input.actions.length; i++)\n                    {\n                        keys = input.actions[i][1];\n                        for (k = 0; k < keys.length; k++)\n                        {\n                            ts = uiSpatial;\n                            if (pc.valid(input.actions[i][2]) && input.actions[i][2] == false)\n                                ts = null;\n                            pc.device.input.bindAction(eventTarget, input.actions[i][0], keys[k], ts);\n                        }\n                    }\n                }\n\n                input._bound = true;\n            }\n        },\n\n        /**\n         * Override to react to the actions\n         * @param {String} actionName Name of the action\n         * @param {Event} event Event object that caused the input\n         * @param {pc.Point} pos Position the input occurred\n         * @param {Object} uiTarget The target that received the input (spatial of an entity if bound)\n         */\n        onAction:function(actionName, event, pos, uiTarget)\n        {\n        },\n\n        /**\n         * Gets whether an input state is active\n         * @param {pc.Entity} entity Entity testing the active state for\n         * @param {String} state The state to test\n         * @return {Boolean} true if the state is presently on\n         */\n        isInputState: function(entity, state)\n        {\n            if (entity.getComponent('input')._bound)\n                return pc.device.input.isInputState(entity, state);\n            return false;\n        }\n\n\n    });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.systems.Expiration\n * @description\n * [Extends <a href='pc.systems.System'>pc.systems.System</a>]\n * <p>\n * Expiry system. See the <a href='pc.components.Expiry'>expiry component</a> for more information.\n */\npc.systems.Expiration = pc.systems.EntitySystem.extend('pc.systems.Expiration',\n    /** @lends pc.systems.Expiration */\n    {},\n    /** @lends pc.systems.Expiration.prototype */\n    {\n        init: function()\n        {\n            this._super(['expiry']);\n        },\n\n        process: function(entity)\n        {\n            var c = entity.getComponent('expiry');\n            if (!c.active) return;\n\n            c.decrease(pc.device.elapsed);\n            if (c.hasExpired())\n                entity.remove();\n        }\n\n    });\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.systems.Activation\n * @description\n * [Extends <a href='pc.systems.System'>pc.systems.System</a>]\n * <p>\n * Handles activating entities when they get within a certain range of another entity.\n * See the <a href='pc.components.Activator'>activator component</a> for more information.\n */\npc.systems.Activation = pc.systems.EntitySystem.extend('pc.systems.Activation',\n    /** @lends pc.systems.Activation */\n    {},\n    /** @lends pc.systems.Activation.prototype */\n    {\n        /**\n         * Constructor for the activation system\n         * @param {Number} delay Time between system runs in milliseconds. Default is 2000 (2 seconds).\n         */\n        init:function(delay)\n        {\n            this._super(['activator'], delay);\n        },\n\n        onEntityAdded:function (entity)\n        {\n            entity.active = false;\n        },\n\n        process:function (entity)\n        {\n            var a = entity.getComponent('activator');\n            if (!a.active) return;\n\n            if (entity.active && a.stayActive) return;\n            if (!a._cacheLayer)\n            {\n                if (a.layer)\n                    a._cacheLayer = entity.layer.scene.get(a.layer);\n                else\n                    a._cacheLayer = entity.layer;\n            }\n\n            var entities = a._cacheLayer.getEntityManager().getTagged(a.tag);\n\n            if (!entities) return;\n\n            var e = entities.first;\n            while(e)\n            {\n                var thisSP = entity.getComponent('spatial');\n                var otherSP = e.object().getComponent('spatial');\n\n                var distance = thisSP.getCenterPos().distance(otherSP.getCenterPos());\n                if (!entity.active)\n                {\n                    // is the other entity close enough\n                    if (distance < a.range)\n                        entity.active = true;\n                } else\n                {\n                    if (distance >= a.range)\n                        entity.active = false;\n                }\n\n                e = e.next();\n            }\n        }\n\n    });\n\n\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.systems.Render\n * @description\n * [Extends <a href='pc.systems.System'>pc.systems.System</a>]\n * <p>\n * Handles rendering of components: sprite, overlay, rect, text\n */\npc.systems.Render = pc.systems.EntitySystem.extend('pc.systems.Render',\n    /** @lends pc.systems.Render */\n    {},\n    /** @lends pc.systems.Render.prototype */\n    {\n        /**\n         * Constructs a new render system.\n         */\n        init: function()\n        {\n            this._super( [ 'sprite', 'overlay', 'rect', 'text', 'poly', 'circle' ] );\n        },\n\n        processAll: function()\n        {\n            var startTime = Date.now();\n\n            var next = this.entities.first;\n            while (next)\n            {\n                var entity = next.obj;\n                if (entity.active)\n                {\n                    var spatial = entity.getComponent('spatial');\n                    var alpha = entity.getComponent('alpha');\n                    var clip = entity.getComponent('clip');\n\n                    // accommodate scene viewport and layering offset positions\n                    var drawX = entity.layer.screenX(spatial.pos.x);\n                    var drawY = entity.layer.screenY(spatial.pos.y);\n                    var unscaledPos = spatial.getUnscaledPos();\n                    var unscaledDim = spatial.getUnscaledDim();\n\n                    var ctx = pc.device.ctx;\n                    ctx.save();\n\n                    if (spatial.scaleX != 1 || spatial.scaleY != 1)\n                    {\n                        drawX = entity.layer.screenX(unscaledPos.x);\n                        drawY = entity.layer.screenY(unscaledPos.y);\n                        ctx.scale(spatial.scaleX, spatial.scaleY);\n                    }\n\n                    if (clip && clip.active)\n                    {\n                        ctx.beginPath();\n                        if (clip.clipEntity)\n                        {\n                            // entity plus clipping rectangle\n                            var sp = clip.clipEntity.getComponent('spatial');\n                            ctx.rect(\n                                entity.layer.screenX(sp.pos.x) + clip.x, entity.layer.screenY(sp.pos.y) + clip.y,\n                                sp.dim.x+clip.w, sp.dim.y+clip.h);\n                        } else\n                        {\n                            // just plain rectangle clipping\n                            ctx.rect(\n                                entity.layer.screenX(spatial.pos.x) + clip.x,\n                                entity.layer.screenY(spatial.pos.y) + clip.y, clip.w, clip.h);\n                        }\n                        ctx.closePath();\n                        ctx.clip();\n                    }\n\n                    var shifter = entity.getComponent('originshifter');\n                    if (shifter && shifter.active)\n                    {\n                        // if it has a shifter on it, adjust the position of the entity based on a ratio to\n                        // the layer's origin\n\n                        // reverse any changes we've made so far\n                        var origX = spatial.pos.x - shifter._offsetX;\n                        var origY = spatial.pos.y - shifter._offsetY;\n\n                        shifter._offsetX = (this.layer.origin.x * shifter.ratio);\n                        shifter._offsetY = (this.layer.origin.y * shifter.ratio);\n\n                        spatial.pos.x = origX + shifter._offsetX;\n                        spatial.pos.y = origY + shifter._offsetY;\n                    }\n\n                    var spriteComponent = entity.getComponent('sprite');\n                    if (spriteComponent && spriteComponent.active)\n                    {\n                        spriteComponent.sprite.update(pc.device.elapsed);\n                        if (alpha && alpha.level != 1 && alpha.level != 0)\n                            spriteComponent.sprite.alpha = alpha.level;\n                        if (spatial.scaleX != 1 || spatial.scaleY != 1)\n                            spriteComponent.sprite.setScale(spatial.scaleX, spatial.scaleY);\n                        spriteComponent.sprite.draw(ctx, drawX+ spriteComponent.offset.x, drawY+ spriteComponent.offset.y, spatial.dir);\n                        if (spatial.scaleX != 1 || spatial.scaleY != 1)\n                            spriteComponent.sprite.setScale(1, 1);\n                    }\n\n                    var overlay = entity.getComponent('overlay');\n                    if (overlay && overlay.active)\n                    {\n                        // update and draw the overlay sprite\n                        overlay.sprite.update(pc.device.elapsed);\n                        if (alpha)\n                            overlay.sprite.alpha = alpha.level;\n                        overlay.sprite.draw(ctx, drawX, drawY, spatial.dir);\n\n                        overlay.decrease(pc.device.elapsed);\n                        if (overlay.hasExpired())\n                            entity.removeComponent(overlay);\n                    }\n\n                    var rect = entity.getComponent('rect');\n                    if (rect && rect.active)\n                    {\n                        ctx.save();\n                        if (alpha) ctx.globalAlpha = alpha.level;\n\n                        // translate to the center of the rectangle (so rotation works correctly)\n\n                        ctx.translate((drawX+(unscaledDim.x/2)), (drawY+(unscaledDim.y/2)));\n                        ctx.rotate( spatial.dir * (Math.PI/180));\n\n                        // rounded rectangle\n                        if (rect.cornerRadius > 0)\n                        {\n                            var topLeftX = -unscaledDim.x/2;\n                            var topLeftY = -unscaledDim.y/2;\n\n                            ctx.beginPath();\n                            ctx.moveTo((-unscaledDim.x/2) + rect.cornerRadius, -unscaledDim.y);\n\n                            ctx.lineTo(drawX + unscaledDim.x - rect.cornerRadius, drawY);\n                            ctx.quadraticCurveTo(drawX + unscaledDim.x, drawY, drawX + unscaledDim.x, drawY + rect.cornerRadius);\n                            ctx.lineTo(drawX + unscaledDim.x, drawY + unscaledDim.y - rect.cornerRadius);\n                            ctx.quadraticCurveTo(drawX + unscaledDim.x, drawY + unscaledDim.y,\n                                drawX + unscaledDim.x - rect.cornerRadius, drawY + unscaledDim.y);\n                            ctx.lineTo(drawX + rect.cornerRadius, drawY + unscaledDim.y);\n                            ctx.quadraticCurveTo(drawX, drawY + unscaledDim.y, drawX, drawY + unscaledDim.y - rect.cornerRadius);\n                            ctx.lineTo(drawX, drawY + rect.cornerRadius);\n                            ctx.quadraticCurveTo(drawX, drawY, drawX + rect.cornerRadius, drawY);\n                            ctx.closePath();\n\n                            if (rect.color)\n                            {\n                                ctx.fillStyle = rect.color.color;\n                                ctx.fill();\n                            }\n                            if (rect.lineColor && rect.lineWidth)\n                            {\n                                ctx.lineWidth = rect.lineWidth;\n                                ctx.strokeStyle = rect.lineColor.color;\n                                ctx.stroke();\n                            }\n                        } else\n                        {\n                            if (rect.color)\n                            {\n                                ctx.fillStyle = rect.color.color;\n                                ctx.fillRect(-unscaledDim.x/2, -unscaledDim.y/2, unscaledDim.x, unscaledDim.y);\n                            }\n                            if (rect.lineColor && rect.lineWidth)\n                            {\n                                ctx.lineWidth = rect.lineWidth;\n                                ctx.strokeStyle = rect.lineColor.color;\n                                ctx.strokeRect(-unscaledDim.x / 2, -unscaledDim.y / 2, unscaledDim.x, unscaledDim.y);\n                            }\n                        }\n\n                        if (alpha) ctx.globalAlpha = 1; // restore the alpha\n                        ctx.restore();\n                        pc.device.elementsDrawn++;\n                    }\n\n\n                    var circle = entity.getComponent('circle');\n                    if (circle && circle.active)\n                    {\n                        ctx.save();\n                        ctx.lineWidth = circle.lineWidth;\n                        if (alpha) ctx.globalAlpha = alpha.level;\n\n                        ctx.translate((drawX + (spatial.dim.x / 2)), (drawY + (spatial.dim.y / 2)));\n                        ctx.rotate(spatial.dir * (Math.PI / 180));\n\n                        ctx.beginPath();\n                        ctx.arc(0, 0, spatial.dim.x / 2, 0, pc.Math.PI * 2, true);\n                        ctx.closePath();\n\n                        if (circle.color)\n                        {\n                            ctx.fillStyle = circle.color.color;\n                            ctx.fill();\n                        }\n\n                        if (circle.lineColor)\n                        {\n                            ctx.lineWidth = circle.lineWidth;\n                            ctx.strokeStyle = circle.lineColor.color;\n                            ctx.stroke();\n                        }\n                        if (alpha) ctx.globalAlpha = 1; // restore the alpha\n                        ctx.restore();\n                        pc.device.elementsDrawn++;\n                    }\n\n                    var poly = entity.getComponent('poly');\n                    if (poly && poly.active)\n                    {\n                        ctx.save();\n                        if (alpha) ctx.globalAlpha = alpha.level;\n\n                        var hw = spatial.dim.x/2;\n                        var hh = spatial.dim.y/2;\n\n                        // we center so rotation / dir works correctly\n                        ctx.translate((drawX + hw), (drawY + hh));\n                        ctx.rotate(spatial.dir * (Math.PI / 180));\n\n                        ctx.beginPath();\n                        ctx.moveTo(poly.points[0][0]-hw, poly.points[0][1]-hh);\n                        for (var p=1; p < poly.points.length; p++)\n                            ctx.lineTo(poly.points[p][0]-hw, poly.points[p][1]-hh);\n\n                        ctx.closePath();\n                        if (poly.color)\n                        {\n                            ctx.fillStyle = poly.color.color;\n                            ctx.fill();\n                        }\n\n                        if (poly.lineColor)\n                        {\n                            ctx.lineWidth = poly.lineWidth;\n                            ctx.strokeStyle = poly.lineColor.color;\n                            ctx.stroke();\n                        }\n\n                        if (alpha) ctx.globalAlpha = 1; // restore the alpha\n                        ctx.restore();\n                        pc.device.elementsDrawn++;\n                    }\n\n                    var text = entity.getComponent('text');\n                    if (text && text.active)\n                    {\n                        ctx.save();\n                        var yAdd=0;\n                        if (alpha) ctx.globalAlpha = alpha.level;\n                        hw = spatial.dim.x / 2;\n                        hh = spatial.dim.y / 2;\n                        ctx.font = text._fontCache;\n                        ctx.lineWidth = text.lineWidth;\n\n                        ctx.translate((drawX + hw), (drawY + hh));\n                        ctx.rotate(spatial.dir * (Math.PI / 180));\n\n                        for (var i=0; i < text.text.length; i++)\n                        {\n                            // canvas text is drawn with an origin at the bottom left, so we draw at y+h, not y\n                            if (text.color)\n                            {\n                                ctx.fillStyle = text.color.color;\n                                ctx.fillText(text.text[i], text.offset.x-hw, yAdd + spatial.dim.y + text.offset.y-hh);\n                            }\n                            if (text.strokeColor && text.lineWidth)\n                            {\n                                ctx.strokeStyle = text.strokeColor.color;\n                                ctx.strokeText(text.text[i], text.offset.x-hw, yAdd + spatial.dim.y + text.offset.y-hh);\n                            }\n                            yAdd += (text.fontHeight * 1.1);\n                        }\n                        if (alpha) ctx.globalAlpha = 1; // restore the alpha\n                        pc.device.elementsDrawn++;\n                        ctx.restore();\n                    }\n\n                    ctx.restore();\n                }\n                next = next.next();\n            }\n\n            pc.device.lastDrawMS += (Date.now() - startTime);\n        }\n\n    });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "/**\n * Playcraft Engine - (C)2012 Playcraft Labs, Inc.\n * See licence.txt for details\n */\n\n/**\n * @class pc.systems.Layout\n * @description\n * [Extends <a href='pc.systems.System'>pc.systems.System</a>]\n * <p>\n * Manages the layout of entities\n */\npc.systems.Layout = pc.systems.EntitySystem.extend('pc.systems.Layout',\n    /** @lends pc.systems.Layout */\n    {},\n    /** @lends pc.systems.Layout.prototype */\n    {\n        /** current margin (left, right, top, bottom) */\n        margin: null,\n\n        /**\n         * Constructs a new layout system.\n         * @param {Number} options.margin.left Default left margin for all entities\n         * @param {Number} options.margin.right Default right margin for all entities\n         * @param {Number} options.margin.top Default top margin for all entities\n         * @param {Number} options.margin.bottom Default bottom margin for all entities\n         */\n        init: function(options)\n        {\n            this._super( [ 'layout' ] );\n            this.margin = {};\n            if (pc.checked(options) && pc.checked(options.margin))\n            {\n                this.margin.left = pc.checked(options.margin.left, 0);\n                this.margin.right = pc.checked(options.margin.right, 0);\n                this.margin.top = pc.checked(options.margin.top, 0);\n                this.margin.bottom = pc.checked(options.margin.bottom, 0);\n            } else\n            {\n                this.margin.left = 0;\n                this.margin.right = 0;\n                this.margin.top = 0;\n                this.margin.bottom = 0;\n            }\n        },\n\n        _getAnchorLocation: function(horizontal, vertically)\n        {\n            if (horizontal === 'left')\n            {\n                if (vertically === 'top') return 'top-left';\n                if (vertically === 'middle') return 'middle-left';\n                if (vertically === 'bottom') return 'bottom-left';\n            }\n\n            if (horizontal === 'center')\n            {\n                if (vertically === 'top') return 'top-center';\n                if (vertically === 'middle') return 'middle-center';\n                if (vertically === 'bottom') return 'bottom-center';\n            }\n\n            if (horizontal === 'right')\n            {\n                if (vertically === 'top') return 'top-right';\n                if (vertically === 'middle') return 'middle-right';\n                if (vertically === 'bottom') return 'bottom-right';\n            }\n\n            return null;\n        },\n\n        /**\n         * Processes all the entities and lays them out according to the anchoring options.\n         * Typically this is called whenever a new entity with a layout component is added to the\n         * system, but you can call it manually if you really want to (such as when an entity changed size or moves)\n         */\n        doLayout: function()\n        {\n            var layouts = new pc.HashList(); // a list for each of the anchors\n\n            var next = this.entities.first;\n            while (next)\n            {\n                var entity = next.obj;\n                var spatial = entity.getComponent('spatial');\n                if (!spatial)\n                    entity.addComponent( pc.components.Spatial({}) );\n\n                var layout = entity.getComponent('layout');\n\n                // add entities to the layout sides; this just sorts them\n                var al = this._getAnchorLocation(layout.horizontal, layout.vertical);\n                layouts.add(al, next.obj);\n                //console.log(' adding: ' + next.obj.toString() + ' to anchor group: ' + al);\n                next = next.next();\n            }\n\n            // now go through all the anchor groups and lay things out\n            var layoutKeys = layouts.hashtable.keys();\n            for (var i=0; i < layoutKeys.length; i++)\n            {\n                var anchor = layoutKeys[i];\n                var list = layouts.get(layoutKeys[i]);\n\n                // if it's centered we need to know the height of all the entities being laid out\n                // before we place the first item.\n\n                var dim = this._getEntityDimensions(list);\n                var cx = this.margin.left;\n                var cy = this.margin.top;\n\n                // set the starting position\n                switch(anchor)\n                {\n                    case 'top-left':\n                        break;\n                    case 'middle-left':\n                        cy += ( this.layer.getScreenRect().h / 2) - (dim.y/2);\n                        break;\n                    case 'bottom-left':\n                        cy = this.layer.getScreenRect().h - dim.y - this.margin.bottom;\n                        break;\n                    case 'top-center':\n                        cx += this.layer.getScreenRect().w / 2 - (dim.x/2);\n                        break;\n                    case 'middle-center':\n                        cx += this.layer.getScreenRect().w / 2 - (dim.x/2);\n                        cy +=( this.layer.getScreenRect().h / 2) - (dim.y/2);\n                        break;\n                    case 'bottom-center':\n                        cx = this.layer.getScreenRect().w / 2 - (dim.x/2) - this.margin.bottom;\n                        cy += this.layer.getScreenRect().h - dim.y;\n                        break;\n                    case 'top-right':\n                        cx += this.layer.getScreenRect().w - dim.x;\n                        break;\n                    case 'middle-right':\n                        cx += this.layer.getScreenRect().w - dim.x;\n                        cy +=( this.layer.getScreenRect().h / 2) - (dim.y/2);\n                        break;\n                    case 'bottom-right':\n                        cx += this.layer.getScreenRect().w - dim.x;\n                        cy = this.layer.getScreenRect().h - dim.y - this.margin.bottom;\n                        break;\n                }\n\n                // whilst this while loop below looks like it's handling all anchor types, keep in mind\n                // each loop is only handling one type (since they are sorted/grouped above)\n                var listNext = list.first;\n                while (listNext)\n                {\n                    entity = listNext.obj;\n                    spatial = entity.getComponent('spatial');\n                    layout = entity.getComponent('layout');\n\n                    cy += layout.margin.top;\n\n                    switch(anchor)\n                    {\n                        case 'top-left':\n                        case 'middle-left':\n                        case 'bottom-left':\n                            cx = layout.margin.left + this.margin.left;\n                            break;\n                        case 'top-center':\n                        case 'middle-center':\n                        case 'bottom-center':\n                            cx = layout.margin.left + (this.layer.getScreenRect().w/2) - (spatial.dim.x/2);\n                            break;\n                        case 'top-right':\n                        case 'middle-right':\n                        case 'bottom-right':\n                            cx = this.layer.getScreenRect().w - spatial.dim.x - layout.margin.right - this.margin.right;\n                            break;\n                    }\n\n                    spatial.pos.x = cx;\n                    spatial.pos.y = cy;\n\n                    cy += spatial.dim.y + layout.margin.bottom;\n\n                    listNext = listNext.next();\n                }\n\n            }\n        },\n\n        _entityDim: null,\n\n        _getEntityDimensions: function(list)\n        {\n            if (!this._entityDim)\n                this._entityDim = new pc.Dim();\n\n            this._entityDim.x = 0;\n            this._entityDim.y = 0;\n\n            var listNext = list.first;\n            while (listNext)\n            {\n                var sp = listNext.obj.getComponent('spatial');\n                var layout = listNext.obj.getComponent('layout');\n\n                if (sp)\n                {\n                    this._entityDim.x += layout.margin.left + sp.dim.x + layout.margin.right;\n                    this._entityDim.y += layout.margin.top + sp.dim.y + layout.margin.bottom;\n                }\n\n                listNext = listNext.nextLinked;\n            }\n\n            return this._entityDim;\n        },\n\n        onResize: function(width, height)\n        {\n            this.doLayout();\n        },\n\n        onEntityAdded: function(entity)\n        {\n            this._super();\n            this.doLayout();\n        },\n\n        onEntityRemoved: function(entity)\n        {\n            this._super();\n            this.doLayout();\n        },\n\n        onComponentAdded: function(entity, component)\n        {\n            this._super();\n            this.doLayout();\n        }\n\n\n\n    });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  ]
}