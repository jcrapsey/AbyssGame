{
  "version": 3,
  "file": "gamecore.js",
  "sources": [
    "vendors/gamecore.js/src/gamecore.js",
    "vendors/gamecore.js/src/class.js",
    "vendors/gamecore.js/src/base.js",
    "vendors/gamecore.js/src/jhashtable.js",
    "vendors/gamecore.js/src/device.js",
    "vendors/gamecore.js/src/perf.js",
    "vendors/gamecore.js/src/linkedlist.js",
    "vendors/gamecore.js/src/hashlist.js",
    "vendors/gamecore.js/src/stacktrace.js",
    "vendors/gamecore.js/src/pooled.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACxoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;ACndA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,O;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC1UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourcesContent": [
    "/**\n * gamecore.js - Copyright 2012 Playcraft Labs, Inc. (see licence.txt)\n */\n\nwindow.gamecore =\n{\n    hasOwn:Object.prototype.hasOwnProperty,\n\n    isFunction:function (obj)\n    {\n        // return Object.prototype.toString.call(obj) === \"[object Function]\";\n       return !!(obj && obj.constructor && obj.call && obj.apply);\n    },\n\n    isWindow:function (obj)\n    {\n        return !!(obj && obj.setInterval);\n    },\n\n    isArray:Array.isArray || function (obj)\n    {\n        return (obj.constructor === Array);\n    },\n\n    isString:function (obj)\n    {\n        return (typeof obj == 'string');\n    },\n\n    isObject:function (obj)\n    {\n        return obj === Object(obj);\n    },\n\n    isPlainObject:function (obj)\n    {\n        // Must be an Object.\n        // Because of IE, we also have to check the presence of the constructor property.\n        // Make sure that DOM nodes and window objects don't pass through, as well\n        if (!obj || this.isObject(obj) || obj.nodeType || this.isWindow(obj))\n            return false;\n\n        try\n        {\n            // Not own constructor property must be Object\n            if (obj.constructor && !this.hasOwn.call(obj, \"constructor\") && !this.hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\"))\n                return false;\n\n        } catch (e)\n        {\n            // IE8,9 Will throw exceptions on certain host objects #9897\n            return false;\n        }\n\n        // own properties are enumerated firstly, so to speed up, if last one is own, then all properties are own.\n        var key;\n        for (key in obj)\n        {\n        }\n\n        return key === undefined || this.hasOwn.call(obj, key);\n    },\n\n    extend:function ()\n    {\n        var options, name, src, copy, copyIsArray, clone,\n            target = arguments[0] || {},\n            i = 1,\n            length = arguments.length,\n            deep = false;\n\n        // Handle a deep copy situation\n        if (typeof target === \"boolean\")\n        {\n            deep = target;\n            target = arguments[1] || {};\n            // skip the boolean and the target\n            i = 2;\n        }\n\n        // Handle case when target is a string or something (possible in deep copy)\n        if (typeof target !== \"object\" && !gamecore.isFunction(target))\n            target = {};\n\n        if (length === i)\n        {\n            target = this;\n            --i;\n        }\n\n        for (; i < length; i++)\n        {\n            // Only deal with non-null/undefined values\n            if ((options = arguments[ i ]) != null)\n            {\n                // Extend the base object\n                for (name in options)\n                {\n                    src = target[ name ];\n                    copy = options[ name ];\n\n                    // Prevent never-ending loop\n                    if (target === copy)\n                    {\n                        continue;\n                    }\n\n                    // Recurse if we're merging plain objects or arrays\n                    if (deep && copy && ( this.isPlainObject(copy) || (copyIsArray = this.isArray(copy)) ))\n                    {\n                        if (copyIsArray)\n                        {\n                            copyIsArray = false;\n                            clone = src && this.isArray(src) ? src : [];\n\n                        } else\n                        {\n                            clone = src && this.isPlainObject(src) ? src : {};\n                        }\n\n                        // Never move original objects, clone them\n                        target[ name ] = this.extend(deep, clone, copy);\n\n                        // Don't bring in undefined values\n                    } else if (copy !== undefined)\n                    {\n                        target[ name ] = copy;\n                    }\n                }\n            }\n        }\n\n        // Return the modified object\n        return target;\n    }\n\n};\n\n\ngamecore.push = Array.prototype.push;\n\ngamecore.merge = function (first, second)\n{\n    var i = first.length, j = 0;\n\n    if (typeof second.length === \"number\")\n    {\n        for (var l = second.length; j < l; j++)\n            first[ i++ ] = second[ j ];\n    } else\n    {\n        while (second[j] !== undefined)\n            first[ i++ ] = second[ j++ ];\n    }\n    first.length = i;\n    return first;\n};\n\ngamecore.makeArray = function (array, results)\n{\n    var ret = results || [];\n\n    if (array != null)\n    {\n        // The window, strings (and functions) also have 'length'\n        // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930\n        if (array.length == null || gamecore.isString(array) || gamecore.isFunction(array) || gamecore.isWindow(array))\n            gamecore.push.call(ret, array);\n        else\n            gamecore.merge(ret, array);\n    }\n\n    return ret;\n};\n\n\ngamecore.each = function (object, callback, args)\n{\n    var name, i = 0,\n        length = object.length,\n        isObj = length === undefined || gamecore.isFunction(object);\n\n    if (args)\n    {\n        if (isObj)\n        {\n            for (name in object)\n            {\n                if (callback.apply(object[ name ], args) === false)\n                {\n                    break;\n                }\n            }\n        } else\n        {\n            for (; i < length;)\n            {\n                if (callback.apply(object[ i++ ], args) === false)\n                {\n                    break;\n                }\n            }\n        }\n\n        // A special, fast, case for the most common use of each\n    } else\n    {\n        if (isObj)\n        {\n            for (name in object)\n            {\n                if (callback.call(object[ name ], name, object[ name ]) === false)\n                {\n                    break;\n                }\n            }\n        } else\n        {\n            for (; i < length;)\n            {\n                if (callback.call(object[ i ], i, object[ i++ ]) === false)\n                {\n                    break;\n                }\n            }\n        }\n    }\n\n    return object;\n};\n\n\ngamecore._flagsCache = {};\n\ngamecore.createFlags = function (flags)\n{\n    var object = gamecore._flagsCache[ flags ] = {}, i, length;\n    flags = flags.split(/\\s+/);\n    for (i = 0, length = flags.length; i < length; i++)\n        object[ flags[i] ] = true;\n    return object;\n};\n\ngamecore.Callbacks = function (flags)\n{\n    // Convert flags from String-formatted to Object-formatted\n    // (we check in cache first)\n    flags = flags ? ( gamecore._flagsCache[ flags ] || gamecore.createFlags(flags) ) : {};\n\n    var // Actual callback list\n        list = [],\n    // Stack of fire calls for repeatable lists\n        stack = [],\n    // Last fire value (for non-forgettable lists)\n        memory,\n    // Flag to know if list is currently firing\n        firing,\n    // First callback to fire (used internally by add and fireWith)\n        firingStart,\n    // End of the loop when firing\n        firingLength,\n    // Index of currently firing callback (modified by remove if needed)\n        firingIndex,\n    // Add one or several callbacks to the list\n        add = function (args)\n        {\n            var i, length, elem, actual;\n\n            for (i = 0, length = args.length; i < length; i++)\n            {\n                elem = args[ i ];\n                if (gamecore.isArray(elem))\n                {\n                    // Inspect recursively\n                    add(elem);\n                } else if (gamecore.isFunction(elem))\n                {\n                    // Add if not in unique mode and callback is not in\n                    if (!flags.unique || !self.has(elem))\n                    {\n                        list.push(elem);\n                    }\n                }\n            }\n        },\n    // Fire callbacks\n        fire = function (context, args)\n        {\n            args = args || [];\n            memory = !flags.memory || [ context, args ];\n            firing = true;\n            firingIndex = firingStart || 0;\n            firingStart = 0;\n            firingLength = list.length;\n            for (; list && firingIndex < firingLength; firingIndex++)\n            {\n                if (list[ firingIndex ].apply(context, args) === false && flags.stopOnFalse)\n                {\n                    memory = true; // Mark as halted\n                    break;\n                }\n            }\n            firing = false;\n            if (list)\n            {\n                if (!flags.once)\n                {\n                    if (stack && stack.length)\n                    {\n                        memory = stack.shift();\n                        self.fireWith(memory[ 0 ], memory[ 1 ]);\n                    }\n                } else if (memory === true)\n                {\n                    self.disable();\n                } else\n                {\n                    list = [];\n                }\n            }\n        },\n    // Actual Callbacks object\n        self = {\n            // Add a callback or a collection of callbacks to the list\n            add:function ()\n            {\n                if (list)\n                {\n                    var length = list.length;\n                    add(arguments);\n                    // Do we need to add the callbacks to the\n                    // current firing batch?\n                    if (firing)\n                    {\n                        firingLength = list.length;\n                        // With memory, if we're not firing then\n                        // we should call right away, unless previous\n                        // firing was halted (stopOnFalse)\n                    } else if (memory && memory !== true)\n                    {\n                        firingStart = length;\n                        fire(memory[ 0 ], memory[ 1 ]);\n                    }\n                }\n                return this;\n            },\n            // Remove a callback from the list\n            remove:function ()\n            {\n                if (list)\n                {\n                    var args = arguments,\n                        argIndex = 0,\n                        argLength = args.length;\n                    for (; argIndex < argLength; argIndex++)\n                    {\n                        for (var i = 0; i < list.length; i++)\n                        {\n                            if (args[ argIndex ] === list[ i ])\n                            {\n                                // Handle firingIndex and firingLength\n                                if (firing)\n                                {\n                                    if (i <= firingLength)\n                                    {\n                                        firingLength--;\n                                        if (i <= firingIndex)\n                                        {\n                                            firingIndex--;\n                                        }\n                                    }\n                                }\n                                // Remove the element\n                                list.splice(i--, 1);\n                                // If we have some unicity property then\n                                // we only need to do this once\n                                if (flags.unique)\n                                {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                return this;\n            },\n            // Control if a given callback is in the list\n            has:function (fn)\n            {\n                if (list)\n                {\n                    var i = 0,\n                        length = list.length;\n                    for (; i < length; i++)\n                    {\n                        if (fn === list[ i ])\n                        {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            },\n            // Remove all callbacks from the list\n            empty:function ()\n            {\n                list = [];\n                return this;\n            },\n            // Have the list do nothing anymore\n            disable:function ()\n            {\n                list = stack = memory = undefined;\n                return this;\n            },\n            // Is it disabled?\n            disabled:function ()\n            {\n                return !list;\n            },\n            // Lock the list in its current state\n            lock:function ()\n            {\n                stack = undefined;\n                if (!memory || memory === true)\n                {\n                    self.disable();\n                }\n                return this;\n            },\n            // Is it locked?\n            locked:function ()\n            {\n                return !stack;\n            },\n            // Call all callbacks with the given context and arguments\n            fireWith:function (context, args)\n            {\n                if (stack)\n                {\n                    if (firing)\n                    {\n                        if (!flags.once)\n                        {\n                            stack.push([ context, args ]);\n                        }\n                    } else if (!( flags.once && memory ))\n                    {\n                        fire(context, args);\n                    }\n                }\n                return this;\n            },\n            // Call all the callbacks with the given arguments\n            fire:function ()\n            {\n                self.fireWith(this, arguments);\n                return this;\n            },\n            // To know if the callbacks have already been called at least once\n            fired:function ()\n            {\n                return !!memory;\n            }\n        };\n\n    return self;\n};\n\n\ngamecore.extend({\n\n    Deferred:function (func)\n    {\n        var doneList = gamecore.Callbacks(\"once memory\"),\n            failList = gamecore.Callbacks(\"once memory\"),\n            progressList = gamecore.Callbacks(\"memory\"),\n            state = \"pending\",\n            lists = {\n                resolve:doneList,\n                reject:failList,\n                notify:progressList\n            },\n            promise = {\n                done:doneList.add,\n                fail:failList.add,\n                progress:progressList.add,\n\n                state:function ()\n                {\n                    return state;\n                },\n\n                // Deprecated\n                isResolved:doneList.fired,\n                isRejected:failList.fired,\n\n                then:function (doneCallbacks, failCallbacks, progressCallbacks)\n                {\n                    deferred.done(doneCallbacks).fail(failCallbacks).progress(progressCallbacks);\n                    return this;\n                },\n                always:function ()\n                {\n                    deferred.done.apply(deferred, arguments).fail.apply(deferred, arguments);\n                    return this;\n                },\n                pipe:function (fnDone, fnFail, fnProgress)\n                {\n                    return gamecore.Deferred(function (newDefer)\n                    {\n                        gamecore.each({\n                            done:[ fnDone, \"resolve\" ],\n                            fail:[ fnFail, \"reject\" ],\n                            progress:[ fnProgress, \"notify\" ]\n                        }, function (handler, data)\n                        {\n                            var fn = data[ 0 ],\n                                action = data[ 1 ],\n                                returned;\n                            if (gamecore.isFunction(fn))\n                            {\n                                deferred[ handler ](function ()\n                                {\n                                    returned = fn.apply(this, arguments);\n                                    if (returned && gamecore.isFunction(returned.promise))\n                                    {\n                                        returned.promise().then(newDefer.resolve, newDefer.reject, newDefer.notify);\n                                    } else\n                                    {\n                                        newDefer[ action + \"With\" ](this === deferred ? newDefer : this, [ returned ]);\n                                    }\n                                });\n                            } else\n                            {\n                                deferred[ handler ](newDefer[ action ]);\n                            }\n                        });\n                    }).promise();\n                },\n                // Get a promise for this deferred\n                // If obj is provided, the promise aspect is added to the object\n                promise:function (obj)\n                {\n                    if (obj == null)\n                    {\n                        obj = promise;\n                    } else\n                    {\n                        for (var key in promise)\n                        {\n                            obj[ key ] = promise[ key ];\n                        }\n                    }\n                    return obj;\n                }\n            },\n            deferred = promise.promise({}),\n            key;\n\n        for (key in lists)\n        {\n            deferred[ key ] = lists[ key ].fire;\n            deferred[ key + \"With\" ] = lists[ key ].fireWith;\n        }\n\n        // Handle state\n        deferred.done(function ()\n        {\n            state = \"resolved\";\n        }, failList.disable, progressList.lock).fail(function ()\n            {\n                state = \"rejected\";\n            }, doneList.disable, progressList.lock);\n\n        // Call given func if any\n        if (func)\n        {\n            func.call(deferred, deferred);\n        }\n\n        // All done!\n        return deferred;\n    },\n\n    // Deferred helper\n    when:function (firstParam)\n    {\n        var // Static reference to slice\n            sliceDeferred = [].slice;\n        var args = sliceDeferred.call(arguments, 0),\n            i = 0,\n            length = args.length,\n            pValues = new Array(length),\n            count = length,\n            pCount = length,\n            deferred = length <= 1 && firstParam && gamecore.isFunction(firstParam.promise) ?\n                firstParam :\n                gamecore.Deferred(),\n            promise = deferred.promise();\n\n        function resolveFunc(i)\n        {\n            return function (value)\n            {\n                args[ i ] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;\n                if (!( --count ))\n                {\n                    deferred.resolveWith(deferred, args);\n                }\n            };\n        }\n\n        function progressFunc(i)\n        {\n            return function (value)\n            {\n                pValues[ i ] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;\n                deferred.notifyWith(promise, pValues);\n            };\n        }\n\n        if (length > 1)\n        {\n            for (; i < length; i++)\n            {\n                if (args[ i ] && args[ i ].promise && gamecore.isFunction(args[ i ].promise))\n                {\n                    args[ i ].promise().then(resolveFunc(i), deferred.reject, progressFunc(i));\n                } else\n                {\n                    --count;\n                }\n            }\n            if (!count)\n            {\n                deferred.resolveWith(deferred, args);\n            }\n        } else if (deferred !== firstParam)\n        {\n            deferred.resolveWith(deferred, length ? [ firstParam ] : []);\n        }\n        return promise;\n    }\n});\n\n\n\n\n",
    "/**\n * gamecore.js - Copyright 2012 Playcraft Labs, Inc. (see licence.txt)\n * class.js\n * Classes and objects\n */\n\n/**\n * @Class\n * A modified version of class.js to cater to static inheritance and deep object cloning\n * Based almost completely on class.js (Javascript MVC -- Justin Meyer, Brian Moschel, Michael Mayer and others)\n * (http://javascriptmvc.com/contribute.html)\n * Some portions adapted from Prototype JavaScript framework, version 1.6.0.1 (c) 2005-2007 Sam Stephenson\n * Some portions extracted from jQuery 1.7\n * <p>\n * Class system for javascript\n * <p>\n * <code>\n *   var Fighter = gamecore.Base.extend('Fighter',\n *   {\n *       // static (this is inherited as well)\n *       firingSpeed: 1000\n *   },\n *   {\n *       // instance\n *\n *       hp: 0,\n *       lastFireTime: 0,\n *\n *       init: function(hp)\n *       {\n *           this.hp = hp;\n *       },\n *\n *       fire: function()\n *       {\n *           this._super(); // super methods!\n *\n *           // do firing!\n *       }\n *   });\n *\n *  var gunship = new Fighter(100);\n * </code>\n *\n * Introspection:\n * <code>\n *   gamecore.Base.extend(‘Fighter.Gunship’);\n *   Fighter.Gunship.shortName; // ‘Gunship’\n *   Fighter.Gunship.fullName;  // ‘Fighter.Gunship’\n *   Fighter.Gunship.namespace; // ‘Fighter’\n * </code>\n * <p>\n * Setup method will be called prior to any init -- nice if you want to do things without needing the\n * users to call _super in the init, as well as for normalizing parameters.\n * <code>\n *   setup: function()\n *   {\n *      this.objectId = this.Class.totalObjects++;\n *      this.uniqueId = this.Class.fullName + ':' + this.objectId;\n *   }\n * </code>\n */\n\n(function (gc)\n{\n    var regs = {\n            undHash:/_|-/,\n            colons:/::/,\n            words:/([A-Z]+)([A-Z][a-z])/g,\n            lowUp:/([a-z\\d])([A-Z])/g,\n            dash:/([a-z\\d])([A-Z])/g,\n            replacer:/\\{([^\\}]+)\\}/g,\n            dot:/\\./\n        },\n        getNext = function (current, nextPart, add)\n        {\n            return current[nextPart] || ( add && (current[nextPart] = {}) );\n        },\n        isContainer = function (current)\n        {\n            var type = typeof current;\n            return type && (  type == 'function' || type == 'object' );\n        },\n        getObject = function (objectName, roots, add)\n        {\n            var parts = objectName ? objectName.split(regs.dot) : [],\n                length = parts.length,\n                currents = gc.isArray(roots) ? roots : [roots || window],\n                current,\n                ret,\n                i,\n                c = 0,\n                type;\n\n            if (length == 0)\n            {\n                return currents[0];\n            }\n            while (current = currents[c++])\n            {\n                for (i = 0; i < length - 1 && isContainer(current); i++)\n                {\n                    current = getNext(current, parts[i], add);\n                }\n                if (isContainer(current))\n                {\n\n                    ret = getNext(current, parts[i], add);\n\n                    if (ret !== undefined)\n                    {\n\n                        if (add === false)\n                        {\n                            delete current[parts[i]];\n                        }\n                        return ret;\n\n                    }\n\n                }\n            }\n        },\n\n        /**\n         * A collection of useful string helpers.\n         */\n        str = gc.String = {\n            /**\n             * @function\n             * Gets an object from a string.\n             * @param {String} name the name of the object to look for\n             * @param {Array} [roots] an array of root objects to look for the name\n             * @param {Boolean} [add] true to add missing objects to\n             *  the path. false to remove found properties. undefined to\n             *  not modify the root object\n             */\n            getObject:getObject,\n            /**\n             * Capitalizes a string\n             * @param {String} s the string.\n             * @return {String} a string with the first character capitalized.\n             */\n            capitalize:function (s, cache)\n            {\n                return s.charAt(0).toUpperCase() + s.substr(1);\n            },\n            /**\n             * Capitalizes a string from something undercored. Examples:\n             * @codestart\n             * gamecore.String.camelize(\"one_two\") //-> \"oneTwo\"\n             * \"three-four\".camelize() //-> threeFour\n             * @codeend\n             * @param {String} s\n             * @return {String} a the camelized string\n             */\n            camelize:function (s)\n            {\n                s = str.classize(s);\n                return s.charAt(0).toLowerCase() + s.substr(1);\n            },\n            /**\n             * Like camelize, but the first part is also capitalized\n             * @param {String} s\n             * @return {String} the classized string\n             */\n            classize:function (s, join)\n            {\n                var parts = s.split(regs.undHash),\n                    i = 0;\n                for (; i < parts.length; i++)\n                {\n                    parts[i] = str.capitalize(parts[i]);\n                }\n\n                return parts.join(join || '');\n            },\n            /**\n             * Like [gamecore.String.classize|classize], but a space separates each 'word'\n             * @codestart\n             * gamecore.String.niceName(\"one_two\") //-> \"One Two\"\n             * @codeend\n             * @param {String} s\n             * @return {String} the niceName\n             */\n            niceName:function (s)\n            {\n                return str.classize(s, ' ');\n            },\n\n            /**\n             * Underscores a string.\n             * @codestart\n             * gamecore.String.underscore(\"OneTwo\") //-> \"one_two\"\n             * @codeend\n             * @param {String} s\n             * @return {String} the underscored string\n             */\n            underscore:function (s)\n            {\n                return s.replace(regs.colons, '/').replace(regs.words, '$1_$2').replace(regs.lowUp, '$1_$2').replace(regs.dash, '_').toLowerCase();\n            },\n            /**\n             * Returns a string with {param} replaced values from data.\n             *\n             *     gamecore.String.sub(\"foo {bar}\",{bar: \"far\"})\n             *     //-> \"foo far\"\n             *\n             * @param {String} s The string to replace\n             * @param {Object} data The data to be used to look for properties.  If it's an array, multiple\n             * objects can be used.\n             * @param {Boolean} [remove] if a match is found, remove the property from the object\n             */\n            sub:function (s, data, remove)\n            {\n                var obs = [];\n                obs.push(s.replace(regs.replacer, function (whole, inside)\n                {\n                    //convert inside to type\n                    var ob = getObject(inside, data, typeof remove == 'boolean' ? !remove : remove),\n                        type = typeof ob;\n                    if ((type === 'object' || type === 'function') && type !== null)\n                    {\n                        obs.push(ob);\n                        return \"\";\n                    } else\n                    {\n                        return \"\" + ob;\n                    }\n                }));\n                return obs.length <= 1 ? obs[0] : obs;\n            }\n        }\n\n})(gamecore);\n\n(function (gc)\n{\n\n    // if we are initializing a new class\n    var initializing = false,\n        makeArray = gc.makeArray,\n        isFunction = gc.isFunction,\n        isArray = gc.isArray,\n        extend = gc.extend,\n\n        cloneObject = function (object)\n        {\n            if (!object || typeof(object) != 'object')\n                return object;\n\n            // special case handling of array (deep copy them)\n            if (object instanceof Array)\n            {\n                var clone = [];\n                for (var c = 0; c < object.length; c++)\n                    clone[c] = cloneObject(object[c]);\n                return clone;\n            }\n            else // otherwise, it's a normal object, clone it's properties\n            {\n                var cloneObj = {};\n                for (var prop in object)\n                    cloneObj[prop] = cloneObject(object[prop]);\n                return cloneObj;\n            }\n        },\n\n        concatArgs = function (arr, args)\n        {\n            return arr.concat(makeArray(args));\n        },\n\n        // tests if we can get super in .toString()\n        fnTest = /xyz/.test(function ()\n        {\n            xyz;\n        }) ? /\\b_super\\b/ : /.*/,\n\n        inheritProps = function (newProps, oldProps, addTo)\n        {\n            // overwrites an object with methods, sets up _super\n            // newProps - new properties\n            // oldProps - where the old properties might be\n            // addTo - what we are adding to\n            addTo = addTo || newProps\n            for (var name in newProps)\n            {\n                // Check if we're overwriting an existing function\n                addTo[name] = isFunction(newProps[name]) &&\n                    isFunction(oldProps[name]) &&\n                    fnTest.test(newProps[name]) ? (function (name, fn)\n                {\n                    return function ()\n                    {\n                        var tmp = this._super, ret;\n\n                        // Add a new ._super() method that is the same method but on the super-class\n                        this._super = oldProps[name];\n\n                        // The method only need to be bound temporarily, so we remove it when we're done executing\n                        ret = fn.apply(this, arguments);\n                        this._super = tmp;\n                        return ret;\n                    };\n                })(name, newProps[name]) : newProps[name];\n            }\n        },\n\n        clss = gc.Class = function ()\n        {\n            if (arguments.length)\n            {\n                return clss.extend.apply(clss, arguments);\n            }\n        };\n\n    /* @Static*/\n    extend(clss, {\n        callback:function (funcs)\n        {\n            //args that should be curried\n            var args = makeArray(arguments),\n                self;\n\n            funcs = args.shift();\n\n            if (!isArray(funcs))\n            {\n                funcs = [funcs];\n            }\n\n            self = this;\n\n            return function class_cb()\n            {\n                var cur = concatArgs(args, arguments),\n                    isString,\n                    length = funcs.length,\n                    f = 0,\n                    func;\n\n                for (; f < length; f++)\n                {\n                    func = funcs[f];\n                    if (!func)\n                        continue;\n\n                    isString = typeof func == \"string\";\n                    if (isString && self._set_called)\n                        self.called = func;\n\n                    cur = (isString ? self[func] : func).apply(self, cur || []);\n                    if (f < length - 1)\n                        cur = !isArray(cur) || cur._use_call ? [cur] : cur\n                }\n                return cur;\n            }\n        },\n\n        getObject:gc.String.getObject,\n\n        newInstance:function ()\n        {\n            var inst = this.rawInstance();\n            var args;\n\n            if (inst.setup)\n                args = inst.setup.apply(inst, arguments);\n\n            // Added by martin@playcraftlabs.com -- fix for deep cloning of properties\n           for (var prop in inst.__proto__)\n               inst[prop] = cloneObject(inst[prop]);\n\n            if (inst.init)\n                inst.init.apply(inst, isArray(args) ? args : arguments);\n\n            return inst;\n        },\n\n        setup:function (baseClass, fullName)\n        {\n            this.defaults = extend(true, {}, baseClass.defaults, this.defaults);\n            if (this._types == undefined) this._types = [];\n            this._types.push(this.fullName);\n            if (this._fullTypeName == undefined) this._fullTypeName = '|';\n            this._fullTypeName += this.fullName + '|';\n            return arguments;\n        },\n        rawInstance:function ()\n        {\n            initializing = true;\n            var inst = new this();\n            initializing = false;\n            return inst;\n        },\n\n        extend:function (fullName, klass, proto)\n        {\n            // figure out what was passed\n            if (typeof fullName != 'string')\n            {\n                proto = klass;\n                klass = fullName;\n                fullName = null;\n            }\n            if (!proto)\n            {\n                proto = klass;\n                klass = null;\n            }\n\n            proto = proto || {};\n            var _super_class = this,\n                _super = this.prototype,\n                name, shortName, namespace, prototype;\n\n            // append the isA function\n            this.isA = function (typeName)\n            {\n                return this._fullTypeName.indexOf('|' + typeName + '|') != -1;\n            };\n\n            // Instantiate a base class (but only create the instance,\n            // don't run the init constructor)\n            initializing = true;\n            prototype = new this();\n            initializing = false;\n            // Copy the properties over onto the new prototype\n            inheritProps(proto, _super, prototype);\n\n            // The dummy class constructor\n\n            function Class()\n            {\n                // All construction is actually done in the init method\n                if (initializing) return;\n\n                if (this.constructor !== Class && arguments.length)\n                { //we are being called w/o new\n                    return arguments.callee.extend.apply(arguments.callee, arguments)\n                } else\n                { //we are being called w/ new\n                    // copy objects\n\n                    return this.Class.newInstance.apply(this.Class, arguments)\n                }\n            }\n\n            // Copy old stuff onto class\n            for (name in this)\n                if (this.hasOwnProperty(name))\n                    Class[name] = cloneObject(this[name]);\n\n            // copy new props on class\n            inheritProps(klass, this, Class);\n\n            // do namespace stuff\n            if (fullName)\n            {\n                var parts = fullName.split(/\\./);\n                var shortName = parts.pop();\n\n                // Martin Wells (playcraft): bug fix. Don't add a namespace object if the class name\n                // has no namespace elements (i.e. it's just \"MyClass\", not \"MyProject.MyClass\")\n                if (parts.length > 0)\n                {\n                    current = clss.getObject(parts.join('.'), window, true),\n                        namespace = current;\n                }\n\n                current[shortName] = Class;\n            }\n\n            // set things that can't be overwritten\n            extend(Class, {\n                prototype:prototype,\n                namespace:namespace,\n                shortName:shortName,\n                constructor:Class,\n                fullName:fullName\n            });\n\n            //make sure our prototype looks nice\n            Class.prototype.Class = Class.prototype.constructor = Class;\n\n            var args = Class.setup.apply(Class, concatArgs([_super_class], arguments));\n\n            if (Class.init)\n                Class.init.apply(Class, args || []);\n\n            /* @Prototype*/\n\n            return Class;\n        }\n    });\n\n    clss.prototype.callback = clss.callback;\n\n\n})(gamecore);\n",
    "/**\n * @class gamecore.Base\n * @description\n * A base class providing logging, object counting and unique object id's\n * Examples:\n *\n * Unique ID and total objects:\n * <pre><code>\n * var Fighter = gamecore.Base.extend('Fighter', {}, {});\n * var fighter1 = new Fighter();\n * var fighter2 = new Fighter();\n * fighter1.uniqueId;    // -> 'Fighter:0'\n * fighter2.uniqueId;    // -> 'Fighter:1'\n * Fighter.totalObjects; // -> 2\n * </code></pre>\n *\n * Logging: (log, info, warn, error, debug)\n * <pre><code>\n * fighter1.warn('oops'); // == console.log('Fighter:0 [WARN] oops');\n * </code></pre>\n */\ngamecore.Base = gamecore.Class('gamecore.Base',\n    /** @lends gamecore.Base */\n    {\n        totalObjects:0,\n        WARN:'WARN',\n        DEBUG:'DEBUG',\n        ERROR:'ERROR',\n        INFO:'INFO',\n\n        log:function (id, type, args)\n        {\n            var idString = '';\n            if (id) idString = ':' + id;\n            //console.log(this.fullName + idString + ' [' + type + '] ' + message);\n            console.log.apply(console, [this.fullName + idString + ' [' + type + '] '].concat(Array.prototype.slice.call(args)));\n        },\n\n        warn:function (message)\n        {\n            this.log(null, this.WARN, message);\n        },\n\n        debug:function (message)\n        {\n            this.log(null, this.DEBUG, message);\n        },\n\n        error:function (message)\n        {\n            this.log(null, this.ERROR, message);\n        },\n\n        info:function (message)\n        {\n            this.log(null, this.INFO, message);\n        },\n\n        assert:function (msg, condition)\n        {\n            if (!condition)\n                throw msg;\n        }\n\n    },\n    /** @lends gamecore.Base.prototype */\n    {\n        objectId:0,\n        uniqueId:null,\n\n        init:function ()\n        {\n        },\n\n        setup:function ()\n        {\n            this.objectId = this.Class.totalObjects++;\n            this.uniqueId = this.Class.fullName + ':' + this.objectId;\n        },\n\n        /**\n         * @returns {String} A system-wide unique Id for this object instance\n         */\n        getUniqueId:function ()\n        {\n            // if you see a null error here, then likely you have forgotten to call\n            // this._super in a subclassed init method.\n            return this.uniqueId;\n        },\n\n        /**\n         * @returns {String} A hash matching this object. Override this to implement different\n         * kinds of object hashing in derived classes.\n         */\n        hashCode:function ()\n        {\n            return this.getUniqueId();\n        },\n\n        warn:function (message)\n        {\n            this.Class.log(this.objectId, this.Class.WARN, arguments);\n        },\n        debug:function (message)\n        {\n            this.Class.log(this.objectId, this.Class.DEBUG, arguments);\n        },\n        error:function (message)\n        {\n            this.Class.log(this.objectId, this.Class.ERROR, arguments);\n        },\n        info:function (message)\n        {\n            this.Class.log(this.objectId, this.Class.INFO, arguments);\n        },\n\n        toString:function ()\n        {\n            return this.Class.fullName + ' [id: ' + this.objectId + ']';\n        }\n    });\n",
    "/**\n * Copyright 2010 Tim Down.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Author: Tim Down <tim@timdown.co.uk>\n * Version: 2.1\n * Build date: 21 March 2010\n * Website: http://www.timdown.co.uk/jshashtable\n *\n * (Slight mod to add to gamecore namespace -- martin@playcraftlabs.com)\n */\n\n/**\n * jshashtable\n *\n * jshashtable is a JavaScript implementation of a hash table. It creates a single constructor function called Hashtable\n * in the global scope.\n * Example:\n * <code>\n *     var map = new gamecore.Hashtable();\n *     map.put('test1', obj);\n *     var obj = map.get('test1');\n * </code>\n */\n\ngamecore.Hashtable = (function ()\n{\n    var FUNCTION = \"function\";\n\n    var arrayRemoveAt = (typeof Array.prototype.splice == FUNCTION) ?\n        function (arr, idx)\n        {\n            arr.splice(idx, 1);\n        } :\n\n        function (arr, idx)\n        {\n            var itemsAfterDeleted, i, len;\n            if (idx === arr.length - 1)\n            {\n                arr.length = idx;\n            } else\n            {\n                itemsAfterDeleted = arr.slice(idx + 1);\n                arr.length = idx;\n                for (i = 0, len = itemsAfterDeleted.length; i < len; ++i)\n                {\n                    arr[idx + i] = itemsAfterDeleted[i];\n                }\n            }\n        };\n\n    function hashObject(obj)\n    {\n        var hashCode;\n        if (typeof obj == \"string\")\n        {\n            return obj;\n        } else if (typeof obj.hashCode == FUNCTION)\n        {\n            // Check the hashCode method really has returned a string\n            hashCode = obj.hashCode();\n            return (typeof hashCode == \"string\") ? hashCode : hashObject(hashCode);\n        } else if (typeof obj.toString == FUNCTION)\n        {\n            return obj.toString();\n        } else\n        {\n            try\n            {\n                return String(obj);\n            }\n            catch (ex)\n            {\n                // For host objects (such as ActiveObjects in IE) that have no toString() method and throw an error when\n                // passed to String()\n                return Object.prototype.toString.call(obj);\n            }\n        }\n    }\n\n    function equals_fixedValueHasEquals(fixedValue, variableValue)\n    {\n        return fixedValue.equals(variableValue);\n    }\n\n    function equals_fixedValueNoEquals(fixedValue, variableValue)\n    {\n        return (typeof variableValue.equals == FUNCTION) ?\n            variableValue.equals(fixedValue) : (fixedValue === variableValue);\n    }\n\n    function createKeyValCheck(kvStr)\n    {\n        return function (kv)\n        {\n            if (kv === null)\n            {\n                throw new Error(\"null is not a valid \" + kvStr);\n            } else if (typeof kv == \"undefined\")\n            {\n                throw new Error(kvStr + \" must not be undefined\");\n            }\n        };\n    }\n\n    var checkKey = createKeyValCheck(\"key\"), checkValue = createKeyValCheck(\"value\");\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    function Bucket(hash, firstKey, firstValue, equalityFunction)\n    {\n        this[0] = hash;\n        this.entries = [];\n        this.addEntry(firstKey, firstValue);\n\n        if (equalityFunction !== null)\n        {\n            this.getEqualityFunction = function ()\n            {\n                return equalityFunction;\n            };\n        }\n    }\n\n    var EXISTENCE = 0, ENTRY = 1, ENTRY_INDEX_AND_VALUE = 2;\n\n    function createBucketSearcher(mode)\n    {\n        return function (key)\n        {\n            var i = this.entries.length, entry, equals = this.getEqualityFunction(key);\n            while (i--)\n            {\n                entry = this.entries[i];\n                if (equals(key, entry[0]))\n                {\n                    switch (mode)\n                    {\n                        case EXISTENCE:\n                            return true;\n                        case ENTRY:\n                            return entry;\n                        case ENTRY_INDEX_AND_VALUE:\n                            return [ i, entry[1] ];\n                    }\n                }\n            }\n            return false;\n        };\n    }\n\n    function createBucketLister(entryProperty)\n    {\n        return function (aggregatedArr)\n        {\n            var startIndex = aggregatedArr.length;\n            for (var i = 0, len = this.entries.length; i < len; ++i)\n            {\n                aggregatedArr[startIndex + i] = this.entries[i][entryProperty];\n            }\n        };\n    }\n\n    Bucket.prototype = {\n        getEqualityFunction:function (searchValue)\n        {\n            return (typeof searchValue.equals == FUNCTION) ? equals_fixedValueHasEquals : equals_fixedValueNoEquals;\n        },\n\n        getEntryForKey:createBucketSearcher(ENTRY),\n\n        getEntryAndIndexForKey:createBucketSearcher(ENTRY_INDEX_AND_VALUE),\n\n        removeEntryForKey:function (key)\n        {\n            var result = this.getEntryAndIndexForKey(key);\n            if (result)\n            {\n                arrayRemoveAt(this.entries, result[0]);\n                return result[1];\n            }\n            return null;\n        },\n\n        addEntry:function (key, value)\n        {\n            this.entries[this.entries.length] = [key, value];\n        },\n\n        keys:createBucketLister(0),\n\n        values:createBucketLister(1),\n\n        getEntries:function (entries)\n        {\n            var startIndex = entries.length;\n            for (var i = 0, len = this.entries.length; i < len; ++i)\n            {\n                // Clone the entry stored in the bucket before adding to array\n                entries[startIndex + i] = this.entries[i].slice(0);\n            }\n        },\n\n        containsKey:createBucketSearcher(EXISTENCE),\n\n        containsValue:function (value)\n        {\n            var i = this.entries.length;\n            while (i--)\n            {\n                if (value === this.entries[i][1])\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    // Supporting functions for searching hashtable buckets\n\n    function searchBuckets(buckets, hash)\n    {\n        var i = buckets.length, bucket;\n        while (i--)\n        {\n            bucket = buckets[i];\n            if (hash === bucket[0])\n            {\n                return i;\n            }\n        }\n        return null;\n    }\n\n    function getBucketForHash(bucketsByHash, hash)\n    {\n        var bucket = bucketsByHash[hash];\n\n        // Check that this is a genuine bucket and not something inherited from the bucketsByHash's prototype\n        return ( bucket && (bucket instanceof Bucket) ) ? bucket : null;\n    }\n\n    /*----------------------------------------------------------------------------------------------------------------*/\n\n    function Hashtable(hashingFunctionParam, equalityFunctionParam)\n    {\n        var that = this;\n        var buckets = [];\n        var bucketsByHash = {};\n\n        var hashingFunction = (typeof hashingFunctionParam == FUNCTION) ? hashingFunctionParam : hashObject;\n        var equalityFunction = (typeof equalityFunctionParam == FUNCTION) ? equalityFunctionParam : null;\n\n        this.put = function (key, value)\n        {\n            checkKey(key);\n            checkValue(value);\n            var hash = hashingFunction(key), bucket, bucketEntry, oldValue = null;\n\n            // Check if a bucket exists for the bucket key\n            bucket = getBucketForHash(bucketsByHash, hash);\n            if (bucket)\n            {\n                // Check this bucket to see if it already contains this key\n                bucketEntry = bucket.getEntryForKey(key);\n                if (bucketEntry)\n                {\n                    // This bucket entry is the current mapping of key to value, so replace old value and we're done.\n                    oldValue = bucketEntry[1];\n                    bucketEntry[1] = value;\n                } else\n                {\n                    // The bucket does not contain an entry for this key, so add one\n                    bucket.addEntry(key, value);\n                }\n            } else\n            {\n                // No bucket exists for the key, so create one and put our key/value mapping in\n                bucket = new Bucket(hash, key, value, equalityFunction);\n                buckets[buckets.length] = bucket;\n                bucketsByHash[hash] = bucket;\n            }\n            return oldValue;\n        };\n\n        this.get = function (key)\n        {\n            checkKey(key);\n\n            var hash = hashingFunction(key);\n\n            // Check if a bucket exists for the bucket key\n            var bucket = getBucketForHash(bucketsByHash, hash);\n            if (bucket)\n            {\n                // Check this bucket to see if it contains this key\n                var bucketEntry = bucket.getEntryForKey(key);\n                if (bucketEntry)\n                {\n                    // This bucket entry is the current mapping of key to value, so return the value.\n                    return bucketEntry[1];\n                }\n            }\n            return null;\n        };\n\n        this.containsKey = function (key)\n        {\n            checkKey(key);\n            var bucketKey = hashingFunction(key);\n\n            // Check if a bucket exists for the bucket key\n            var bucket = getBucketForHash(bucketsByHash, bucketKey);\n\n            return bucket ? bucket.containsKey(key) : false;\n        };\n\n        this.containsValue = function (value)\n        {\n            checkValue(value);\n            var i = buckets.length;\n            while (i--)\n            {\n                if (buckets[i].containsValue(value))\n                {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        this.clear = function ()\n        {\n            buckets.length = 0;\n            bucketsByHash = {};\n        };\n\n        this.isEmpty = function ()\n        {\n            return !buckets.length;\n        };\n\n        var createBucketAggregator = function (bucketFuncName)\n        {\n            return function ()\n            {\n                var aggregated = [], i = buckets.length;\n                while (i--)\n                {\n                    buckets[i][bucketFuncName](aggregated);\n                }\n                return aggregated;\n            };\n        };\n\n        this.keys = createBucketAggregator(\"keys\");\n        this.values = createBucketAggregator(\"values\");\n        this.entries = createBucketAggregator(\"getEntries\");\n\n        this.remove = function (key)\n        {\n            checkKey(key);\n\n            var hash = hashingFunction(key), bucketIndex, oldValue = null;\n\n            // Check if a bucket exists for the bucket key\n            var bucket = getBucketForHash(bucketsByHash, hash);\n\n            if (bucket)\n            {\n                // Remove entry from this bucket for this key\n                oldValue = bucket.removeEntryForKey(key);\n                if (oldValue !== null)\n                {\n                    // Entry was removed, so check if bucket is empty\n                    if (!bucket.entries.length)\n                    {\n                        // Bucket is empty, so remove it from the bucket collections\n                        bucketIndex = searchBuckets(buckets, hash);\n                        arrayRemoveAt(buckets, bucketIndex);\n                        delete bucketsByHash[hash];\n                    }\n                }\n            }\n            return oldValue;\n        };\n\n        this.size = function ()\n        {\n            var total = 0, i = buckets.length;\n            while (i--)\n            {\n                total += buckets[i].entries.length;\n            }\n            return total;\n        };\n\n        this.each = function (callback)\n        {\n            var entries = that.entries(), i = entries.length, entry;\n            while (i--)\n            {\n                entry = entries[i];\n                callback(entry[0], entry[1]);\n            }\n        };\n\n        this.putAll = function (hashtable, conflictCallback)\n        {\n            var entries = hashtable.entries();\n            var entry, key, value, thisValue, i = entries.length;\n            var hasConflictCallback = (typeof conflictCallback == FUNCTION);\n            while (i--)\n            {\n                entry = entries[i];\n                key = entry[0];\n                value = entry[1];\n\n                // Check for a conflict. The default behaviour is to overwrite the value for an existing key\n                if (hasConflictCallback && (thisValue = that.get(key)))\n                {\n                    value = conflictCallback(key, thisValue, value);\n                }\n                that.put(key, value);\n            }\n        };\n\n        this.clone = function ()\n        {\n            var clone = new Hashtable(hashingFunctionParam, equalityFunctionParam);\n            clone.putAll(that);\n            return clone;\n        };\n\n        /**\n         * Added by martin@playcratlabs.com to support debug dumping of hash arrays\n         */\n        this.toString = function ()\n        {\n            var result = '';\n            var keys = this.keys();\n            for (var i = 0; i < keys.length; i++)\n            {\n                var obj = this.get(keys[i]);\n                result += keys[i].toString() + ' = ' + obj.toString() + '\\n';\n            }\n\n            return result;\n        }\n    }\n\n    return Hashtable;\n})();",
    "/**\n * gamecore.js - Copyright 2012 Playcraft Labs, Inc. (see licence.txt)\n * device.js\n * Access to device capabilities\n */\n\n/**\n * @class gamecore.Device\n * Staic class with lots of device information.\n */\n\ngamecore.Device = gamecore.Base.extend('gamecore.Device',\n    {\n        pixelRatio:0,\n        isiPhone:false,\n        isiPhone4:false,\n        isiPad:false,\n        isiPod: false,\n        isAndroid:false,\n        isTouch:false,\n        isFirefox:false,\n        isChrome:false,\n        isOpera:false,\n        isIE:false,\n        ieVersion:0,\n        requestAnimFrame:null,\n        hasMemoryProfiling:false,\n        canPlayOgg: false,\n        canPlayMP3: false,\n        canPlayWav: false,\n\n        init:function ()\n        {\n            this.pixelRatio = window.devicePixelRatio || 1;\n            this.isiPhone = navigator.userAgent.toLowerCase().indexOf('iphone') != -1;\n            this.isiPod = navigator.userAgent.toLowerCase().indexOf('ipod') != -1;\n            this.isiPhone4 = (this.pixelRatio == 2 && this.isiPhone);\n            this.isiPad = navigator.userAgent.toLowerCase().indexOf('ipad') != -1;\n            this.isAndroid = navigator.userAgent.toLowerCase().indexOf('android') != -1;\n            this.isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') != -1;\n            this.isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') != -1;\n            this.isOpera = navigator.userAgent.toLowerCase().indexOf('opera') != -1;\n            this.isTouch = window.ontouchstart !== 'undefined';\n            this.isiOS = (this.isiPhone || this.iPad || this.isiPod);\n\n            if (window.performance != undefined)\n                this.hasMemoryProfiling = (window.performance.memory);\n\n            if (/MSIE (\\d+\\.\\d+);/.test(navigator.userAgent))\n            {\n                this.ieVersion = new Number(RegExp.$1);\n                this.isIE = true;\n            }\n\n            // determine what sound formats we can play\n            var check = new Audio();\n            if (check.canPlayType('audio/ogg')) this.canPlayOgg = true;\n            if (check.canPlayType('audio/mpeg')) this.canPlayMP3 = true;\n            if (check.canPlayType('audio/x-wav')) this.canPlayWav = true;\n\n            this.requestAnimFrame = (function ()\n            {\n                var request =\n                    window.requestAnimationFrame ||\n                        window.webkitRequestAnimationFrame ||\n                        window.mozRequestAnimationFrame ||\n                        window.oRequestAnimationFrame ||\n                        window.msRequestAnimationFrame ||\n                        function (callback, element)\n                        {\n                            window.setTimeout(callback, 16, Date.now());\n                        };\n\n                // apply to our window global to avoid illegal invocations (it's a native)\n                return function (callback, element)\n                {\n                    request.apply(window, [callback, element]);\n                };\n            })();\n\n            // todo:\n            // highres timer\n            // game pads\n            // fullscreen api\n            // mouse lock\n        },\n\n        canPlay: function(format)\n        {\n            if (format.toLowerCase() === 'mp3' && this.canPlayMP3) return true;\n            if (format.toLowerCase() === 'ogg' && this.canPlayOgg) return true;\n            if (format.toLowerCase() === 'wav' && this.canPlayWav) return true;\n            return false;\n        },\n\n        getUsedHeap:function ()\n        {\n            return this.hasMemoryProfiling ? window.performance.memory.usedJSHeapSize : 0;\n        },\n\n        getTotalHeap:function ()\n        {\n            return this.hasMemoryProfiling ? window.performance.memory.totalJSHeapSize : 0;\n        }\n\n\n    },\n    {\n        // Singleton static class, so nothing required here\n    });",
    "/**\n * gamecore.js - Copyright 2012 Playcraft Labs, Inc. (see licence.txt)\n * perf.js\n * Simple performance monitoring tools.\n */\n\n/**\n * @class gamecore.PerformanceMeasure\n * Example:\n * <code>\n * var measure = new gamecore.PerformanceMeasure('A test');\n * // ... do something\n * console.log(measure.end()); // end returns a string you can easily log\n * </code>\n *\n * The memory count is an idea based on a delta of the useJSHeapSize exposed by Chrome.\n * You will need to restart Chrome with --enable-memory-info to have this exposed.\n * It is however, not very reliable as the value will jump around due to gc runs (I think).\n * So far it seems to produce reliable results that are consistent, however memStart > memEnd\n * cases still occur and it would be good to understand this more (is it limited only to GC\n * runs? if so, why is it so consistent?).\n */\n\ngamecore.PerformanceMeasure = gamecore.Base.extend('gamecore.PerformanceMeasure',\n{\n    history: [],\n\n    /**\n     * Clears the performance history\n     */\n    clearHistory: function()\n    {\n        history.length = 0;\n    }\n},\n{\n    timeStart: 0,\n    timeEnd: 0,\n    timeDelat: 0,\n    memStart: 0,\n    memEnd: 0,\n    memDelta: 0,\n    description: null,\n\n    /**\n     * Constructs a new performance measure with description\n     * @param description\n     */\n    init: function(description)\n    {\n        this.description = description;\n        this.start();\n        this.Class.history.push(this);\n    },\n\n    /**\n     * Starts a performance measure\n     */\n    start: function()\n    {\n        this.timeStart = Date.now();\n        this.memStart = gamecore.Device.getUsedHeap();\n    },\n\n    /**\n     * Ends a performance measure, and for convenience returns a toString of the measurement\n     * @return String representing the measurement\n     */\n    end: function()\n    {\n        this.timeEnd = Date.now();\n        this.timeDelta = this.timeEnd - this.timeStart;\n        this.memEnd = gamecore.Device.getUsedHeap();\n\n        if (this.memEnd < this.memStart)\n            this.memDelta = 0;\n        else\n            this.memDelta = this.memEnd - this.memStart;\n        return this.toString();\n    },\n\n    /**\n     * Reports the performance measurement in a nice clean way\n     */\n    toString: function()\n    {\n        return this.description + ' took ' + this.timeDelta + 'ms, ' +\n            (this.memDelta == 0 ? 'unknown':this.memDelta) + ' byte(s)';\n    }\n\n});",
    "/**\n * gamecore.js - Copyright 2012 Playcraft Labs, Inc. (see licence.txt)\n * linkedlist.js\n * A high-perforance doubly-linked list intended for use in gaming\n */\n\n/**\n * @class gamecore.LinkedNode\n * @description\n * Represents an item stored in a linked list.\n */\ngamecore.LinkedListNode = gamecore.Base('gamecore.LinkedNode', {},\n    /** @lends gamecore.LinkedListNode.prototype */\n    {\n        obj:null, // the object reference\n        nextLinked:null, // link to next object in the list\n        prevLinked:null, // link to previous object in the list\n        free:true,\n\n        /**\n         * @return {pc.LinkedListNode} Next node on the list\n         */\n        next:function ()\n        {\n            return this.nextLinked;\n        },\n\n        /**\n         * @return {Object} Object this node represents on the list\n         */\n        object:function ()\n        {\n            return this.obj;\n        },\n\n        /**\n         * @return {pc.LinkedListNode} Prev node on the list\n         */\n        prev:function ()\n        {\n            return this.prevLinked;\n        }\n\n    });\n\n/**\n * @class gamecore.LinkedList\n * @description\n * A high-speed doubly linked list of objects. Note that for speed reasons (using a dictionary lookup of\n * cached nodes) there can only be a single instance of an object in the list at the same time. Adding the same\n * object a second time will result in a silent return from the add method.\n * <p>\n * In order to keep a track of node links, an object must be able to identify itself with a getUniqueId() function.\n * <p>\n * To add an item use:\n * <pre><code>\n *   list.add(newItem);\n * </code></pre>\n * <p>\n * You can iterate using the first and next members, such as:\n * <pre><code>\n *   var node = list.first;\n *   while (node)\n *   {\n *       node.object().DOSOMETHING();\n *       node = node.next();\n *   }\n * </code></pre>\n */\ngamecore.LinkedList = gamecore.Base('gamecore.LinkedList',\n    /** @lends gamecore.LinkedList */\n    {\n    },\n    /** @lends gamecore.LinkedList.prototype */\n    {\n        first:null,\n        last:null,\n        count:0,\n        objToNodeMap:null, // a quick lookup list to map linked list nodes to objects\n\n        /**\n         * Constructs a new linked list\n         */\n        init:function ()\n        {\n            this._super();\n            this.objToNodeMap = new gamecore.Hashtable();\n        },\n\n        /**\n         * Get the LinkedListNode for this object.\n         * @param obj The object to get the node for\n         */\n        getNode:function (obj)\n        {\n            // objects added to a list must implement a getUniqueId which returns a unique object identifier string\n            // or just extend gamecore.Base to get it for free\n            return this.objToNodeMap.get(obj.getUniqueId());\n        },\n\n        /**\n         * Adds a specific node to the list -- typically only used internally unless you're doing something funky\n         * Use add() to add an object to the list, not this.\n         */\n        addNode:function (obj)\n        {\n            var node = new gamecore.LinkedNode();\n            node.obj = obj;\n            node.prevLinked = null;\n            node.nextLinked = null;\n            node.free = false;\n            this.objToNodeMap.put(obj.getUniqueId(), node);\n            return node;\n        },\n\n        /**\n         * Add an item to the list\n         * @param obj The object to add\n         */\n        add:function (obj)\n        {\n            var node = this.getNode(obj);\n            if (node == null)\n            {\n                node = this.addNode(obj);\n            } else\n            {\n                // if the object is already in the list just throw an (can't add an object more than once)\n                // if you want to quickly check if an item is already in a list, then call list.has(obj)\n                if (node.free == false)\n                    throw 'Attempting to add object: ' + obj.getUniqueId() + ' twice to list ' + this.getUniqueId();\n\n                // reusing a node, so we clean it up\n                // this caching of node/object pairs is the reason an object can only exist\n                // once in a list -- which also makes things faster (not always creating new node\n                // object every time objects are moving on and off the list\n                node.obj = obj;\n                node.free = false;\n                node.nextLinked = null;\n                node.prevLinked = null;\n            }\n\n            // append this obj to the end of the list\n            if (this.first == null) // is this the first?\n            {\n                this.first = node;\n                this.last = node;\n                node.nextLinked = null; // clear just in case\n                node.prevLinked = null;\n            } else\n            {\n                if (this.last == null)\n                    throw \"Hmm, no last in the list -- that shouldn't happen here\";\n\n                // add this entry to the end of the list\n                this.last.nextLinked = node; // current end of list points to the new end\n                node.prevLinked = this.last;\n                this.last = node;            // new object to add becomes last in the list\n                node.nextLinked = null;      // just in case this was previously set\n            }\n            this.count++;\n\n            if (this.showDebug) this.dump('after add');\n        },\n\n        has:function (obj)\n        {\n            var node = this.getNode(obj);\n            return !(node == null || node.free == true);\n        },\n\n        /**\n         * Moves this item upwards in the list\n         * @param obj\n         */\n        moveUp:function (obj)\n        {\n            this.dump('before move up');\n            var c = this.getNode(obj);\n            if (!c) throw \"Oops, trying to move an object that isn't in the list\";\n            if (c.prevLinked == null) return; // already first, ignore\n\n            // This operation makes C swap places with B:\n            // A <-> B <-> C <-> D\n            // A <-> C <-> B <-> D\n\n            var b = c.prevLinked;\n            var a = b.prevLinked;\n\n            // fix last\n            if (c == this.last)\n                this.last = b;\n\n            var oldCNext = c.nextLinked;\n\n            if (a)\n                a.nextLinked = c;\n            c.nextLinked = b;\n            c.prevLinked = b.prevLinked;\n\n            b.nextLinked = oldCNext;\n            b.prevLinked = c;\n\n            // check to see if we are now first\n            if (this.first == b)\n                this.first = c;\n        },\n\n        /**\n         * Moves this item downwards in the list\n         * @param obj\n         */\n        moveDown:function (obj)\n        {\n            var b = this.getNode(obj);\n            if (!b) throw \"Oops, trying to move an object that isn't in the list\";\n            if (b.nextLinked == null) return; // already last, ignore\n\n            // This operation makes B swap places with C:\n            // A <-> B <-> C <-> D\n            // A <-> C <-> B <-> D\n\n            var c = b.nextLinked;\n            this.moveUp(c.obj);\n\n            // check to see if we are now last\n            if (this.last == c)\n                this.last = b;\n        },\n\n        sort:function (compare)\n        {\n            // take everything off the list and put it in an array\n            var sortArray = [];\n            var node = this.first;\n            while (node)\n            {\n                sortArray.push(node.object());\n                node = node.next();\n            }\n\n            this.clear();\n\n            // sort it\n            sortArray.sort(compare);\n\n            // then put it back\n            for (var i = 0; i < sortArray.length; i++)\n                this.add(sortArray[i]);\n        },\n\n        /**\n         * Removes an item from the list\n         * @param obj The object to remove\n         * @returns boolean true if the item was removed, false if the item was not on the list\n         */\n        remove:function (obj)\n        {\n            if (this.showDebug) this.dump('before remove of ' + obj);\n            var node = this.getNode(obj);\n            if (node == null || node.free == true)\n                return false; // ignore this error (trying to remove something not there\n            //throw ('Error: trying to remove a node (' + obj + ') that isnt on the list ');\n\n            // pull this object out and tie up the ends\n            if (node.prevLinked != null)\n                node.prevLinked.nextLinked = node.nextLinked;\n            if (node.nextLinked != null)\n                node.nextLinked.prevLinked = node.prevLinked;\n\n            // fix first and last\n            if (node.prevLinked == null) // if this was first on the list\n                this.first = node.nextLinked; // make the next on the list first (can be null)\n            if (node.nextLinked == null) // if this was the last\n                this.last = node.prevLinked; // then this nodes previous becomes last\n\n            node.free = true;\n            node.prevLinked = null;\n            node.nextLinked = null;\n\n            this.count--;\n            if (this.showDebug) this.dump('after remove');\n\n            return true;\n        },\n\n        /**\n         * Clears the list out\n         */\n        clear:function ()\n        {\n            // sweep the list and free all the nodes\n            var next = this.first;\n            while (next != null)\n            {\n                next.free = true;\n                next = next.nextLinked;\n            }\n            this.first = null;\n            this.count = 0;\n        },\n\n        /**\n         * @return number of items in the list\n         */\n        length:function ()\n        {\n            return this.count;\n        },\n\n        /**\n         * Outputs the contents of the current list. Usually for debugging.\n         */\n        dump:function (msg)\n        {\n            this.debug('====================' + msg + '=====================');\n            var a = this.first;\n            while (a != null)\n            {\n                this.debug(\"{\" + a.obj.toString() + \"} previous=\" + ( a.prevLinked ? a.prevLinked.obj : \"NULL\"));\n                a = a.next();\n            }\n            this.debug(\"===================================\");\n            this.debug(\"Last: {\" + (this.last ? this.last.obj : 'NULL') + \"} \" +\n                \"First: {\" + (this.first ? this.first.obj : 'NULL') + \"}\");\n        }\n\n    })\n;\n\n\n",
    "\n/**\n * @class gamecore.HashList\n * @description\n * A map of linked lists mapped by a string value\n */\ngamecore.HashList = gamecore.Base.extend('gamecore.HashList',\n    {},\n    /** @lends gamecore.HashList */\n    {\n        /** Internal hash table of lists */\n        hashtable: null,\n\n        /**\n         * Constructs a new hash list\n         */\n        init: function()\n        {\n            this.hashtable = new gamecore.Hashtable();\n        },\n\n        /**\n         * Add an object to a list based on the given key. If the list doesn't yet exist it will be constructed.\n         * @param {String} key Key\n         * @param {Object} object Object to store\n         */\n        add: function(key, object)\n        {\n            // find the list associated with this key and add the object to it\n            var list = this.hashtable.get(key);\n            if (list == null)\n            {\n                // no list associated with this key yet, so let's make one\n                list = new pc.LinkedList();\n                this.hashtable.put(key, list);\n            }\n            list.add(object);\n        },\n\n        /**\n         * Removes an object from the list\n         * @param {String} key Key for the list to remove the object from\n         * @param {Object} object Object to remove\n         */\n        remove: function(key, object)\n        {\n            var list = this.hashtable.get(key);\n            if (list == null) throw \"No list for a key in hashlist when removing\";\n            list.remove(object);\n        },\n\n        /**\n         * Get a list associated with a given key\n         * @param {String} key The key\n         * @return {gamecore.LinkedList} The list\n         */\n        get: function(key)\n        {\n            return this.hashtable.get(key);\n        }\n\n\n    });\n",
    "// Domain Public by Eric Wendelin http://eriwen.com/ (2008)\n//                  Luke Smith http://lucassmith.name/ (2008)\n//                  Loic Dachary <loic@dachary.org> (2008)\n//                  Johan Euphrosine <proppy@aminche.com> (2008)\n//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)\n//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)\n\n/**\n * Main function giving a function stack trace with a forced or passed in Error\n *\n * @cfg {Error} e The error to create a stacktrace from (optional)\n * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions\n * @return {Array} of Strings with functions, lines, files, and arguments where possible\n */\nfunction printStackTrace(options) {\n    options = options || {guess: true};\n    var ex = options.e || null, guess = !!options.guess;\n    var p = new printStackTrace.implementation(), result = p.run(ex);\n    return (guess) ? p.guessAnonymousFunctions(result) : result;\n}\n\nprintStackTrace.implementation = function() {\n};\n\nprintStackTrace.implementation.prototype = {\n    /**\n     * @param {Error} ex The error to create a stacktrace from (optional)\n     * @param {String} mode Forced mode (optional, mostly for unit tests)\n     */\n    run: function(ex, mode) {\n        ex = ex || this.createException();\n        // examine exception properties w/o debugger\n        //for (var prop in ex) {alert(\"Ex['\" + prop + \"']=\" + ex[prop]);}\n        mode = mode || this.mode(ex);\n        if (mode === 'other') {\n            return this.other(arguments.callee);\n        } else {\n            return this[mode](ex);\n        }\n    },\n\n    createException: function() {\n        try {\n            this.undef();\n        } catch (e) {\n            return e;\n        }\n    },\n\n    /**\n     * Mode could differ for different exception, e.g.\n     * exceptions in Chrome may or may not have arguments or stack.\n     *\n     * @return {String} mode of operation for the exception\n     */\n    mode: function(e) {\n        if (e['arguments'] && e.stack) {\n            return 'chrome';\n        } else if (typeof e.message === 'string' && typeof window !== 'undefined' && window.opera) {\n            // e.message.indexOf(\"Backtrace:\") > -1 -> opera\n            // !e.stacktrace -> opera\n            if (!e.stacktrace) {\n                return 'opera9'; // use e.message\n            }\n            // 'opera#sourceloc' in e -> opera9, opera10a\n            if (e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n                return 'opera9'; // use e.message\n            }\n            // e.stacktrace && !e.stack -> opera10a\n            if (!e.stack) {\n                return 'opera10a'; // use e.stacktrace\n            }\n            // e.stacktrace && e.stack -> opera10b\n            if (e.stacktrace.indexOf(\"called from line\") < 0) {\n                return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'\n            }\n            // e.stacktrace && e.stack -> opera11\n            return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'\n        } else if (e.stack) {\n            return 'firefox';\n        }\n        return 'other';\n    },\n\n    /**\n     * Given a context, function name, and callback function, overwrite it so that it calls\n     * printStackTrace() first with a callback and then runs the rest of the body.\n     *\n     * @param {Object} context of execution (e.g. window)\n     * @param {String} functionName to instrument\n     * @param {Function} function to call with a stack trace on invocation\n     */\n    instrumentFunction: function(context, functionName, callback) {\n        context = context || window;\n        var original = context[functionName];\n        context[functionName] = function instrumented() {\n            callback.call(this, printStackTrace().slice(4));\n            return context[functionName]._instrumented.apply(this, arguments);\n        };\n        context[functionName]._instrumented = original;\n    },\n\n    /**\n     * Given a context and function name of a function that has been\n     * instrumented, revert the function to it's original (non-instrumented)\n     * state.\n     *\n     * @param {Object} context of execution (e.g. window)\n     * @param {String} functionName to de-instrument\n     */\n    deinstrumentFunction: function(context, functionName) {\n        if (context[functionName].constructor === Function &&\n                context[functionName]._instrumented &&\n                context[functionName]._instrumented.constructor === Function) {\n            context[functionName] = context[functionName]._instrumented;\n        }\n    },\n\n    /**\n     * Given an Error object, return a formatted Array based on Chrome's stack string.\n     *\n     * @param e - Error object to inspect\n     * @return Array<String> of function calls, files and line numbers\n     */\n    chrome: function(e) {\n        var stack = (e.stack + '\\n').replace(/^\\S[^\\(]+?[\\n$]/gm, '').\n          replace(/^\\s+(at eval )?at\\s+/gm, '').\n          replace(/^([^\\(]+?)([\\n$])/gm, '{anonymous}()@$1$2').\n          replace(/^Object.<anonymous>\\s*\\(([^\\)]+)\\)/gm, '{anonymous}()@$1').split('\\n');\n        stack.pop();\n        return stack;\n    },\n\n    /**\n     * Given an Error object, return a formatted Array based on Firefox's stack string.\n     *\n     * @param e - Error object to inspect\n     * @return Array<String> of function calls, files and line numbers\n     */\n    firefox: function(e) {\n        return e.stack.replace(/(?:\\n@:0)?\\s+$/m, '').replace(/^\\(/gm, '{anonymous}(').split('\\n');\n    },\n\n    opera11: function(e) {\n        // \"Error thrown at line 42, column 12 in <anonymous function>() in file://localhost/G:/js/stacktrace.js:\\n\"\n        // \"Error thrown at line 42, column 12 in <anonymous function: createException>() in file://localhost/G:/js/stacktrace.js:\\n\"\n        // \"called from line 7, column 4 in bar(n) in file://localhost/G:/js/test/functional/testcase1.html:\\n\"\n        // \"called from line 15, column 3 in file://localhost/G:/js/test/functional/testcase1.html:\\n\"\n        var ANON = '{anonymous}', lineRE = /^.*line (\\d+), column (\\d+)(?: in (.+))? in (\\S+):$/;\n        var lines = e.stacktrace.split('\\n'), result = [];\n\n        for (var i = 0, len = lines.length; i < len; i += 2) {\n            var match = lineRE.exec(lines[i]);\n            if (match) {\n                var location = match[4] + ':' + match[1] + ':' + match[2];\n                var fnName = match[3] || \"global code\";\n                fnName = fnName.replace(/<anonymous function: (\\S+)>/, \"$1\").replace(/<anonymous function>/, ANON);\n                result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n            }\n        }\n\n        return result;\n    },\n\n    opera10b: function(e) {\n        // \"<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\\n\" +\n        // \"printStackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\\n\" +\n        // \"@file://localhost/G:/js/test/functional/testcase1.html:15\"\n        var lineRE = /^(.*)@(.+):(\\d+)$/;\n        var lines = e.stacktrace.split('\\n'), result = [];\n\n        for (var i = 0, len = lines.length; i < len; i++) {\n            var match = lineRE.exec(lines[i]);\n            if (match) {\n                var fnName = match[1]? (match[1] + '()') : \"global code\";\n                result.push(fnName + '@' + match[2] + ':' + match[3]);\n            }\n        }\n\n        return result;\n    },\n\n    /**\n     * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.\n     *\n     * @param e - Error object to inspect\n     * @return Array<String> of function calls, files and line numbers\n     */\n    opera10a: function(e) {\n        // \"  Line 27 of linked script file://localhost/G:/js/stacktrace.js\\n\"\n        // \"  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\\n\"\n        var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n        var lines = e.stacktrace.split('\\n'), result = [];\n\n        for (var i = 0, len = lines.length; i < len; i += 2) {\n            var match = lineRE.exec(lines[i]);\n            if (match) {\n                var fnName = match[3] || ANON;\n                result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n            }\n        }\n\n        return result;\n    },\n\n    // Opera 7.x-9.2x only!\n    opera9: function(e) {\n        // \"  Line 43 of linked script file://localhost/G:/js/stacktrace.js\\n\"\n        // \"  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\\n\"\n        var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n        var lines = e.message.split('\\n'), result = [];\n\n        for (var i = 2, len = lines.length; i < len; i += 2) {\n            var match = lineRE.exec(lines[i]);\n            if (match) {\n                result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\n            }\n        }\n\n        return result;\n    },\n\n    // Safari, IE, and others\n    other: function(curr) {\n        var ANON = '{anonymous}', fnRE = /function\\s*([\\w\\-$]+)?\\s*\\(/i, stack = [], fn, args, maxStackSize = 10;\n        while (curr && curr['arguments'] && stack.length < maxStackSize) {\n            fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;\n            args = Array.prototype.slice.call(curr['arguments'] || []);\n            stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';\n            curr = curr.caller;\n        }\n        return stack;\n    },\n\n    /**\n     * Given arguments array as a String, subsituting type names for non-string types.\n     *\n     * @param {Arguments} object\n     * @return {Array} of Strings with stringified arguments\n     */\n    stringifyArguments: function(args) {\n        var result = [];\n        var slice = Array.prototype.slice;\n        for (var i = 0; i < args.length; ++i) {\n            var arg = args[i];\n            if (arg === undefined) {\n                result[i] = 'undefined';\n            } else if (arg === null) {\n                result[i] = 'null';\n            } else if (arg.constructor) {\n                if (arg.constructor === Array) {\n                    if (arg.length < 3) {\n                        result[i] = '[' + this.stringifyArguments(arg) + ']';\n                    } else {\n                        result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';\n                    }\n                } else if (arg.constructor === Object) {\n                    result[i] = '#object';\n                } else if (arg.constructor === Function) {\n                    result[i] = '#function';\n                } else if (arg.constructor === String) {\n                    result[i] = '\"' + arg + '\"';\n                } else if (arg.constructor === Number) {\n                    result[i] = arg;\n                }\n            }\n        }\n        return result.join(',');\n    },\n\n    sourceCache: {},\n\n    /**\n     * @return the text from a given URL\n     */\n    ajax: function(url) {\n        var req = this.createXMLHTTPObject();\n        if (req) {\n            try {\n                req.open('GET', url, false);\n                //req.overrideMimeType('text/plain');\n                //req.overrideMimeType('text/javascript');\n                req.send(null);\n                //return req.status == 200 ? req.responseText : '';\n                return req.responseText;\n            } catch (e) {\n            }\n        }\n        return '';\n    },\n\n    /**\n     * Try XHR methods in order and store XHR factory.\n     *\n     * @return <Function> XHR function or equivalent\n     */\n    createXMLHTTPObject: function() {\n        var xmlhttp, XMLHttpFactories = [\n            function() {\n                return new XMLHttpRequest();\n            }, function() {\n                return new ActiveXObject('Msxml2.XMLHTTP');\n            }, function() {\n                return new ActiveXObject('Msxml3.XMLHTTP');\n            }, function() {\n                return new ActiveXObject('Microsoft.XMLHTTP');\n            }\n        ];\n        for (var i = 0; i < XMLHttpFactories.length; i++) {\n            try {\n                xmlhttp = XMLHttpFactories[i]();\n                // Use memoization to cache the factory\n                this.createXMLHTTPObject = XMLHttpFactories[i];\n                return xmlhttp;\n            } catch (e) {\n            }\n        }\n    },\n\n    /**\n     * Given a URL, check if it is in the same domain (so we can get the source\n     * via Ajax).\n     *\n     * @param url <String> source url\n     * @return False if we need a cross-domain request\n     */\n    isSameDomain: function(url) {\n        return typeof location !== \"undefined\" && url.indexOf(location.hostname) !== -1; // location may not be defined, e.g. when running from nodejs.\n    },\n\n    /**\n     * Get source code from given URL if in the same domain.\n     *\n     * @param url <String> JS source URL\n     * @return <Array> Array of source code lines\n     */\n    getSource: function(url) {\n        // TODO reuse source from script tags?\n        if (!(url in this.sourceCache)) {\n            this.sourceCache[url] = this.ajax(url).split('\\n');\n        }\n        return this.sourceCache[url];\n    },\n\n    guessAnonymousFunctions: function(stack) {\n        for (var i = 0; i < stack.length; ++i) {\n            var reStack = /\\{anonymous\\}\\(.*\\)@(.*)/,\n                reRef = /^(.*?)(?::(\\d+))(?::(\\d+))?(?: -- .+)?$/,\n                frame = stack[i], ref = reStack.exec(frame);\n\n            if (ref) {\n                var m = reRef.exec(ref[1]);\n                if (m) { // If falsey, we did not get any file/line information\n                    var file = m[1], lineno = m[2], charno = m[3] || 0;\n                    if (file && this.isSameDomain(file) && lineno) {\n                        var functionName = this.guessAnonymousFunction(file, lineno, charno);\n                        stack[i] = frame.replace('{anonymous}', functionName);\n                    }\n                }\n            }\n        }\n        return stack;\n    },\n\n    guessAnonymousFunction: function(url, lineNo, charNo) {\n        var ret;\n        try {\n            ret = this.findFunctionName(this.getSource(url), lineNo);\n        } catch (e) {\n            ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();\n        }\n        return ret;\n    },\n\n    findFunctionName: function(source, lineNo) {\n        // FIXME findFunctionName fails for compressed source\n        // (more than one function on the same line)\n        // TODO use captured args\n        // function {name}({args}) m[1]=name m[2]=args\n        var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\n        // {name} = function ({args}) TODO args capture\n        // /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function(?:[^(]*)/\n        var reFunctionExpression = /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function\\b/;\n        // {name} = eval()\n        var reFunctionEvaluation = /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\n        // Walk backwards in the source lines until we find\n        // the line which matches one of the patterns above\n        var code = \"\", line, maxLines = Math.min(lineNo, 20), m, commentPos;\n        for (var i = 0; i < maxLines; ++i) {\n            // lineNo is 1-based, source[] is 0-based\n            line = source[lineNo - i - 1];\n            commentPos = line.indexOf('//');\n            if (commentPos >= 0) {\n                line = line.substr(0, commentPos);\n            }\n            // TODO check other types of comments? Commented code may lead to false positive\n            if (line) {\n                code = line + code;\n                m = reFunctionExpression.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n                m = reFunctionDeclaration.exec(code);\n                if (m && m[1]) {\n                    //return m[1] + \"(\" + (m[2] || \"\") + \")\";\n                    return m[1];\n                }\n                m = reFunctionEvaluation.exec(code);\n                if (m && m[1]) {\n                    return m[1];\n                }\n            }\n        }\n        return '(?)';\n    }\n};\n",
    "/**\n * gamecore.js - Copyright 2012 Playcraft Labs, Inc. (see licence.txt)\n * pool.js\n */\n\n/**\n * @class gamecore.Pool\n * Easy (high-performance) object pooling\n *\n * A pool of objects for use in situations where you want to minimize object life cycling (and\n * subsequently garbage collection). It also serves as a very high speed, minimal overhead\n * collection for small numbers of objects.\n * <p>\n * This class maintains mutual an array of objects which are free. If you wish to maintain a list of both\n * free and used then see the gamecore.DualPool.\n * <p>\n * Pools are managed by class type, and will auto-expand as required. You can create a custom initial pool\n * size by deriving from the Pool class and statically overriding INITIAL_POOL_SIZE.\n * <p>\n * Keep in mind that objects that are pooled are not constructed; they are \"reset\" when handed out.\n * You need to \"acquire\" one and then reset its state, usually via a static create factory method.\n * <p>\n * Example:\n * <pre><code>\n * Point = gamecore.Pooled('Point',\n * {\n *   // Static constructor\n *   create:function (x, y)\n *   {\n *      var n = this._super();\n *      n.x = x;\n *      n.y = y;\n *      return n;\n *   }\n * },\n * {\n *    x:0, y:0,   // instance\n *\n *    init: function(x, y)\n *    {\n *       this.x = x;\n *       this.y = y;\n *    }\n * }\n * </code></pre>\n * To then access the object from the pool, use create, instead of new. Then release it.\n * <pre><code>\n * var p = Point.create(100, 100);\n * // ... do something\n * p.release();\n * </code></pre>\n *\n */\n\ngamecore.Pool = gamecore.Base.extend('gamecore.Pool',\n    /** @lends gamecore.Pool */\n    {\n        /** Initial size of all object pools */\n        INITIAL_POOL_SIZE:1,\n\n        /** Hashtable of ALL the object pools */\n        pools:new gamecore.Hashtable(),\n        /** total objects in all pools */\n        totalPooled:0,\n        /** total objects in use right now */\n        totalUsed:0,\n\n        /**\n         * Acquire an object from a pool based on the class[name]. Typically this method is\n         * automatically called from Pooled.create method and should not be used directly.\n         * @param {String} classType Class of object to create\n         * @return {gamecore.Pooled} A shiny object you can then configure\n         */\n        acquire:function (classType)\n        {\n            var pool = this.getPool(classType);\n            if (pool == undefined || pool == null)\n            {\n                // create a pool for this type of class\n                //this.info('Constructing a new pool for ' + classType.fullName + ' objects.');\n                pool = new gamecore.Pool(classType, this.INITIAL_POOL_SIZE);\n                this.pools.put(classType.fullName, pool);\n            }\n\n            return pool.acquire();\n        },\n\n        /**\n         * Releases an object back into it's corresponding object pool\n         * @param {gamecore.Pooled} pooledObj Object to return to the pool\n         */\n        release:function (pooledObj)\n        {\n            var pool = this.pools.get(pooledObj.Class.fullName);\n            if (pool == undefined)\n                throw \"Oops, trying to release an object of type \" + pooledObj.Class.fullName +\n                    \" but no pool exists. Did you new an object instead of using create.\";\n\n            pool.release(pooledObj);\n        },\n\n        /**\n         * Returns the pool associated with the given classType, or null if no pool currently exists.\n         * @return {gamecore.Pool} Object pool associated with the class type\n         */\n        getPool:function (classType)\n        {\n            return this.pools.get(classType.fullName);\n        },\n\n        /**\n         * Gets stats on the usage of all pools.\n         * @return {String} Stats string\n         */\n        getStats:function ()\n        {\n            var s = '';\n\n            var keys = this.pools.keys();\n            for (var i = 0; i < keys.length; i++)\n            {\n                var key = keys[i];\n                var pool = this.pools.get(key);\n                s += key + ': ' + pool.getStats()  + '\\n';\n            }\n\n            return s;\n        }\n\n    },\n    /** @lends gamecore.Pool.prototype */\n    {\n        /** Linked list of currently free objects residing in the pool */\n        freeList:null,\n        /** Current number of items to expand by: will increase with every expansion */\n        expansion: 1,\n        /** Array of traces currently active. Tracing must be on. */\n        traces: null,\n\n        /**\n         * Constructs a pool. Will automatically be called by the static pool method. Generally not called directly.\n         * @param {String} classType Class name of the type of objects in the pool\n         * @param {Number} initial Starting number of objects in the pool\n         */\n        init:function (classType, initial)\n        {\n            this._super();\n            this.classType = classType;\n            this.freeList = [];\n\n            // instantiate the initial objects for the pool\n            this.expand(initial);\n        },\n\n        /**\n         * Enables tracing on this pool.\n         */\n        startTracing:function ()\n        {\n            if (this.tracing) return;\n            this.tracing = true;\n            if (this.traces)\n                this.traces.clear();\n            else\n                this.traces = new gamecore.Hashtable();\n        },\n\n        /**\n         * Disables tracing on this pool.\n         */\n        stopTracing:function ()\n        {\n            this.tracing = false;\n        },\n\n        /**\n         * Expand the pool of objects by constructing a bunch of new ones. The pool will\n         * automatically expand itself by 10% each time it runs out of space, so generally you\n         * shouldn't need to use this.\n         * @param {Number} howMany Number of new objects you want to add\n         */\n        expand:function (howMany)\n        {\n            gamecore.Pool.totalPooled += howMany;\n\n            //debug: if you want to track expansion\n            //this.debug('expanding ' + this.classType.fullName + ' by ' + howMany + ' total=' + gamecore.Pool.totalPooled);\n\n            for (var i = 0; i < howMany; i++)\n                this.freeList.push(new this.classType());\n        },\n\n        /**\n         * Gets the free count of objects left in the pool\n         * @return {Number} Number free\n         */\n        getFreeCount: function()\n        {\n            return this.freeList.length;\n        },\n\n        /**\n         * Returns the next free object by moving it from the free pool to the used one. If no free objects are\n         * available it will expand the pool\n         * @return {gamecore.Pooled} A pooled object\n         */\n        acquire:function ()\n        {\n            // check if we have anymore to give out\n            if (this.freeList.length <= 0)\n            {\n                // create some more space (expand by 20%, minimum 1)\n                this.expansion = Math.round(this.expansion*1.2)+1;\n                this.expand(this.expansion);\n            }\n\n            if (this.tracing)\n            {\n                var stack = printStackTrace();\n                var pos = stack.length - 1;\n                while (stack[pos].indexOf('Class.addTo') == 0 && pos > 0)\n                    pos--;\n                var count = this.traces.get(stack[pos]);\n                if (count == null)\n                    this.traces.put(stack[pos], { value:1 });\n                else\n                    count.value++;\n            }\n\n            return this.freeList.pop();\n        },\n\n        /**\n         * Releases an object by moving it back onto the free pool\n         * @param {gamecore.Pooled} obj The obj to release back into the pool\n         */\n        release:function (obj)\n        {\n            this.freeList.push(obj);\n        },\n\n        /**\n         * Gets stats about the pool\n         * @return {String} Stats\n         */\n        getStats:function ()\n        {\n            var s = this.Class.fullName + ' stats: ' + this.freeList.length + ' free.';\n\n            if (this.tracing)\n            {\n                s += 'TRACING\\n';\n                var traceKeys = this.traces.keys();\n                for (var k in traceKeys)\n                    s += traceKeys[k] + ' (' + this.traces.get(traceKeys[k]).value + ')\\n';\n            }\n            return s;\n        },\n\n        /**\n         * Dumps contents of the pool to through info logging (usually console). Mostly used for debugging the pooling\n         * system, mostly.\n         * @param {String} msg A string to write before the dump\n         */\n        dump:function (msg)\n        {\n            this.info('================== ' + msg + ' ===================');\n            this.info('FREE');\n            this.freeList.dump();\n        },\n\n        /**\n         * Returns the number of objects in the pool\n         * @return {Number} Total objects\n         */\n        size:function ()\n        {\n            return this.freeList.length;\n        },\n\n        /**\n         * Returns the LinkedList of currently free objects in the pool\n         * @return {gamecore.LinkedList} List of free objects\n         */\n        getFreeList:function ()\n        {\n            return this.freeList;\n        }\n\n    });\n\n/**\n * @class gamecore.DualPool\n * @description\n * Easy (high-performance) object pooling\n *\n * A pool of objects for use in situations where you want to minimize object life cycling (and\n * subsequently garbage collection). It also serves as a very high speed, minimal overhead\n * collection for small numbers of objects.\n * <p>\n * This class maintains mutual set of doubly-linked lists in order to differentiate between\n * objects that are in use and those that are unallocated from the pool. This allows for much\n * faster cycling of only the in-use objects.\n * <p>\n * Pools are managed by class type, and will auto-expand as required. You can create a custom initial pool\n * size by deriving from the Pool class and statically overriding INITIAL_POOL_SIZE.\n * <p>\n * Keep in mind that objects that are pooled are not constructed; they are \"reset\" when handed out.\n * You need to \"acquire\" one and then reset its state, usually via a static create factory method.\n * <p>\n * Example:\n * <code>\n * Point = gamecore.Pooled('Point',\n * {\n *   // Static constructor\n *   create:function (x, y)\n *   {\n *      var n = this._super();\n *      n.x = x;\n *      n.y = y;\n *      return n;\n *   }\n * },\n * {\n *    x:0, y:0,   // instance\n *\n *    init: function(x, y)\n *    {\n *       this.x = x;\n *       this.y = y;\n *    }\n * }\n * </code>\n * To then access the object from the pool, use create, instead of new. Then release it.\n * <code>\n * var p = Point.create(100, 100);\n * // ... do something\n * p.release();\n * </code>\n *\n */\ngamecore.DualPool = gamecore.Pool.extend('gamecore.DualPool',\n    /** @lends gamecore.DualPool */\n    {\n        /**\n         * Acquire an object from a pool based on the class[name]. Typically this method is\n         * automatically called from Pooled.create method and should not be used directly.\n         * @param {String} classType Class of object to create\n         * @return {gamecore.Pooled} A shiny object you can then configure\n         */\n        acquire:function (classType)\n        {\n            var pool = this.getPool(classType);\n            if (pool == undefined || pool == null)\n            {\n                pool = new gamecore.DualPool(classType, this.INITIAL_POOL_SIZE);\n                this.pools.put(classType.fullName, pool);\n            }\n\n            return pool.acquire();\n        },\n\n        /**\n         * Gets stats on the usage of all pools.\n         * @return {String} Stats string\n         */\n        getStats:function ()\n        {\n            var s = '';\n\n            var keys = this.pools.keys();\n            for (var i = 0; i < keys.length; i++)\n            {\n                var key = keys[i];\n                var pool = this.pools.get(key);\n                s += key + ' (free: ' + pool.freeList.length() + ' used: ' + pool.usedList.length() + ')\\n';\n            }\n            return s;\n        }\n    },\n    /** @lends gamecore.DualPool.prototype */\n    {\n        /** Linked list of currently free objects residing in the pool */\n        freeList:null,\n        /** Linked list of currently used objects not in the pool */\n        usedList:null,\n\n        /**\n         * Constructs a pool. Will automatically be called by the static pool method. Generally not called directly.\n         * @param {String} classType Class name of the type of objects in the pool\n         * @param {Number} initial Starting number of objects in the pool\n         */\n        init:function (classType, initial)\n        {\n            this.classType = classType;\n            this.usedList = new gamecore.LinkedList();\n            this.freeList = new gamecore.LinkedList();\n\n            // instantiate the initial objects for the pool\n            this.expand(initial);\n        },\n\n        /**\n         * Expand the pool of objects by constructing a bunch of new ones. The pool will\n         * automatically expand itself by 10% each time it runs out of space, so generally you\n         * shouldn't need to use this.\n         * @param {Number} howMany Number of new objects you want to add\n         */\n        expand:function (howMany)\n        {\n//            this.info('Expanding ' + this.classType.fullName + ' pool from ' + this.size() +\n//                ' to ' + (this.size() + howMany) + ' objects');\n            gamecore.Pool.totalPooled += howMany;\n            for (var i = 0; i < howMany; i++)\n                this.freeList.add(new this.classType());\n        },\n\n        returnObj:null,\n\n        /**\n         * Returns the next free object by moving it from the free pool to the used one.\n         * @return {gamecore.DualPooled} A pooled object you can then configure\n         */\n        acquire:function ()\n        {\n            // check if we have anymore to give out\n            if (this.freeList.first == null)\n            // create some more space (expand by 20%, minimum 1)\n                this.expand(Math.round(this.size() / 5) + 1);\n\n            this.returnObj = this.freeList.first.obj;\n            this.freeList.remove(this.returnObj);\n            this.returnObj.destroyed = false;\n            this.usedList.add(this.returnObj);\n\n            if (this.tracing)\n            {\n                var stack = printStackTrace();\n                var pos = stack.length - 1;\n                while (stack[pos].indexOf('Class.addTo') == 0 && pos > 0)\n                    pos--;\n                var count = this.traces.get(stack[pos]);\n                if (count == null)\n                    this.traces.put(stack[pos], { value:1 });\n                else\n                    count.value++;\n            }\n\n            return this.returnObj;\n        },\n\n        /**\n         * Releases an object by moving it from the used list back to the free list.\n         * @param obj {gamecore.DualPooled} The obj to release back into the pool\n         */\n        release:function (obj)\n        {\n            this.freeList.add(obj);\n            this.usedList.remove(obj);\n        },\n\n        /**\n         * Dumps stats about usage to the debug info (generally console)\n         * @param {String} msg Message to display before the dump\n         */\n        dump:function (msg)\n        {\n            this.info('================== ' + msg + ' ===================');\n            this.info('FREE');\n            this.freeList.dump();\n            this.info('USED');\n            this.usedList.dump();\n        },\n\n        /**\n         * Returns the number of objects in both the free and used pool\n         */\n        size:function ()\n        {\n            return this.freeList.count + this.usedList.count;\n        },\n\n        /**\n         * Returns the LinkedList of current used objects\n         * @return {gamecore.LinkedList}\n         */\n        getUsedList:function ()\n        {\n            return this.usedList;\n        }\n    });\n\n\n/**\n * @class gamecore.Pooled\n * @description\n * Used as a base class for objects which are life cycle managed in an object pool.\n */\ngamecore.Pooled = gamecore.Base('gamecore.Pooled',\n    /** @lends gamecore.Pooled */\n    {\n        /**\n         * Static factory method for creating a new object based on its class. This method\n         * should be called using this._super from the Class.create that derives from this.\n         * @returns {gamecore.Pooled} An object from the pool\n         */\n        create:function ()\n        {\n            return gamecore.Pool.acquire(this);\n        },\n\n        /**\n         * Get the object pool associated with this object class\n         * @return {gamecore.Pool} The object pool\n         */\n        getPool:function ()\n        {\n            return gamecore.Pool.getPool(this);\n        }\n\n    },\n    /** @lends gamecore.Pooled.prototype */\n    {\n        /** Has the object been destroyed (returned to the pool) */\n        destroyed:false,\n\n        /**\n         * Constructor for the object (default calls base class init)\n         */\n        init:function ()\n        {\n            this._super();\n        },\n\n        /**\n         * Release the object back into the pool\n         */\n        release:function ()\n        {\n            this.onRelease();\n            gamecore.Pool.release(this);\n        },\n\n        /**\n         * Template callback when an object is released; gives you a chance to do your own cleanup / releasing\n         */\n        onRelease:function ()\n        {\n        }\n\n    });\n\n\n/**\n * @class gamecore.DualPooled\n * @description\n * Used as a base class for objects which are life cycle managed in an object pool (the DualPool edition)\n */\ngamecore.DualPooled = gamecore.Base('gamecore.DualPooled',\n    /** @lends gamecore.DualPool */\n    {\n        /**\n         * Static factory method for creating a new object based on its class. This method\n         * should be called using this._super from the Class.create that derives from this.\n         * @returns {gamecore.Pooled} An object from the pool\n         */\n        create:function ()\n        {\n            return gamecore.DualPool.acquire(this);\n        },\n\n        /**\n         * Get the object pool associated with this object class\n         * @return {gamecore.Pool} The object pool\n         */\n        getPool:function ()\n        {\n            return gamecore.DualPool.getPool(this);\n        }\n\n    },\n    /** @lends gamecore.DualPool.prototype */\n    {\n        /** Has the object been destroyed (returned to the pool) */\n        destroyed:false,\n\n        /**\n         * Constructor for the object (default calls base class init)\n         */\n        init:function ()\n        {\n            this._super();\n        },\n\n        /**\n         * Release the object back into the pool\n         */\n        release:function ()\n        {\n            this.onRelease();\n            gamecore.DualPool.release(this);\n        },\n\n        /**\n         * Template callback when an object is released; gives you a chance to do your own cleanup / releasing\n         */\n        onRelease:function ()\n        {\n        }\n\n    });\n"
  ]
}